"use strict";(self["webpackChunk_vue_devtools"]=self["webpackChunk_vue_devtools"]||[]).push([[2501],{32501:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"getJavaScriptWorker\": () => (/* binding */ getJavaScriptWorker),\n  \"getTypeScriptWorker\": () => (/* binding */ getTypeScriptWorker),\n  \"setupJavaScript\": () => (/* binding */ setupJavaScript),\n  \"setupTypeScript\": () => (/* binding */ setupTypeScript)\n});\n\n// EXTERNAL MODULE: ../../node_modules/monaco-editor/esm/vs/language/typescript/fillers/monaco-editor-core.js\nvar monaco_editor_core = __webpack_require__(67181);\n;// CONCATENATED MODULE: ../../node_modules/monaco-editor/esm/vs/language/typescript/workerManager.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (undefined && undefined.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\n\nvar WorkerManager = /** @class */ (function () {\n    function WorkerManager(modeId, defaults) {\n        var _this = this;\n        this._modeId = modeId;\n        this._defaults = defaults;\n        this._worker = null;\n        this._client = null;\n        this._configChangeListener = this._defaults.onDidChange(function () { return _this._stopWorker(); });\n        this._updateExtraLibsToken = 0;\n        this._extraLibsChangeListener = this._defaults.onDidExtraLibsChange(function () {\n            return _this._updateExtraLibs();\n        });\n    }\n    WorkerManager.prototype._stopWorker = function () {\n        if (this._worker) {\n            this._worker.dispose();\n            this._worker = null;\n        }\n        this._client = null;\n    };\n    WorkerManager.prototype.dispose = function () {\n        this._configChangeListener.dispose();\n        this._extraLibsChangeListener.dispose();\n        this._stopWorker();\n    };\n    WorkerManager.prototype._updateExtraLibs = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var myToken, proxy;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!this._worker) {\n                            return [2 /*return*/];\n                        }\n                        myToken = ++this._updateExtraLibsToken;\n                        return [4 /*yield*/, this._worker.getProxy()];\n                    case 1:\n                        proxy = _a.sent();\n                        if (this._updateExtraLibsToken !== myToken) {\n                            // avoid multiple calls\n                            return [2 /*return*/];\n                        }\n                        proxy.updateExtraLibs(this._defaults.getExtraLibs());\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    WorkerManager.prototype._getClient = function () {\n        var _this = this;\n        if (!this._client) {\n            this._worker = monaco_editor_core/* editor.createWebWorker */.j6.createWebWorker({\n                // module that exports the create() method and returns a `TypeScriptWorker` instance\n                moduleId: 'vs/language/typescript/tsWorker',\n                label: this._modeId,\n                keepIdleModels: true,\n                // passed in to the create() method\n                createData: {\n                    compilerOptions: this._defaults.getCompilerOptions(),\n                    extraLibs: this._defaults.getExtraLibs(),\n                    customWorkerPath: this._defaults.workerOptions.customWorkerPath\n                }\n            });\n            var p = this._worker.getProxy();\n            if (this._defaults.getEagerModelSync()) {\n                p = p.then(function (worker) {\n                    if (_this._worker) {\n                        return _this._worker.withSyncedResources(monaco_editor_core/* editor.getModels */.j6.getModels()\n                            .filter(function (model) { return model.getModeId() === _this._modeId; })\n                            .map(function (model) { return model.uri; }));\n                    }\n                    return worker;\n                });\n            }\n            this._client = p;\n        }\n        return this._client;\n    };\n    WorkerManager.prototype.getLanguageServiceWorker = function () {\n        var _this = this;\n        var resources = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            resources[_i] = arguments[_i];\n        }\n        var _client;\n        return this._getClient()\n            .then(function (client) {\n            _client = client;\n        })\n            .then(function (_) {\n            if (_this._worker) {\n                return _this._worker.withSyncedResources(resources);\n            }\n        })\n            .then(function (_) { return _client; });\n    };\n    return WorkerManager;\n}());\n\n\n;// CONCATENATED MODULE: ../../node_modules/monaco-editor/esm/vs/language/typescript/lib/lib.index.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n//\n// **NOTE**: Do not edit directly! This file is generated using `npm run import-typescript`\n//\n/** Contains all the lib files */\nvar libFileSet = {};\nlibFileSet['lib.d.ts'] = true;\nlibFileSet['lib.dom.d.ts'] = true;\nlibFileSet['lib.dom.iterable.d.ts'] = true;\nlibFileSet['lib.es2015.collection.d.ts'] = true;\nlibFileSet['lib.es2015.core.d.ts'] = true;\nlibFileSet['lib.es2015.d.ts'] = true;\nlibFileSet['lib.es2015.generator.d.ts'] = true;\nlibFileSet['lib.es2015.iterable.d.ts'] = true;\nlibFileSet['lib.es2015.promise.d.ts'] = true;\nlibFileSet['lib.es2015.proxy.d.ts'] = true;\nlibFileSet['lib.es2015.reflect.d.ts'] = true;\nlibFileSet['lib.es2015.symbol.d.ts'] = true;\nlibFileSet['lib.es2015.symbol.wellknown.d.ts'] = true;\nlibFileSet['lib.es2016.array.include.d.ts'] = true;\nlibFileSet['lib.es2016.d.ts'] = true;\nlibFileSet['lib.es2016.full.d.ts'] = true;\nlibFileSet['lib.es2017.d.ts'] = true;\nlibFileSet['lib.es2017.full.d.ts'] = true;\nlibFileSet['lib.es2017.intl.d.ts'] = true;\nlibFileSet['lib.es2017.object.d.ts'] = true;\nlibFileSet['lib.es2017.sharedmemory.d.ts'] = true;\nlibFileSet['lib.es2017.string.d.ts'] = true;\nlibFileSet['lib.es2017.typedarrays.d.ts'] = true;\nlibFileSet['lib.es2018.asyncgenerator.d.ts'] = true;\nlibFileSet['lib.es2018.asynciterable.d.ts'] = true;\nlibFileSet['lib.es2018.d.ts'] = true;\nlibFileSet['lib.es2018.full.d.ts'] = true;\nlibFileSet['lib.es2018.intl.d.ts'] = true;\nlibFileSet['lib.es2018.promise.d.ts'] = true;\nlibFileSet['lib.es2018.regexp.d.ts'] = true;\nlibFileSet['lib.es2019.array.d.ts'] = true;\nlibFileSet['lib.es2019.d.ts'] = true;\nlibFileSet['lib.es2019.full.d.ts'] = true;\nlibFileSet['lib.es2019.object.d.ts'] = true;\nlibFileSet['lib.es2019.string.d.ts'] = true;\nlibFileSet['lib.es2019.symbol.d.ts'] = true;\nlibFileSet['lib.es2020.bigint.d.ts'] = true;\nlibFileSet['lib.es2020.d.ts'] = true;\nlibFileSet['lib.es2020.full.d.ts'] = true;\nlibFileSet['lib.es2020.intl.d.ts'] = true;\nlibFileSet['lib.es2020.promise.d.ts'] = true;\nlibFileSet['lib.es2020.sharedmemory.d.ts'] = true;\nlibFileSet['lib.es2020.string.d.ts'] = true;\nlibFileSet['lib.es2020.symbol.wellknown.d.ts'] = true;\nlibFileSet['lib.es5.d.ts'] = true;\nlibFileSet['lib.es6.d.ts'] = true;\nlibFileSet['lib.esnext.d.ts'] = true;\nlibFileSet['lib.esnext.full.d.ts'] = true;\nlibFileSet['lib.esnext.intl.d.ts'] = true;\nlibFileSet['lib.esnext.promise.d.ts'] = true;\nlibFileSet['lib.esnext.string.d.ts'] = true;\nlibFileSet['lib.esnext.weakref.d.ts'] = true;\nlibFileSet['lib.scripthost.d.ts'] = true;\nlibFileSet['lib.webworker.d.ts'] = true;\nlibFileSet['lib.webworker.importscripts.d.ts'] = true;\nlibFileSet['lib.webworker.iterable.d.ts'] = true;\n\n;// CONCATENATED MODULE: ../../node_modules/monaco-editor/esm/vs/language/typescript/languageFeatures.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar languageFeatures_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar languageFeatures_generator = (undefined && undefined.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\n\n\n//#region utils copied from typescript to prevent loading the entire typescriptServices ---\nvar IndentStyle;\n(function (IndentStyle) {\n    IndentStyle[IndentStyle[\"None\"] = 0] = \"None\";\n    IndentStyle[IndentStyle[\"Block\"] = 1] = \"Block\";\n    IndentStyle[IndentStyle[\"Smart\"] = 2] = \"Smart\";\n})(IndentStyle || (IndentStyle = {}));\nfunction flattenDiagnosticMessageText(diag, newLine, indent) {\n    if (indent === void 0) { indent = 0; }\n    if (typeof diag === 'string') {\n        return diag;\n    }\n    else if (diag === undefined) {\n        return '';\n    }\n    var result = '';\n    if (indent) {\n        result += newLine;\n        for (var i = 0; i < indent; i++) {\n            result += '  ';\n        }\n    }\n    result += diag.messageText;\n    indent++;\n    if (diag.next) {\n        for (var _i = 0, _a = diag.next; _i < _a.length; _i++) {\n            var kid = _a[_i];\n            result += flattenDiagnosticMessageText(kid, newLine, indent);\n        }\n    }\n    return result;\n}\nfunction displayPartsToString(displayParts) {\n    if (displayParts) {\n        return displayParts.map(function (displayPart) { return displayPart.text; }).join('');\n    }\n    return '';\n}\n//#endregion\nvar Adapter = /** @class */ (function () {\n    function Adapter(_worker) {\n        this._worker = _worker;\n    }\n    // protected _positionToOffset(model: editor.ITextModel, position: monaco.IPosition): number {\n    // \treturn model.getOffsetAt(position);\n    // }\n    // protected _offsetToPosition(model: editor.ITextModel, offset: number): monaco.IPosition {\n    // \treturn model.getPositionAt(offset);\n    // }\n    Adapter.prototype._textSpanToRange = function (model, span) {\n        var p1 = model.getPositionAt(span.start);\n        var p2 = model.getPositionAt(span.start + span.length);\n        var startLineNumber = p1.lineNumber, startColumn = p1.column;\n        var endLineNumber = p2.lineNumber, endColumn = p2.column;\n        return { startLineNumber: startLineNumber, startColumn: startColumn, endLineNumber: endLineNumber, endColumn: endColumn };\n    };\n    return Adapter;\n}());\n\n// --- lib files\nvar LibFiles = /** @class */ (function () {\n    function LibFiles(_worker) {\n        this._worker = _worker;\n        this._libFiles = {};\n        this._hasFetchedLibFiles = false;\n        this._fetchLibFilesPromise = null;\n    }\n    LibFiles.prototype.isLibFile = function (uri) {\n        if (!uri) {\n            return false;\n        }\n        if (uri.path.indexOf('/lib.') === 0) {\n            return !!libFileSet[uri.path.slice(1)];\n        }\n        return false;\n    };\n    LibFiles.prototype.getOrCreateModel = function (uri) {\n        var model = monaco_editor_core/* editor.getModel */.j6.getModel(uri);\n        if (model) {\n            return model;\n        }\n        if (this.isLibFile(uri) && this._hasFetchedLibFiles) {\n            return monaco_editor_core/* editor.createModel */.j6.createModel(this._libFiles[uri.path.slice(1)], 'typescript', uri);\n        }\n        return null;\n    };\n    LibFiles.prototype._containsLibFile = function (uris) {\n        for (var _i = 0, uris_1 = uris; _i < uris_1.length; _i++) {\n            var uri = uris_1[_i];\n            if (this.isLibFile(uri)) {\n                return true;\n            }\n        }\n        return false;\n    };\n    LibFiles.prototype.fetchLibFilesIfNecessary = function (uris) {\n        return languageFeatures_awaiter(this, void 0, void 0, function () {\n            return languageFeatures_generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!this._containsLibFile(uris)) {\n                            // no lib files necessary\n                            return [2 /*return*/];\n                        }\n                        return [4 /*yield*/, this._fetchLibFiles()];\n                    case 1:\n                        _a.sent();\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    LibFiles.prototype._fetchLibFiles = function () {\n        var _this = this;\n        if (!this._fetchLibFilesPromise) {\n            this._fetchLibFilesPromise = this._worker()\n                .then(function (w) { return w.getLibFiles(); })\n                .then(function (libFiles) {\n                _this._hasFetchedLibFiles = true;\n                _this._libFiles = libFiles;\n            });\n        }\n        return this._fetchLibFilesPromise;\n    };\n    return LibFiles;\n}());\n\n// --- diagnostics --- ---\nvar DiagnosticCategory;\n(function (DiagnosticCategory) {\n    DiagnosticCategory[DiagnosticCategory[\"Warning\"] = 0] = \"Warning\";\n    DiagnosticCategory[DiagnosticCategory[\"Error\"] = 1] = \"Error\";\n    DiagnosticCategory[DiagnosticCategory[\"Suggestion\"] = 2] = \"Suggestion\";\n    DiagnosticCategory[DiagnosticCategory[\"Message\"] = 3] = \"Message\";\n})(DiagnosticCategory || (DiagnosticCategory = {}));\nvar DiagnosticsAdapter = /** @class */ (function (_super) {\n    __extends(DiagnosticsAdapter, _super);\n    function DiagnosticsAdapter(_libFiles, _defaults, _selector, worker) {\n        var _this = _super.call(this, worker) || this;\n        _this._libFiles = _libFiles;\n        _this._defaults = _defaults;\n        _this._selector = _selector;\n        _this._disposables = [];\n        _this._listener = Object.create(null);\n        var onModelAdd = function (model) {\n            if (model.getModeId() !== _selector) {\n                return;\n            }\n            var maybeValidate = function () {\n                var onlyVisible = _this._defaults.getDiagnosticsOptions().onlyVisible;\n                if (onlyVisible) {\n                    if (model.isAttachedToEditor()) {\n                        _this._doValidate(model);\n                    }\n                }\n                else {\n                    _this._doValidate(model);\n                }\n            };\n            var handle;\n            var changeSubscription = model.onDidChangeContent(function () {\n                clearTimeout(handle);\n                handle = setTimeout(maybeValidate, 500);\n            });\n            var visibleSubscription = model.onDidChangeAttached(function () {\n                var onlyVisible = _this._defaults.getDiagnosticsOptions().onlyVisible;\n                if (onlyVisible) {\n                    if (model.isAttachedToEditor()) {\n                        // this model is now attached to an editor\n                        // => compute diagnostics\n                        maybeValidate();\n                    }\n                    else {\n                        // this model is no longer attached to an editor\n                        // => clear existing diagnostics\n                        monaco_editor_core/* editor.setModelMarkers */.j6.setModelMarkers(model, _this._selector, []);\n                    }\n                }\n            });\n            _this._listener[model.uri.toString()] = {\n                dispose: function () {\n                    changeSubscription.dispose();\n                    visibleSubscription.dispose();\n                    clearTimeout(handle);\n                }\n            };\n            maybeValidate();\n        };\n        var onModelRemoved = function (model) {\n            monaco_editor_core/* editor.setModelMarkers */.j6.setModelMarkers(model, _this._selector, []);\n            var key = model.uri.toString();\n            if (_this._listener[key]) {\n                _this._listener[key].dispose();\n                delete _this._listener[key];\n            }\n        };\n        _this._disposables.push(monaco_editor_core/* editor.onDidCreateModel */.j6.onDidCreateModel(function (model) { return onModelAdd(model); }));\n        _this._disposables.push(monaco_editor_core/* editor.onWillDisposeModel */.j6.onWillDisposeModel(onModelRemoved));\n        _this._disposables.push(monaco_editor_core/* editor.onDidChangeModelLanguage */.j6.onDidChangeModelLanguage(function (event) {\n            onModelRemoved(event.model);\n            onModelAdd(event.model);\n        }));\n        _this._disposables.push({\n            dispose: function () {\n                for (var _i = 0, _a = monaco_editor_core/* editor.getModels */.j6.getModels(); _i < _a.length; _i++) {\n                    var model = _a[_i];\n                    onModelRemoved(model);\n                }\n            }\n        });\n        var recomputeDiagostics = function () {\n            // redo diagnostics when options change\n            for (var _i = 0, _a = monaco_editor_core/* editor.getModels */.j6.getModels(); _i < _a.length; _i++) {\n                var model = _a[_i];\n                onModelRemoved(model);\n                onModelAdd(model);\n            }\n        };\n        _this._disposables.push(_this._defaults.onDidChange(recomputeDiagostics));\n        _this._disposables.push(_this._defaults.onDidExtraLibsChange(recomputeDiagostics));\n        monaco_editor_core/* editor.getModels */.j6.getModels().forEach(function (model) { return onModelAdd(model); });\n        return _this;\n    }\n    DiagnosticsAdapter.prototype.dispose = function () {\n        this._disposables.forEach(function (d) { return d && d.dispose(); });\n        this._disposables = [];\n    };\n    DiagnosticsAdapter.prototype._doValidate = function (model) {\n        return languageFeatures_awaiter(this, void 0, void 0, function () {\n            var worker, promises, _a, noSyntaxValidation, noSemanticValidation, noSuggestionDiagnostics, allDiagnostics, diagnostics, relatedUris;\n            var _this = this;\n            return languageFeatures_generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0: return [4 /*yield*/, this._worker(model.uri)];\n                    case 1:\n                        worker = _b.sent();\n                        if (model.isDisposed()) {\n                            // model was disposed in the meantime\n                            return [2 /*return*/];\n                        }\n                        promises = [];\n                        _a = this._defaults.getDiagnosticsOptions(), noSyntaxValidation = _a.noSyntaxValidation, noSemanticValidation = _a.noSemanticValidation, noSuggestionDiagnostics = _a.noSuggestionDiagnostics;\n                        if (!noSyntaxValidation) {\n                            promises.push(worker.getSyntacticDiagnostics(model.uri.toString()));\n                        }\n                        if (!noSemanticValidation) {\n                            promises.push(worker.getSemanticDiagnostics(model.uri.toString()));\n                        }\n                        if (!noSuggestionDiagnostics) {\n                            promises.push(worker.getSuggestionDiagnostics(model.uri.toString()));\n                        }\n                        return [4 /*yield*/, Promise.all(promises)];\n                    case 2:\n                        allDiagnostics = _b.sent();\n                        if (!allDiagnostics || model.isDisposed()) {\n                            // model was disposed in the meantime\n                            return [2 /*return*/];\n                        }\n                        diagnostics = allDiagnostics\n                            .reduce(function (p, c) { return c.concat(p); }, [])\n                            .filter(function (d) {\n                            return (_this._defaults.getDiagnosticsOptions().diagnosticCodesToIgnore || []).indexOf(d.code) ===\n                                -1;\n                        });\n                        relatedUris = diagnostics\n                            .map(function (d) { return d.relatedInformation || []; })\n                            .reduce(function (p, c) { return c.concat(p); }, [])\n                            .map(function (relatedInformation) {\n                            return relatedInformation.file ? monaco_editor_core/* Uri.parse */.Sf.parse(relatedInformation.file.fileName) : null;\n                        });\n                        return [4 /*yield*/, this._libFiles.fetchLibFilesIfNecessary(relatedUris)];\n                    case 3:\n                        _b.sent();\n                        if (model.isDisposed()) {\n                            // model was disposed in the meantime\n                            return [2 /*return*/];\n                        }\n                        monaco_editor_core/* editor.setModelMarkers */.j6.setModelMarkers(model, this._selector, diagnostics.map(function (d) { return _this._convertDiagnostics(model, d); }));\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    DiagnosticsAdapter.prototype._convertDiagnostics = function (model, diag) {\n        var diagStart = diag.start || 0;\n        var diagLength = diag.length || 1;\n        var _a = model.getPositionAt(diagStart), startLineNumber = _a.lineNumber, startColumn = _a.column;\n        var _b = model.getPositionAt(diagStart + diagLength), endLineNumber = _b.lineNumber, endColumn = _b.column;\n        var tags = [];\n        if (diag.reportsUnnecessary) {\n            tags.push(monaco_editor_core/* MarkerTag.Unnecessary */.eB.Unnecessary);\n        }\n        if (diag.reportsDeprecated) {\n            tags.push(monaco_editor_core/* MarkerTag.Deprecated */.eB.Deprecated);\n        }\n        return {\n            severity: this._tsDiagnosticCategoryToMarkerSeverity(diag.category),\n            startLineNumber: startLineNumber,\n            startColumn: startColumn,\n            endLineNumber: endLineNumber,\n            endColumn: endColumn,\n            message: flattenDiagnosticMessageText(diag.messageText, '\\n'),\n            code: diag.code.toString(),\n            tags: tags,\n            relatedInformation: this._convertRelatedInformation(model, diag.relatedInformation)\n        };\n    };\n    DiagnosticsAdapter.prototype._convertRelatedInformation = function (model, relatedInformation) {\n        var _this = this;\n        if (!relatedInformation) {\n            return;\n        }\n        var result = [];\n        relatedInformation.forEach(function (info) {\n            var relatedResource = model;\n            if (info.file) {\n                var relatedResourceUri = monaco_editor_core/* Uri.parse */.Sf.parse(info.file.fileName);\n                relatedResource = _this._libFiles.getOrCreateModel(relatedResourceUri);\n            }\n            if (!relatedResource) {\n                return;\n            }\n            var infoStart = info.start || 0;\n            var infoLength = info.length || 1;\n            var _a = relatedResource.getPositionAt(infoStart), startLineNumber = _a.lineNumber, startColumn = _a.column;\n            var _b = relatedResource.getPositionAt(infoStart + infoLength), endLineNumber = _b.lineNumber, endColumn = _b.column;\n            result.push({\n                resource: relatedResource.uri,\n                startLineNumber: startLineNumber,\n                startColumn: startColumn,\n                endLineNumber: endLineNumber,\n                endColumn: endColumn,\n                message: flattenDiagnosticMessageText(info.messageText, '\\n')\n            });\n        });\n        return result;\n    };\n    DiagnosticsAdapter.prototype._tsDiagnosticCategoryToMarkerSeverity = function (category) {\n        switch (category) {\n            case DiagnosticCategory.Error:\n                return monaco_editor_core/* MarkerSeverity.Error */.ZL.Error;\n            case DiagnosticCategory.Message:\n                return monaco_editor_core/* MarkerSeverity.Info */.ZL.Info;\n            case DiagnosticCategory.Warning:\n                return monaco_editor_core/* MarkerSeverity.Warning */.ZL.Warning;\n            case DiagnosticCategory.Suggestion:\n                return monaco_editor_core/* MarkerSeverity.Hint */.ZL.Hint;\n        }\n        return monaco_editor_core/* MarkerSeverity.Info */.ZL.Info;\n    };\n    return DiagnosticsAdapter;\n}(Adapter));\n\nvar SuggestAdapter = /** @class */ (function (_super) {\n    __extends(SuggestAdapter, _super);\n    function SuggestAdapter() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(SuggestAdapter.prototype, \"triggerCharacters\", {\n        get: function () {\n            return ['.'];\n        },\n        enumerable: false,\n        configurable: true\n    });\n    SuggestAdapter.prototype.provideCompletionItems = function (model, position, _context, token) {\n        return languageFeatures_awaiter(this, void 0, void 0, function () {\n            var wordInfo, wordRange, resource, offset, worker, info, suggestions;\n            return languageFeatures_generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        wordInfo = model.getWordUntilPosition(position);\n                        wordRange = new monaco_editor_core/* Range */.e6(position.lineNumber, wordInfo.startColumn, position.lineNumber, wordInfo.endColumn);\n                        resource = model.uri;\n                        offset = model.getOffsetAt(position);\n                        return [4 /*yield*/, this._worker(resource)];\n                    case 1:\n                        worker = _a.sent();\n                        if (model.isDisposed()) {\n                            return [2 /*return*/];\n                        }\n                        return [4 /*yield*/, worker.getCompletionsAtPosition(resource.toString(), offset)];\n                    case 2:\n                        info = _a.sent();\n                        if (!info || model.isDisposed()) {\n                            return [2 /*return*/];\n                        }\n                        suggestions = info.entries.map(function (entry) {\n                            var _a;\n                            var range = wordRange;\n                            if (entry.replacementSpan) {\n                                var p1 = model.getPositionAt(entry.replacementSpan.start);\n                                var p2 = model.getPositionAt(entry.replacementSpan.start + entry.replacementSpan.length);\n                                range = new monaco_editor_core/* Range */.e6(p1.lineNumber, p1.column, p2.lineNumber, p2.column);\n                            }\n                            var tags = [];\n                            if (((_a = entry.kindModifiers) === null || _a === void 0 ? void 0 : _a.indexOf('deprecated')) !== -1) {\n                                tags.push(monaco_editor_core/* languages.CompletionItemTag.Deprecated */.Mj.CompletionItemTag.Deprecated);\n                            }\n                            return {\n                                uri: resource,\n                                position: position,\n                                offset: offset,\n                                range: range,\n                                label: entry.name,\n                                insertText: entry.name,\n                                sortText: entry.sortText,\n                                kind: SuggestAdapter.convertKind(entry.kind),\n                                tags: tags\n                            };\n                        });\n                        return [2 /*return*/, {\n                                suggestions: suggestions\n                            }];\n                }\n            });\n        });\n    };\n    SuggestAdapter.prototype.resolveCompletionItem = function (item, token) {\n        return languageFeatures_awaiter(this, void 0, void 0, function () {\n            var myItem, resource, position, offset, worker, details;\n            return languageFeatures_generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        myItem = item;\n                        resource = myItem.uri;\n                        position = myItem.position;\n                        offset = myItem.offset;\n                        return [4 /*yield*/, this._worker(resource)];\n                    case 1:\n                        worker = _a.sent();\n                        return [4 /*yield*/, worker.getCompletionEntryDetails(resource.toString(), offset, myItem.label)];\n                    case 2:\n                        details = _a.sent();\n                        if (!details) {\n                            return [2 /*return*/, myItem];\n                        }\n                        return [2 /*return*/, {\n                                uri: resource,\n                                position: position,\n                                label: details.name,\n                                kind: SuggestAdapter.convertKind(details.kind),\n                                detail: displayPartsToString(details.displayParts),\n                                documentation: {\n                                    value: SuggestAdapter.createDocumentationString(details)\n                                }\n                            }];\n                }\n            });\n        });\n    };\n    SuggestAdapter.convertKind = function (kind) {\n        switch (kind) {\n            case Kind.primitiveType:\n            case Kind.keyword:\n                return monaco_editor_core/* languages.CompletionItemKind.Keyword */.Mj.CompletionItemKind.Keyword;\n            case Kind.variable:\n            case Kind.localVariable:\n                return monaco_editor_core/* languages.CompletionItemKind.Variable */.Mj.CompletionItemKind.Variable;\n            case Kind.memberVariable:\n            case Kind.memberGetAccessor:\n            case Kind.memberSetAccessor:\n                return monaco_editor_core/* languages.CompletionItemKind.Field */.Mj.CompletionItemKind.Field;\n            case Kind.function:\n            case Kind.memberFunction:\n            case Kind.constructSignature:\n            case Kind.callSignature:\n            case Kind.indexSignature:\n                return monaco_editor_core/* languages.CompletionItemKind.Function */.Mj.CompletionItemKind.Function;\n            case Kind.enum:\n                return monaco_editor_core/* languages.CompletionItemKind.Enum */.Mj.CompletionItemKind.Enum;\n            case Kind.module:\n                return monaco_editor_core/* languages.CompletionItemKind.Module */.Mj.CompletionItemKind.Module;\n            case Kind.class:\n                return monaco_editor_core/* languages.CompletionItemKind.Class */.Mj.CompletionItemKind.Class;\n            case Kind.interface:\n                return monaco_editor_core/* languages.CompletionItemKind.Interface */.Mj.CompletionItemKind.Interface;\n            case Kind.warning:\n                return monaco_editor_core/* languages.CompletionItemKind.File */.Mj.CompletionItemKind.File;\n        }\n        return monaco_editor_core/* languages.CompletionItemKind.Property */.Mj.CompletionItemKind.Property;\n    };\n    SuggestAdapter.createDocumentationString = function (details) {\n        var documentationString = displayPartsToString(details.documentation);\n        if (details.tags) {\n            for (var _i = 0, _a = details.tags; _i < _a.length; _i++) {\n                var tag = _a[_i];\n                documentationString += \"\\n\\n\" + tagToString(tag);\n            }\n        }\n        return documentationString;\n    };\n    return SuggestAdapter;\n}(Adapter));\n\nfunction tagToString(tag) {\n    var tagLabel = \"*@\" + tag.name + \"*\";\n    if (tag.name === 'param' && tag.text) {\n        var _a = tag.text.split(' '), paramName = _a[0], rest = _a.slice(1);\n        tagLabel += \"`\" + paramName + \"`\";\n        if (rest.length > 0)\n            tagLabel += \" \\u2014 \" + rest.join(' ');\n    }\n    else if (tag.text) {\n        tagLabel += \" \\u2014 \" + tag.text;\n    }\n    return tagLabel;\n}\nvar SignatureHelpAdapter = /** @class */ (function (_super) {\n    __extends(SignatureHelpAdapter, _super);\n    function SignatureHelpAdapter() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.signatureHelpTriggerCharacters = ['(', ','];\n        return _this;\n    }\n    SignatureHelpAdapter._toSignatureHelpTriggerReason = function (context) {\n        switch (context.triggerKind) {\n            case monaco_editor_core/* languages.SignatureHelpTriggerKind.TriggerCharacter */.Mj.SignatureHelpTriggerKind.TriggerCharacter:\n                if (context.triggerCharacter) {\n                    if (context.isRetrigger) {\n                        return { kind: 'retrigger', triggerCharacter: context.triggerCharacter };\n                    }\n                    else {\n                        return { kind: 'characterTyped', triggerCharacter: context.triggerCharacter };\n                    }\n                }\n                else {\n                    return { kind: 'invoked' };\n                }\n            case monaco_editor_core/* languages.SignatureHelpTriggerKind.ContentChange */.Mj.SignatureHelpTriggerKind.ContentChange:\n                return context.isRetrigger ? { kind: 'retrigger' } : { kind: 'invoked' };\n            case monaco_editor_core/* languages.SignatureHelpTriggerKind.Invoke */.Mj.SignatureHelpTriggerKind.Invoke:\n            default:\n                return { kind: 'invoked' };\n        }\n    };\n    SignatureHelpAdapter.prototype.provideSignatureHelp = function (model, position, token, context) {\n        return languageFeatures_awaiter(this, void 0, void 0, function () {\n            var resource, offset, worker, info, ret;\n            return languageFeatures_generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        resource = model.uri;\n                        offset = model.getOffsetAt(position);\n                        return [4 /*yield*/, this._worker(resource)];\n                    case 1:\n                        worker = _a.sent();\n                        if (model.isDisposed()) {\n                            return [2 /*return*/];\n                        }\n                        return [4 /*yield*/, worker.getSignatureHelpItems(resource.toString(), offset, {\n                                triggerReason: SignatureHelpAdapter._toSignatureHelpTriggerReason(context)\n                            })];\n                    case 2:\n                        info = _a.sent();\n                        if (!info || model.isDisposed()) {\n                            return [2 /*return*/];\n                        }\n                        ret = {\n                            activeSignature: info.selectedItemIndex,\n                            activeParameter: info.argumentIndex,\n                            signatures: []\n                        };\n                        info.items.forEach(function (item) {\n                            var signature = {\n                                label: '',\n                                parameters: []\n                            };\n                            signature.documentation = {\n                                value: displayPartsToString(item.documentation)\n                            };\n                            signature.label += displayPartsToString(item.prefixDisplayParts);\n                            item.parameters.forEach(function (p, i, a) {\n                                var label = displayPartsToString(p.displayParts);\n                                var parameter = {\n                                    label: label,\n                                    documentation: {\n                                        value: displayPartsToString(p.documentation)\n                                    }\n                                };\n                                signature.label += label;\n                                signature.parameters.push(parameter);\n                                if (i < a.length - 1) {\n                                    signature.label += displayPartsToString(item.separatorDisplayParts);\n                                }\n                            });\n                            signature.label += displayPartsToString(item.suffixDisplayParts);\n                            ret.signatures.push(signature);\n                        });\n                        return [2 /*return*/, {\n                                value: ret,\n                                dispose: function () { }\n                            }];\n                }\n            });\n        });\n    };\n    return SignatureHelpAdapter;\n}(Adapter));\n\n// --- hover ------\nvar QuickInfoAdapter = /** @class */ (function (_super) {\n    __extends(QuickInfoAdapter, _super);\n    function QuickInfoAdapter() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    QuickInfoAdapter.prototype.provideHover = function (model, position, token) {\n        return languageFeatures_awaiter(this, void 0, void 0, function () {\n            var resource, offset, worker, info, documentation, tags, contents;\n            return languageFeatures_generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        resource = model.uri;\n                        offset = model.getOffsetAt(position);\n                        return [4 /*yield*/, this._worker(resource)];\n                    case 1:\n                        worker = _a.sent();\n                        if (model.isDisposed()) {\n                            return [2 /*return*/];\n                        }\n                        return [4 /*yield*/, worker.getQuickInfoAtPosition(resource.toString(), offset)];\n                    case 2:\n                        info = _a.sent();\n                        if (!info || model.isDisposed()) {\n                            return [2 /*return*/];\n                        }\n                        documentation = displayPartsToString(info.documentation);\n                        tags = info.tags ? info.tags.map(function (tag) { return tagToString(tag); }).join('  \\n\\n') : '';\n                        contents = displayPartsToString(info.displayParts);\n                        return [2 /*return*/, {\n                                range: this._textSpanToRange(model, info.textSpan),\n                                contents: [\n                                    {\n                                        value: '```typescript\\n' + contents + '\\n```\\n'\n                                    },\n                                    {\n                                        value: documentation + (tags ? '\\n\\n' + tags : '')\n                                    }\n                                ]\n                            }];\n                }\n            });\n        });\n    };\n    return QuickInfoAdapter;\n}(Adapter));\n\n// --- occurrences ------\nvar OccurrencesAdapter = /** @class */ (function (_super) {\n    __extends(OccurrencesAdapter, _super);\n    function OccurrencesAdapter() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    OccurrencesAdapter.prototype.provideDocumentHighlights = function (model, position, token) {\n        return languageFeatures_awaiter(this, void 0, void 0, function () {\n            var resource, offset, worker, entries;\n            var _this = this;\n            return languageFeatures_generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        resource = model.uri;\n                        offset = model.getOffsetAt(position);\n                        return [4 /*yield*/, this._worker(resource)];\n                    case 1:\n                        worker = _a.sent();\n                        if (model.isDisposed()) {\n                            return [2 /*return*/];\n                        }\n                        return [4 /*yield*/, worker.getOccurrencesAtPosition(resource.toString(), offset)];\n                    case 2:\n                        entries = _a.sent();\n                        if (!entries || model.isDisposed()) {\n                            return [2 /*return*/];\n                        }\n                        return [2 /*return*/, entries.map(function (entry) {\n                                return {\n                                    range: _this._textSpanToRange(model, entry.textSpan),\n                                    kind: entry.isWriteAccess\n                                        ? monaco_editor_core/* languages.DocumentHighlightKind.Write */.Mj.DocumentHighlightKind.Write\n                                        : monaco_editor_core/* languages.DocumentHighlightKind.Text */.Mj.DocumentHighlightKind.Text\n                                };\n                            })];\n                }\n            });\n        });\n    };\n    return OccurrencesAdapter;\n}(Adapter));\n\n// --- definition ------\nvar DefinitionAdapter = /** @class */ (function (_super) {\n    __extends(DefinitionAdapter, _super);\n    function DefinitionAdapter(_libFiles, worker) {\n        var _this = _super.call(this, worker) || this;\n        _this._libFiles = _libFiles;\n        return _this;\n    }\n    DefinitionAdapter.prototype.provideDefinition = function (model, position, token) {\n        return languageFeatures_awaiter(this, void 0, void 0, function () {\n            var resource, offset, worker, entries, result, _i, entries_1, entry, uri, refModel;\n            return languageFeatures_generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        resource = model.uri;\n                        offset = model.getOffsetAt(position);\n                        return [4 /*yield*/, this._worker(resource)];\n                    case 1:\n                        worker = _a.sent();\n                        if (model.isDisposed()) {\n                            return [2 /*return*/];\n                        }\n                        return [4 /*yield*/, worker.getDefinitionAtPosition(resource.toString(), offset)];\n                    case 2:\n                        entries = _a.sent();\n                        if (!entries || model.isDisposed()) {\n                            return [2 /*return*/];\n                        }\n                        // Fetch lib files if necessary\n                        return [4 /*yield*/, this._libFiles.fetchLibFilesIfNecessary(entries.map(function (entry) { return monaco_editor_core/* Uri.parse */.Sf.parse(entry.fileName); }))];\n                    case 3:\n                        // Fetch lib files if necessary\n                        _a.sent();\n                        if (model.isDisposed()) {\n                            return [2 /*return*/];\n                        }\n                        result = [];\n                        for (_i = 0, entries_1 = entries; _i < entries_1.length; _i++) {\n                            entry = entries_1[_i];\n                            uri = monaco_editor_core/* Uri.parse */.Sf.parse(entry.fileName);\n                            refModel = this._libFiles.getOrCreateModel(uri);\n                            if (refModel) {\n                                result.push({\n                                    uri: uri,\n                                    range: this._textSpanToRange(refModel, entry.textSpan)\n                                });\n                            }\n                        }\n                        return [2 /*return*/, result];\n                }\n            });\n        });\n    };\n    return DefinitionAdapter;\n}(Adapter));\n\n// --- references ------\nvar ReferenceAdapter = /** @class */ (function (_super) {\n    __extends(ReferenceAdapter, _super);\n    function ReferenceAdapter(_libFiles, worker) {\n        var _this = _super.call(this, worker) || this;\n        _this._libFiles = _libFiles;\n        return _this;\n    }\n    ReferenceAdapter.prototype.provideReferences = function (model, position, context, token) {\n        return languageFeatures_awaiter(this, void 0, void 0, function () {\n            var resource, offset, worker, entries, result, _i, entries_2, entry, uri, refModel;\n            return languageFeatures_generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        resource = model.uri;\n                        offset = model.getOffsetAt(position);\n                        return [4 /*yield*/, this._worker(resource)];\n                    case 1:\n                        worker = _a.sent();\n                        if (model.isDisposed()) {\n                            return [2 /*return*/];\n                        }\n                        return [4 /*yield*/, worker.getReferencesAtPosition(resource.toString(), offset)];\n                    case 2:\n                        entries = _a.sent();\n                        if (!entries || model.isDisposed()) {\n                            return [2 /*return*/];\n                        }\n                        // Fetch lib files if necessary\n                        return [4 /*yield*/, this._libFiles.fetchLibFilesIfNecessary(entries.map(function (entry) { return monaco_editor_core/* Uri.parse */.Sf.parse(entry.fileName); }))];\n                    case 3:\n                        // Fetch lib files if necessary\n                        _a.sent();\n                        if (model.isDisposed()) {\n                            return [2 /*return*/];\n                        }\n                        result = [];\n                        for (_i = 0, entries_2 = entries; _i < entries_2.length; _i++) {\n                            entry = entries_2[_i];\n                            uri = monaco_editor_core/* Uri.parse */.Sf.parse(entry.fileName);\n                            refModel = this._libFiles.getOrCreateModel(uri);\n                            if (refModel) {\n                                result.push({\n                                    uri: uri,\n                                    range: this._textSpanToRange(refModel, entry.textSpan)\n                                });\n                            }\n                        }\n                        return [2 /*return*/, result];\n                }\n            });\n        });\n    };\n    return ReferenceAdapter;\n}(Adapter));\n\n// --- outline ------\nvar OutlineAdapter = /** @class */ (function (_super) {\n    __extends(OutlineAdapter, _super);\n    function OutlineAdapter() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    OutlineAdapter.prototype.provideDocumentSymbols = function (model, token) {\n        return languageFeatures_awaiter(this, void 0, void 0, function () {\n            var resource, worker, items, convert, result;\n            var _this = this;\n            return languageFeatures_generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        resource = model.uri;\n                        return [4 /*yield*/, this._worker(resource)];\n                    case 1:\n                        worker = _a.sent();\n                        if (model.isDisposed()) {\n                            return [2 /*return*/];\n                        }\n                        return [4 /*yield*/, worker.getNavigationBarItems(resource.toString())];\n                    case 2:\n                        items = _a.sent();\n                        if (!items || model.isDisposed()) {\n                            return [2 /*return*/];\n                        }\n                        convert = function (bucket, item, containerLabel) {\n                            var result = {\n                                name: item.text,\n                                detail: '',\n                                kind: (outlineTypeTable[item.kind] || monaco_editor_core/* languages.SymbolKind.Variable */.Mj.SymbolKind.Variable),\n                                range: _this._textSpanToRange(model, item.spans[0]),\n                                selectionRange: _this._textSpanToRange(model, item.spans[0]),\n                                tags: [],\n                                containerName: containerLabel\n                            };\n                            if (item.childItems && item.childItems.length > 0) {\n                                for (var _i = 0, _a = item.childItems; _i < _a.length; _i++) {\n                                    var child = _a[_i];\n                                    convert(bucket, child, result.name);\n                                }\n                            }\n                            bucket.push(result);\n                        };\n                        result = [];\n                        items.forEach(function (item) { return convert(result, item); });\n                        return [2 /*return*/, result];\n                }\n            });\n        });\n    };\n    return OutlineAdapter;\n}(Adapter));\n\nvar Kind = /** @class */ (function () {\n    function Kind() {\n    }\n    Kind.unknown = '';\n    Kind.keyword = 'keyword';\n    Kind.script = 'script';\n    Kind.module = 'module';\n    Kind.class = 'class';\n    Kind.interface = 'interface';\n    Kind.type = 'type';\n    Kind.enum = 'enum';\n    Kind.variable = 'var';\n    Kind.localVariable = 'local var';\n    Kind.function = 'function';\n    Kind.localFunction = 'local function';\n    Kind.memberFunction = 'method';\n    Kind.memberGetAccessor = 'getter';\n    Kind.memberSetAccessor = 'setter';\n    Kind.memberVariable = 'property';\n    Kind.constructorImplementation = 'constructor';\n    Kind.callSignature = 'call';\n    Kind.indexSignature = 'index';\n    Kind.constructSignature = 'construct';\n    Kind.parameter = 'parameter';\n    Kind.typeParameter = 'type parameter';\n    Kind.primitiveType = 'primitive type';\n    Kind.label = 'label';\n    Kind.alias = 'alias';\n    Kind.const = 'const';\n    Kind.let = 'let';\n    Kind.warning = 'warning';\n    return Kind;\n}());\n\nvar outlineTypeTable = Object.create(null);\noutlineTypeTable[Kind.module] = monaco_editor_core/* languages.SymbolKind.Module */.Mj.SymbolKind.Module;\noutlineTypeTable[Kind.class] = monaco_editor_core/* languages.SymbolKind.Class */.Mj.SymbolKind.Class;\noutlineTypeTable[Kind.enum] = monaco_editor_core/* languages.SymbolKind.Enum */.Mj.SymbolKind.Enum;\noutlineTypeTable[Kind.interface] = monaco_editor_core/* languages.SymbolKind.Interface */.Mj.SymbolKind.Interface;\noutlineTypeTable[Kind.memberFunction] = monaco_editor_core/* languages.SymbolKind.Method */.Mj.SymbolKind.Method;\noutlineTypeTable[Kind.memberVariable] = monaco_editor_core/* languages.SymbolKind.Property */.Mj.SymbolKind.Property;\noutlineTypeTable[Kind.memberGetAccessor] = monaco_editor_core/* languages.SymbolKind.Property */.Mj.SymbolKind.Property;\noutlineTypeTable[Kind.memberSetAccessor] = monaco_editor_core/* languages.SymbolKind.Property */.Mj.SymbolKind.Property;\noutlineTypeTable[Kind.variable] = monaco_editor_core/* languages.SymbolKind.Variable */.Mj.SymbolKind.Variable;\noutlineTypeTable[Kind.const] = monaco_editor_core/* languages.SymbolKind.Variable */.Mj.SymbolKind.Variable;\noutlineTypeTable[Kind.localVariable] = monaco_editor_core/* languages.SymbolKind.Variable */.Mj.SymbolKind.Variable;\noutlineTypeTable[Kind.variable] = monaco_editor_core/* languages.SymbolKind.Variable */.Mj.SymbolKind.Variable;\noutlineTypeTable[Kind.function] = monaco_editor_core/* languages.SymbolKind.Function */.Mj.SymbolKind.Function;\noutlineTypeTable[Kind.localFunction] = monaco_editor_core/* languages.SymbolKind.Function */.Mj.SymbolKind.Function;\n// --- formatting ----\nvar FormatHelper = /** @class */ (function (_super) {\n    __extends(FormatHelper, _super);\n    function FormatHelper() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    FormatHelper._convertOptions = function (options) {\n        return {\n            ConvertTabsToSpaces: options.insertSpaces,\n            TabSize: options.tabSize,\n            IndentSize: options.tabSize,\n            IndentStyle: IndentStyle.Smart,\n            NewLineCharacter: '\\n',\n            InsertSpaceAfterCommaDelimiter: true,\n            InsertSpaceAfterSemicolonInForStatements: true,\n            InsertSpaceBeforeAndAfterBinaryOperators: true,\n            InsertSpaceAfterKeywordsInControlFlowStatements: true,\n            InsertSpaceAfterFunctionKeywordForAnonymousFunctions: true,\n            InsertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis: false,\n            InsertSpaceAfterOpeningAndBeforeClosingNonemptyBrackets: false,\n            InsertSpaceAfterOpeningAndBeforeClosingTemplateStringBraces: false,\n            PlaceOpenBraceOnNewLineForControlBlocks: false,\n            PlaceOpenBraceOnNewLineForFunctions: false\n        };\n    };\n    FormatHelper.prototype._convertTextChanges = function (model, change) {\n        return {\n            text: change.newText,\n            range: this._textSpanToRange(model, change.span)\n        };\n    };\n    return FormatHelper;\n}(Adapter));\n\nvar FormatAdapter = /** @class */ (function (_super) {\n    __extends(FormatAdapter, _super);\n    function FormatAdapter() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    FormatAdapter.prototype.provideDocumentRangeFormattingEdits = function (model, range, options, token) {\n        return languageFeatures_awaiter(this, void 0, void 0, function () {\n            var resource, startOffset, endOffset, worker, edits;\n            var _this = this;\n            return languageFeatures_generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        resource = model.uri;\n                        startOffset = model.getOffsetAt({\n                            lineNumber: range.startLineNumber,\n                            column: range.startColumn\n                        });\n                        endOffset = model.getOffsetAt({\n                            lineNumber: range.endLineNumber,\n                            column: range.endColumn\n                        });\n                        return [4 /*yield*/, this._worker(resource)];\n                    case 1:\n                        worker = _a.sent();\n                        if (model.isDisposed()) {\n                            return [2 /*return*/];\n                        }\n                        return [4 /*yield*/, worker.getFormattingEditsForRange(resource.toString(), startOffset, endOffset, FormatHelper._convertOptions(options))];\n                    case 2:\n                        edits = _a.sent();\n                        if (!edits || model.isDisposed()) {\n                            return [2 /*return*/];\n                        }\n                        return [2 /*return*/, edits.map(function (edit) { return _this._convertTextChanges(model, edit); })];\n                }\n            });\n        });\n    };\n    return FormatAdapter;\n}(FormatHelper));\n\nvar FormatOnTypeAdapter = /** @class */ (function (_super) {\n    __extends(FormatOnTypeAdapter, _super);\n    function FormatOnTypeAdapter() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(FormatOnTypeAdapter.prototype, \"autoFormatTriggerCharacters\", {\n        get: function () {\n            return [';', '}', '\\n'];\n        },\n        enumerable: false,\n        configurable: true\n    });\n    FormatOnTypeAdapter.prototype.provideOnTypeFormattingEdits = function (model, position, ch, options, token) {\n        return languageFeatures_awaiter(this, void 0, void 0, function () {\n            var resource, offset, worker, edits;\n            var _this = this;\n            return languageFeatures_generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        resource = model.uri;\n                        offset = model.getOffsetAt(position);\n                        return [4 /*yield*/, this._worker(resource)];\n                    case 1:\n                        worker = _a.sent();\n                        if (model.isDisposed()) {\n                            return [2 /*return*/];\n                        }\n                        return [4 /*yield*/, worker.getFormattingEditsAfterKeystroke(resource.toString(), offset, ch, FormatHelper._convertOptions(options))];\n                    case 2:\n                        edits = _a.sent();\n                        if (!edits || model.isDisposed()) {\n                            return [2 /*return*/];\n                        }\n                        return [2 /*return*/, edits.map(function (edit) { return _this._convertTextChanges(model, edit); })];\n                }\n            });\n        });\n    };\n    return FormatOnTypeAdapter;\n}(FormatHelper));\n\n// --- code actions ------\nvar CodeActionAdaptor = /** @class */ (function (_super) {\n    __extends(CodeActionAdaptor, _super);\n    function CodeActionAdaptor() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    CodeActionAdaptor.prototype.provideCodeActions = function (model, range, context, token) {\n        return languageFeatures_awaiter(this, void 0, void 0, function () {\n            var resource, start, end, formatOptions, errorCodes, worker, codeFixes, actions;\n            var _this = this;\n            return languageFeatures_generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        resource = model.uri;\n                        start = model.getOffsetAt({\n                            lineNumber: range.startLineNumber,\n                            column: range.startColumn\n                        });\n                        end = model.getOffsetAt({\n                            lineNumber: range.endLineNumber,\n                            column: range.endColumn\n                        });\n                        formatOptions = FormatHelper._convertOptions(model.getOptions());\n                        errorCodes = context.markers\n                            .filter(function (m) { return m.code; })\n                            .map(function (m) { return m.code; })\n                            .map(Number);\n                        return [4 /*yield*/, this._worker(resource)];\n                    case 1:\n                        worker = _a.sent();\n                        if (model.isDisposed()) {\n                            return [2 /*return*/];\n                        }\n                        return [4 /*yield*/, worker.getCodeFixesAtPosition(resource.toString(), start, end, errorCodes, formatOptions)];\n                    case 2:\n                        codeFixes = _a.sent();\n                        if (!codeFixes || model.isDisposed()) {\n                            return [2 /*return*/, { actions: [], dispose: function () { } }];\n                        }\n                        actions = codeFixes\n                            .filter(function (fix) {\n                            // Removes any 'make a new file'-type code fix\n                            return fix.changes.filter(function (change) { return change.isNewFile; }).length === 0;\n                        })\n                            .map(function (fix) {\n                            return _this._tsCodeFixActionToMonacoCodeAction(model, context, fix);\n                        });\n                        return [2 /*return*/, {\n                                actions: actions,\n                                dispose: function () { }\n                            }];\n                }\n            });\n        });\n    };\n    CodeActionAdaptor.prototype._tsCodeFixActionToMonacoCodeAction = function (model, context, codeFix) {\n        var edits = [];\n        for (var _i = 0, _a = codeFix.changes; _i < _a.length; _i++) {\n            var change = _a[_i];\n            for (var _b = 0, _c = change.textChanges; _b < _c.length; _b++) {\n                var textChange = _c[_b];\n                edits.push({\n                    resource: model.uri,\n                    edit: {\n                        range: this._textSpanToRange(model, textChange.span),\n                        text: textChange.newText\n                    }\n                });\n            }\n        }\n        var action = {\n            title: codeFix.description,\n            edit: { edits: edits },\n            diagnostics: context.markers,\n            kind: 'quickfix'\n        };\n        return action;\n    };\n    return CodeActionAdaptor;\n}(FormatHelper));\n\n// --- rename ----\nvar RenameAdapter = /** @class */ (function (_super) {\n    __extends(RenameAdapter, _super);\n    function RenameAdapter() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    RenameAdapter.prototype.provideRenameEdits = function (model, position, newName, token) {\n        return languageFeatures_awaiter(this, void 0, void 0, function () {\n            var resource, fileName, offset, worker, renameInfo, renameLocations, edits, _i, renameLocations_1, renameLocation, resource_1, model_1;\n            return languageFeatures_generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        resource = model.uri;\n                        fileName = resource.toString();\n                        offset = model.getOffsetAt(position);\n                        return [4 /*yield*/, this._worker(resource)];\n                    case 1:\n                        worker = _a.sent();\n                        if (model.isDisposed()) {\n                            return [2 /*return*/];\n                        }\n                        return [4 /*yield*/, worker.getRenameInfo(fileName, offset, {\n                                allowRenameOfImportPath: false\n                            })];\n                    case 2:\n                        renameInfo = _a.sent();\n                        if (renameInfo.canRename === false) {\n                            // use explicit comparison so that the discriminated union gets resolved properly\n                            return [2 /*return*/, {\n                                    edits: [],\n                                    rejectReason: renameInfo.localizedErrorMessage\n                                }];\n                        }\n                        if (renameInfo.fileToRename !== undefined) {\n                            throw new Error('Renaming files is not supported.');\n                        }\n                        return [4 /*yield*/, worker.findRenameLocations(fileName, offset, \n                            /*strings*/ false, \n                            /*comments*/ false, \n                            /*prefixAndSuffix*/ false)];\n                    case 3:\n                        renameLocations = _a.sent();\n                        if (!renameLocations || model.isDisposed()) {\n                            return [2 /*return*/];\n                        }\n                        edits = [];\n                        for (_i = 0, renameLocations_1 = renameLocations; _i < renameLocations_1.length; _i++) {\n                            renameLocation = renameLocations_1[_i];\n                            resource_1 = monaco_editor_core/* Uri.parse */.Sf.parse(renameLocation.fileName);\n                            model_1 = monaco_editor_core/* editor.getModel */.j6.getModel(resource_1);\n                            if (model_1) {\n                                edits.push({\n                                    resource: resource_1,\n                                    edit: {\n                                        range: this._textSpanToRange(model_1, renameLocation.textSpan),\n                                        text: newName\n                                    }\n                                });\n                            }\n                            else {\n                                throw new Error(\"Unknown URI \" + resource_1 + \".\");\n                            }\n                        }\n                        return [2 /*return*/, { edits: edits }];\n                }\n            });\n        });\n    };\n    return RenameAdapter;\n}(Adapter));\n\n\n;// CONCATENATED MODULE: ../../node_modules/monaco-editor/esm/vs/language/typescript/tsMode.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n\n\n\nvar javaScriptWorker;\nvar typeScriptWorker;\nfunction setupTypeScript(defaults) {\n    typeScriptWorker = setupMode(defaults, 'typescript');\n}\nfunction setupJavaScript(defaults) {\n    javaScriptWorker = setupMode(defaults, 'javascript');\n}\nfunction getJavaScriptWorker() {\n    return new Promise(function (resolve, reject) {\n        if (!javaScriptWorker) {\n            return reject('JavaScript not registered!');\n        }\n        resolve(javaScriptWorker);\n    });\n}\nfunction getTypeScriptWorker() {\n    return new Promise(function (resolve, reject) {\n        if (!typeScriptWorker) {\n            return reject('TypeScript not registered!');\n        }\n        resolve(typeScriptWorker);\n    });\n}\nfunction setupMode(defaults, modeId) {\n    var client = new WorkerManager(modeId, defaults);\n    var worker = function () {\n        var uris = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            uris[_i] = arguments[_i];\n        }\n        return client.getLanguageServiceWorker.apply(client, uris);\n    };\n    var libFiles = new LibFiles(worker);\n    monaco_editor_core/* languages.registerCompletionItemProvider */.Mj.registerCompletionItemProvider(modeId, new SuggestAdapter(worker));\n    monaco_editor_core/* languages.registerSignatureHelpProvider */.Mj.registerSignatureHelpProvider(modeId, new SignatureHelpAdapter(worker));\n    monaco_editor_core/* languages.registerHoverProvider */.Mj.registerHoverProvider(modeId, new QuickInfoAdapter(worker));\n    monaco_editor_core/* languages.registerDocumentHighlightProvider */.Mj.registerDocumentHighlightProvider(modeId, new OccurrencesAdapter(worker));\n    monaco_editor_core/* languages.registerDefinitionProvider */.Mj.registerDefinitionProvider(modeId, new DefinitionAdapter(libFiles, worker));\n    monaco_editor_core/* languages.registerReferenceProvider */.Mj.registerReferenceProvider(modeId, new ReferenceAdapter(libFiles, worker));\n    monaco_editor_core/* languages.registerDocumentSymbolProvider */.Mj.registerDocumentSymbolProvider(modeId, new OutlineAdapter(worker));\n    monaco_editor_core/* languages.registerDocumentRangeFormattingEditProvider */.Mj.registerDocumentRangeFormattingEditProvider(modeId, new FormatAdapter(worker));\n    monaco_editor_core/* languages.registerOnTypeFormattingEditProvider */.Mj.registerOnTypeFormattingEditProvider(modeId, new FormatOnTypeAdapter(worker));\n    monaco_editor_core/* languages.registerCodeActionProvider */.Mj.registerCodeActionProvider(modeId, new CodeActionAdaptor(worker));\n    monaco_editor_core/* languages.registerRenameProvider */.Mj.registerRenameProvider(modeId, new RenameAdapter(worker));\n    new DiagnosticsAdapter(libFiles, defaults, modeId, worker);\n    return worker;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixRQUF5QjtBQUNoRCxJQUFJLGtHQUF3QyxhQUFhLGNBQStCO0FBQ3hGLElBQUksZ0dBQXVDLGFBQWEsb0JBQXFDO0FBQzdGLElBQUksZ0ZBQStCLGFBQWEsZ0JBQWlDO0FBQ2pGLElBQUksd0dBQTJDLGFBQWEsa0JBQW1DO0FBQy9GLElBQUksMEZBQW9DLGFBQWEsaUJBQWtDO0FBQ3ZGLElBQUksd0ZBQW1DLGFBQWEsZ0JBQWlDO0FBQ3JGLElBQUksa0dBQXdDLGFBQWEsY0FBK0I7QUFDeEYsSUFBSSw0SEFBcUQsYUFBYSxhQUE4QjtBQUNwRyxJQUFJLDhHQUE4QyxhQUFhLG1CQUFvQztBQUNuRyxJQUFJLDBGQUFvQyxhQUFhLGlCQUFrQztBQUN2RixJQUFJLGtGQUFnQyxhQUFhLGFBQThCO0FBQy9FLFFBQVEsa0JBQW1DO0FBQzNDO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AdnVlL2RldnRvb2xzLy4uLy4uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9sYW5ndWFnZS90eXBlc2NyaXB0L3dvcmtlck1hbmFnZXIuanM/MzQzMSIsIndlYnBhY2s6Ly9AdnVlL2RldnRvb2xzLy4uLy4uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9sYW5ndWFnZS90eXBlc2NyaXB0L2xpYi9saWIuaW5kZXguanM/MWU4YSIsIndlYnBhY2s6Ly9AdnVlL2RldnRvb2xzLy4uLy4uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9sYW5ndWFnZS90eXBlc2NyaXB0L2xhbmd1YWdlRmVhdHVyZXMuanM/ZDdjNCIsIndlYnBhY2s6Ly9AdnVlL2RldnRvb2xzLy4uLy4uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9sYW5ndWFnZS90eXBlc2NyaXB0L3RzTW9kZS5qcz9mNzU0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuJ3VzZSBzdHJpY3QnO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbmltcG9ydCB7IGVkaXRvciB9IGZyb20gJy4vZmlsbGVycy9tb25hY28tZWRpdG9yLWNvcmUuanMnO1xudmFyIFdvcmtlck1hbmFnZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gV29ya2VyTWFuYWdlcihtb2RlSWQsIGRlZmF1bHRzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX21vZGVJZCA9IG1vZGVJZDtcbiAgICAgICAgdGhpcy5fZGVmYXVsdHMgPSBkZWZhdWx0cztcbiAgICAgICAgdGhpcy5fd29ya2VyID0gbnVsbDtcbiAgICAgICAgdGhpcy5fY2xpZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fY29uZmlnQ2hhbmdlTGlzdGVuZXIgPSB0aGlzLl9kZWZhdWx0cy5vbkRpZENoYW5nZShmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fc3RvcFdvcmtlcigpOyB9KTtcbiAgICAgICAgdGhpcy5fdXBkYXRlRXh0cmFMaWJzVG9rZW4gPSAwO1xuICAgICAgICB0aGlzLl9leHRyYUxpYnNDaGFuZ2VMaXN0ZW5lciA9IHRoaXMuX2RlZmF1bHRzLm9uRGlkRXh0cmFMaWJzQ2hhbmdlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5fdXBkYXRlRXh0cmFMaWJzKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBXb3JrZXJNYW5hZ2VyLnByb3RvdHlwZS5fc3RvcFdvcmtlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dvcmtlcikge1xuICAgICAgICAgICAgdGhpcy5fd29ya2VyLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIHRoaXMuX3dvcmtlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2xpZW50ID0gbnVsbDtcbiAgICB9O1xuICAgIFdvcmtlck1hbmFnZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2NvbmZpZ0NoYW5nZUxpc3RlbmVyLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5fZXh0cmFMaWJzQ2hhbmdlTGlzdGVuZXIuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLl9zdG9wV29ya2VyKCk7XG4gICAgfTtcbiAgICBXb3JrZXJNYW5hZ2VyLnByb3RvdHlwZS5fdXBkYXRlRXh0cmFMaWJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbXlUb2tlbiwgcHJveHk7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3dvcmtlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG15VG9rZW4gPSArK3RoaXMuX3VwZGF0ZUV4dHJhTGlic1Rva2VuO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5fd29ya2VyLmdldFByb3h5KCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm94eSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl91cGRhdGVFeHRyYUxpYnNUb2tlbiAhPT0gbXlUb2tlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGF2b2lkIG11bHRpcGxlIGNhbGxzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcHJveHkudXBkYXRlRXh0cmFMaWJzKHRoaXMuX2RlZmF1bHRzLmdldEV4dHJhTGlicygpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBXb3JrZXJNYW5hZ2VyLnByb3RvdHlwZS5fZ2V0Q2xpZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIXRoaXMuX2NsaWVudCkge1xuICAgICAgICAgICAgdGhpcy5fd29ya2VyID0gZWRpdG9yLmNyZWF0ZVdlYldvcmtlcih7XG4gICAgICAgICAgICAgICAgLy8gbW9kdWxlIHRoYXQgZXhwb3J0cyB0aGUgY3JlYXRlKCkgbWV0aG9kIGFuZCByZXR1cm5zIGEgYFR5cGVTY3JpcHRXb3JrZXJgIGluc3RhbmNlXG4gICAgICAgICAgICAgICAgbW9kdWxlSWQ6ICd2cy9sYW5ndWFnZS90eXBlc2NyaXB0L3RzV29ya2VyJyxcbiAgICAgICAgICAgICAgICBsYWJlbDogdGhpcy5fbW9kZUlkLFxuICAgICAgICAgICAgICAgIGtlZXBJZGxlTW9kZWxzOiB0cnVlLFxuICAgICAgICAgICAgICAgIC8vIHBhc3NlZCBpbiB0byB0aGUgY3JlYXRlKCkgbWV0aG9kXG4gICAgICAgICAgICAgICAgY3JlYXRlRGF0YToge1xuICAgICAgICAgICAgICAgICAgICBjb21waWxlck9wdGlvbnM6IHRoaXMuX2RlZmF1bHRzLmdldENvbXBpbGVyT3B0aW9ucygpLFxuICAgICAgICAgICAgICAgICAgICBleHRyYUxpYnM6IHRoaXMuX2RlZmF1bHRzLmdldEV4dHJhTGlicygpLFxuICAgICAgICAgICAgICAgICAgICBjdXN0b21Xb3JrZXJQYXRoOiB0aGlzLl9kZWZhdWx0cy53b3JrZXJPcHRpb25zLmN1c3RvbVdvcmtlclBhdGhcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBwID0gdGhpcy5fd29ya2VyLmdldFByb3h5KCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fZGVmYXVsdHMuZ2V0RWFnZXJNb2RlbFN5bmMoKSkge1xuICAgICAgICAgICAgICAgIHAgPSBwLnRoZW4oZnVuY3Rpb24gKHdvcmtlcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX3dvcmtlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl93b3JrZXIud2l0aFN5bmNlZFJlc291cmNlcyhlZGl0b3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZ2V0TW9kZWxzKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChtb2RlbCkgeyByZXR1cm4gbW9kZWwuZ2V0TW9kZUlkKCkgPT09IF90aGlzLl9tb2RlSWQ7IH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAobW9kZWwpIHsgcmV0dXJuIG1vZGVsLnVyaTsgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB3b3JrZXI7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9jbGllbnQgPSBwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9jbGllbnQ7XG4gICAgfTtcbiAgICBXb3JrZXJNYW5hZ2VyLnByb3RvdHlwZS5nZXRMYW5ndWFnZVNlcnZpY2VXb3JrZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciByZXNvdXJjZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHJlc291cmNlc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfY2xpZW50O1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0Q2xpZW50KClcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChjbGllbnQpIHtcbiAgICAgICAgICAgIF9jbGllbnQgPSBjbGllbnQ7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgaWYgKF90aGlzLl93b3JrZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX3dvcmtlci53aXRoU3luY2VkUmVzb3VyY2VzKHJlc291cmNlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoXykgeyByZXR1cm4gX2NsaWVudDsgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gV29ya2VyTWFuYWdlcjtcbn0oKSk7XG5leHBvcnQgeyBXb3JrZXJNYW5hZ2VyIH07XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbi8vXG4vLyAqKk5PVEUqKjogRG8gbm90IGVkaXQgZGlyZWN0bHkhIFRoaXMgZmlsZSBpcyBnZW5lcmF0ZWQgdXNpbmcgYG5wbSBydW4gaW1wb3J0LXR5cGVzY3JpcHRgXG4vL1xuLyoqIENvbnRhaW5zIGFsbCB0aGUgbGliIGZpbGVzICovXG5leHBvcnQgdmFyIGxpYkZpbGVTZXQgPSB7fTtcbmxpYkZpbGVTZXRbJ2xpYi5kLnRzJ10gPSB0cnVlO1xubGliRmlsZVNldFsnbGliLmRvbS5kLnRzJ10gPSB0cnVlO1xubGliRmlsZVNldFsnbGliLmRvbS5pdGVyYWJsZS5kLnRzJ10gPSB0cnVlO1xubGliRmlsZVNldFsnbGliLmVzMjAxNS5jb2xsZWN0aW9uLmQudHMnXSA9IHRydWU7XG5saWJGaWxlU2V0WydsaWIuZXMyMDE1LmNvcmUuZC50cyddID0gdHJ1ZTtcbmxpYkZpbGVTZXRbJ2xpYi5lczIwMTUuZC50cyddID0gdHJ1ZTtcbmxpYkZpbGVTZXRbJ2xpYi5lczIwMTUuZ2VuZXJhdG9yLmQudHMnXSA9IHRydWU7XG5saWJGaWxlU2V0WydsaWIuZXMyMDE1Lml0ZXJhYmxlLmQudHMnXSA9IHRydWU7XG5saWJGaWxlU2V0WydsaWIuZXMyMDE1LnByb21pc2UuZC50cyddID0gdHJ1ZTtcbmxpYkZpbGVTZXRbJ2xpYi5lczIwMTUucHJveHkuZC50cyddID0gdHJ1ZTtcbmxpYkZpbGVTZXRbJ2xpYi5lczIwMTUucmVmbGVjdC5kLnRzJ10gPSB0cnVlO1xubGliRmlsZVNldFsnbGliLmVzMjAxNS5zeW1ib2wuZC50cyddID0gdHJ1ZTtcbmxpYkZpbGVTZXRbJ2xpYi5lczIwMTUuc3ltYm9sLndlbGxrbm93bi5kLnRzJ10gPSB0cnVlO1xubGliRmlsZVNldFsnbGliLmVzMjAxNi5hcnJheS5pbmNsdWRlLmQudHMnXSA9IHRydWU7XG5saWJGaWxlU2V0WydsaWIuZXMyMDE2LmQudHMnXSA9IHRydWU7XG5saWJGaWxlU2V0WydsaWIuZXMyMDE2LmZ1bGwuZC50cyddID0gdHJ1ZTtcbmxpYkZpbGVTZXRbJ2xpYi5lczIwMTcuZC50cyddID0gdHJ1ZTtcbmxpYkZpbGVTZXRbJ2xpYi5lczIwMTcuZnVsbC5kLnRzJ10gPSB0cnVlO1xubGliRmlsZVNldFsnbGliLmVzMjAxNy5pbnRsLmQudHMnXSA9IHRydWU7XG5saWJGaWxlU2V0WydsaWIuZXMyMDE3Lm9iamVjdC5kLnRzJ10gPSB0cnVlO1xubGliRmlsZVNldFsnbGliLmVzMjAxNy5zaGFyZWRtZW1vcnkuZC50cyddID0gdHJ1ZTtcbmxpYkZpbGVTZXRbJ2xpYi5lczIwMTcuc3RyaW5nLmQudHMnXSA9IHRydWU7XG5saWJGaWxlU2V0WydsaWIuZXMyMDE3LnR5cGVkYXJyYXlzLmQudHMnXSA9IHRydWU7XG5saWJGaWxlU2V0WydsaWIuZXMyMDE4LmFzeW5jZ2VuZXJhdG9yLmQudHMnXSA9IHRydWU7XG5saWJGaWxlU2V0WydsaWIuZXMyMDE4LmFzeW5jaXRlcmFibGUuZC50cyddID0gdHJ1ZTtcbmxpYkZpbGVTZXRbJ2xpYi5lczIwMTguZC50cyddID0gdHJ1ZTtcbmxpYkZpbGVTZXRbJ2xpYi5lczIwMTguZnVsbC5kLnRzJ10gPSB0cnVlO1xubGliRmlsZVNldFsnbGliLmVzMjAxOC5pbnRsLmQudHMnXSA9IHRydWU7XG5saWJGaWxlU2V0WydsaWIuZXMyMDE4LnByb21pc2UuZC50cyddID0gdHJ1ZTtcbmxpYkZpbGVTZXRbJ2xpYi5lczIwMTgucmVnZXhwLmQudHMnXSA9IHRydWU7XG5saWJGaWxlU2V0WydsaWIuZXMyMDE5LmFycmF5LmQudHMnXSA9IHRydWU7XG5saWJGaWxlU2V0WydsaWIuZXMyMDE5LmQudHMnXSA9IHRydWU7XG5saWJGaWxlU2V0WydsaWIuZXMyMDE5LmZ1bGwuZC50cyddID0gdHJ1ZTtcbmxpYkZpbGVTZXRbJ2xpYi5lczIwMTkub2JqZWN0LmQudHMnXSA9IHRydWU7XG5saWJGaWxlU2V0WydsaWIuZXMyMDE5LnN0cmluZy5kLnRzJ10gPSB0cnVlO1xubGliRmlsZVNldFsnbGliLmVzMjAxOS5zeW1ib2wuZC50cyddID0gdHJ1ZTtcbmxpYkZpbGVTZXRbJ2xpYi5lczIwMjAuYmlnaW50LmQudHMnXSA9IHRydWU7XG5saWJGaWxlU2V0WydsaWIuZXMyMDIwLmQudHMnXSA9IHRydWU7XG5saWJGaWxlU2V0WydsaWIuZXMyMDIwLmZ1bGwuZC50cyddID0gdHJ1ZTtcbmxpYkZpbGVTZXRbJ2xpYi5lczIwMjAuaW50bC5kLnRzJ10gPSB0cnVlO1xubGliRmlsZVNldFsnbGliLmVzMjAyMC5wcm9taXNlLmQudHMnXSA9IHRydWU7XG5saWJGaWxlU2V0WydsaWIuZXMyMDIwLnNoYXJlZG1lbW9yeS5kLnRzJ10gPSB0cnVlO1xubGliRmlsZVNldFsnbGliLmVzMjAyMC5zdHJpbmcuZC50cyddID0gdHJ1ZTtcbmxpYkZpbGVTZXRbJ2xpYi5lczIwMjAuc3ltYm9sLndlbGxrbm93bi5kLnRzJ10gPSB0cnVlO1xubGliRmlsZVNldFsnbGliLmVzNS5kLnRzJ10gPSB0cnVlO1xubGliRmlsZVNldFsnbGliLmVzNi5kLnRzJ10gPSB0cnVlO1xubGliRmlsZVNldFsnbGliLmVzbmV4dC5kLnRzJ10gPSB0cnVlO1xubGliRmlsZVNldFsnbGliLmVzbmV4dC5mdWxsLmQudHMnXSA9IHRydWU7XG5saWJGaWxlU2V0WydsaWIuZXNuZXh0LmludGwuZC50cyddID0gdHJ1ZTtcbmxpYkZpbGVTZXRbJ2xpYi5lc25leHQucHJvbWlzZS5kLnRzJ10gPSB0cnVlO1xubGliRmlsZVNldFsnbGliLmVzbmV4dC5zdHJpbmcuZC50cyddID0gdHJ1ZTtcbmxpYkZpbGVTZXRbJ2xpYi5lc25leHQud2Vha3JlZi5kLnRzJ10gPSB0cnVlO1xubGliRmlsZVNldFsnbGliLnNjcmlwdGhvc3QuZC50cyddID0gdHJ1ZTtcbmxpYkZpbGVTZXRbJ2xpYi53ZWJ3b3JrZXIuZC50cyddID0gdHJ1ZTtcbmxpYkZpbGVTZXRbJ2xpYi53ZWJ3b3JrZXIuaW1wb3J0c2NyaXB0cy5kLnRzJ10gPSB0cnVlO1xubGliRmlsZVNldFsnbGliLndlYndvcmtlci5pdGVyYWJsZS5kLnRzJ10gPSB0cnVlO1xuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4ndXNlIHN0cmljdCc7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbmltcG9ydCB7IGxpYkZpbGVTZXQgfSBmcm9tICcuL2xpYi9saWIuaW5kZXguanMnO1xuaW1wb3J0IHsgZWRpdG9yLCBsYW5ndWFnZXMsIFVyaSwgUmFuZ2UsIE1hcmtlclRhZywgTWFya2VyU2V2ZXJpdHkgfSBmcm9tICcuL2ZpbGxlcnMvbW9uYWNvLWVkaXRvci1jb3JlLmpzJztcbi8vI3JlZ2lvbiB1dGlscyBjb3BpZWQgZnJvbSB0eXBlc2NyaXB0IHRvIHByZXZlbnQgbG9hZGluZyB0aGUgZW50aXJlIHR5cGVzY3JpcHRTZXJ2aWNlcyAtLS1cbnZhciBJbmRlbnRTdHlsZTtcbihmdW5jdGlvbiAoSW5kZW50U3R5bGUpIHtcbiAgICBJbmRlbnRTdHlsZVtJbmRlbnRTdHlsZVtcIk5vbmVcIl0gPSAwXSA9IFwiTm9uZVwiO1xuICAgIEluZGVudFN0eWxlW0luZGVudFN0eWxlW1wiQmxvY2tcIl0gPSAxXSA9IFwiQmxvY2tcIjtcbiAgICBJbmRlbnRTdHlsZVtJbmRlbnRTdHlsZVtcIlNtYXJ0XCJdID0gMl0gPSBcIlNtYXJ0XCI7XG59KShJbmRlbnRTdHlsZSB8fCAoSW5kZW50U3R5bGUgPSB7fSkpO1xuZXhwb3J0IGZ1bmN0aW9uIGZsYXR0ZW5EaWFnbm9zdGljTWVzc2FnZVRleHQoZGlhZywgbmV3TGluZSwgaW5kZW50KSB7XG4gICAgaWYgKGluZGVudCA9PT0gdm9pZCAwKSB7IGluZGVudCA9IDA7IH1cbiAgICBpZiAodHlwZW9mIGRpYWcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBkaWFnO1xuICAgIH1cbiAgICBlbHNlIGlmIChkaWFnID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgaWYgKGluZGVudCkge1xuICAgICAgICByZXN1bHQgKz0gbmV3TGluZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmRlbnQ7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0ICs9ICcgICc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0ICs9IGRpYWcubWVzc2FnZVRleHQ7XG4gICAgaW5kZW50Kys7XG4gICAgaWYgKGRpYWcubmV4dCkge1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gZGlhZy5uZXh0OyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGtpZCA9IF9hW19pXTtcbiAgICAgICAgICAgIHJlc3VsdCArPSBmbGF0dGVuRGlhZ25vc3RpY01lc3NhZ2VUZXh0KGtpZCwgbmV3TGluZSwgaW5kZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZGlzcGxheVBhcnRzVG9TdHJpbmcoZGlzcGxheVBhcnRzKSB7XG4gICAgaWYgKGRpc3BsYXlQYXJ0cykge1xuICAgICAgICByZXR1cm4gZGlzcGxheVBhcnRzLm1hcChmdW5jdGlvbiAoZGlzcGxheVBhcnQpIHsgcmV0dXJuIGRpc3BsYXlQYXJ0LnRleHQ7IH0pLmpvaW4oJycpO1xuICAgIH1cbiAgICByZXR1cm4gJyc7XG59XG4vLyNlbmRyZWdpb25cbnZhciBBZGFwdGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFkYXB0ZXIoX3dvcmtlcikge1xuICAgICAgICB0aGlzLl93b3JrZXIgPSBfd29ya2VyO1xuICAgIH1cbiAgICAvLyBwcm90ZWN0ZWQgX3Bvc2l0aW9uVG9PZmZzZXQobW9kZWw6IGVkaXRvci5JVGV4dE1vZGVsLCBwb3NpdGlvbjogbW9uYWNvLklQb3NpdGlvbik6IG51bWJlciB7XG4gICAgLy8gXHRyZXR1cm4gbW9kZWwuZ2V0T2Zmc2V0QXQocG9zaXRpb24pO1xuICAgIC8vIH1cbiAgICAvLyBwcm90ZWN0ZWQgX29mZnNldFRvUG9zaXRpb24obW9kZWw6IGVkaXRvci5JVGV4dE1vZGVsLCBvZmZzZXQ6IG51bWJlcik6IG1vbmFjby5JUG9zaXRpb24ge1xuICAgIC8vIFx0cmV0dXJuIG1vZGVsLmdldFBvc2l0aW9uQXQob2Zmc2V0KTtcbiAgICAvLyB9XG4gICAgQWRhcHRlci5wcm90b3R5cGUuX3RleHRTcGFuVG9SYW5nZSA9IGZ1bmN0aW9uIChtb2RlbCwgc3Bhbikge1xuICAgICAgICB2YXIgcDEgPSBtb2RlbC5nZXRQb3NpdGlvbkF0KHNwYW4uc3RhcnQpO1xuICAgICAgICB2YXIgcDIgPSBtb2RlbC5nZXRQb3NpdGlvbkF0KHNwYW4uc3RhcnQgKyBzcGFuLmxlbmd0aCk7XG4gICAgICAgIHZhciBzdGFydExpbmVOdW1iZXIgPSBwMS5saW5lTnVtYmVyLCBzdGFydENvbHVtbiA9IHAxLmNvbHVtbjtcbiAgICAgICAgdmFyIGVuZExpbmVOdW1iZXIgPSBwMi5saW5lTnVtYmVyLCBlbmRDb2x1bW4gPSBwMi5jb2x1bW47XG4gICAgICAgIHJldHVybiB7IHN0YXJ0TGluZU51bWJlcjogc3RhcnRMaW5lTnVtYmVyLCBzdGFydENvbHVtbjogc3RhcnRDb2x1bW4sIGVuZExpbmVOdW1iZXI6IGVuZExpbmVOdW1iZXIsIGVuZENvbHVtbjogZW5kQ29sdW1uIH07XG4gICAgfTtcbiAgICByZXR1cm4gQWRhcHRlcjtcbn0oKSk7XG5leHBvcnQgeyBBZGFwdGVyIH07XG4vLyAtLS0gbGliIGZpbGVzXG52YXIgTGliRmlsZXMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTGliRmlsZXMoX3dvcmtlcikge1xuICAgICAgICB0aGlzLl93b3JrZXIgPSBfd29ya2VyO1xuICAgICAgICB0aGlzLl9saWJGaWxlcyA9IHt9O1xuICAgICAgICB0aGlzLl9oYXNGZXRjaGVkTGliRmlsZXMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZmV0Y2hMaWJGaWxlc1Byb21pc2UgPSBudWxsO1xuICAgIH1cbiAgICBMaWJGaWxlcy5wcm90b3R5cGUuaXNMaWJGaWxlID0gZnVuY3Rpb24gKHVyaSkge1xuICAgICAgICBpZiAoIXVyaSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cmkucGF0aC5pbmRleE9mKCcvbGliLicpID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gISFsaWJGaWxlU2V0W3VyaS5wYXRoLnNsaWNlKDEpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBMaWJGaWxlcy5wcm90b3R5cGUuZ2V0T3JDcmVhdGVNb2RlbCA9IGZ1bmN0aW9uICh1cmkpIHtcbiAgICAgICAgdmFyIG1vZGVsID0gZWRpdG9yLmdldE1vZGVsKHVyaSk7XG4gICAgICAgIGlmIChtb2RlbCkge1xuICAgICAgICAgICAgcmV0dXJuIG1vZGVsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzTGliRmlsZSh1cmkpICYmIHRoaXMuX2hhc0ZldGNoZWRMaWJGaWxlcykge1xuICAgICAgICAgICAgcmV0dXJuIGVkaXRvci5jcmVhdGVNb2RlbCh0aGlzLl9saWJGaWxlc1t1cmkucGF0aC5zbGljZSgxKV0sICd0eXBlc2NyaXB0JywgdXJpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIExpYkZpbGVzLnByb3RvdHlwZS5fY29udGFpbnNMaWJGaWxlID0gZnVuY3Rpb24gKHVyaXMpIHtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCB1cmlzXzEgPSB1cmlzOyBfaSA8IHVyaXNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciB1cmkgPSB1cmlzXzFbX2ldO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNMaWJGaWxlKHVyaSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBMaWJGaWxlcy5wcm90b3R5cGUuZmV0Y2hMaWJGaWxlc0lmTmVjZXNzYXJ5ID0gZnVuY3Rpb24gKHVyaXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9jb250YWluc0xpYkZpbGUodXJpcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBubyBsaWIgZmlsZXMgbmVjZXNzYXJ5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5fZmV0Y2hMaWJGaWxlcygpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIExpYkZpbGVzLnByb3RvdHlwZS5fZmV0Y2hMaWJGaWxlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLl9mZXRjaExpYkZpbGVzUHJvbWlzZSkge1xuICAgICAgICAgICAgdGhpcy5fZmV0Y2hMaWJGaWxlc1Byb21pc2UgPSB0aGlzLl93b3JrZXIoKVxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LmdldExpYkZpbGVzKCk7IH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGxpYkZpbGVzKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2hhc0ZldGNoZWRMaWJGaWxlcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2xpYkZpbGVzID0gbGliRmlsZXM7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZmV0Y2hMaWJGaWxlc1Byb21pc2U7XG4gICAgfTtcbiAgICByZXR1cm4gTGliRmlsZXM7XG59KCkpO1xuZXhwb3J0IHsgTGliRmlsZXMgfTtcbi8vIC0tLSBkaWFnbm9zdGljcyAtLS0gLS0tXG52YXIgRGlhZ25vc3RpY0NhdGVnb3J5O1xuKGZ1bmN0aW9uIChEaWFnbm9zdGljQ2F0ZWdvcnkpIHtcbiAgICBEaWFnbm9zdGljQ2F0ZWdvcnlbRGlhZ25vc3RpY0NhdGVnb3J5W1wiV2FybmluZ1wiXSA9IDBdID0gXCJXYXJuaW5nXCI7XG4gICAgRGlhZ25vc3RpY0NhdGVnb3J5W0RpYWdub3N0aWNDYXRlZ29yeVtcIkVycm9yXCJdID0gMV0gPSBcIkVycm9yXCI7XG4gICAgRGlhZ25vc3RpY0NhdGVnb3J5W0RpYWdub3N0aWNDYXRlZ29yeVtcIlN1Z2dlc3Rpb25cIl0gPSAyXSA9IFwiU3VnZ2VzdGlvblwiO1xuICAgIERpYWdub3N0aWNDYXRlZ29yeVtEaWFnbm9zdGljQ2F0ZWdvcnlbXCJNZXNzYWdlXCJdID0gM10gPSBcIk1lc3NhZ2VcIjtcbn0pKERpYWdub3N0aWNDYXRlZ29yeSB8fCAoRGlhZ25vc3RpY0NhdGVnb3J5ID0ge30pKTtcbnZhciBEaWFnbm9zdGljc0FkYXB0ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERpYWdub3N0aWNzQWRhcHRlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEaWFnbm9zdGljc0FkYXB0ZXIoX2xpYkZpbGVzLCBfZGVmYXVsdHMsIF9zZWxlY3Rvciwgd29ya2VyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHdvcmtlcikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX2xpYkZpbGVzID0gX2xpYkZpbGVzO1xuICAgICAgICBfdGhpcy5fZGVmYXVsdHMgPSBfZGVmYXVsdHM7XG4gICAgICAgIF90aGlzLl9zZWxlY3RvciA9IF9zZWxlY3RvcjtcbiAgICAgICAgX3RoaXMuX2Rpc3Bvc2FibGVzID0gW107XG4gICAgICAgIF90aGlzLl9saXN0ZW5lciA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHZhciBvbk1vZGVsQWRkID0gZnVuY3Rpb24gKG1vZGVsKSB7XG4gICAgICAgICAgICBpZiAobW9kZWwuZ2V0TW9kZUlkKCkgIT09IF9zZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBtYXliZVZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBvbmx5VmlzaWJsZSA9IF90aGlzLl9kZWZhdWx0cy5nZXREaWFnbm9zdGljc09wdGlvbnMoKS5vbmx5VmlzaWJsZTtcbiAgICAgICAgICAgICAgICBpZiAob25seVZpc2libGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGVsLmlzQXR0YWNoZWRUb0VkaXRvcigpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fZG9WYWxpZGF0ZShtb2RlbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9kb1ZhbGlkYXRlKG1vZGVsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGhhbmRsZTtcbiAgICAgICAgICAgIHZhciBjaGFuZ2VTdWJzY3JpcHRpb24gPSBtb2RlbC5vbkRpZENoYW5nZUNvbnRlbnQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChoYW5kbGUpO1xuICAgICAgICAgICAgICAgIGhhbmRsZSA9IHNldFRpbWVvdXQobWF5YmVWYWxpZGF0ZSwgNTAwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIHZpc2libGVTdWJzY3JpcHRpb24gPSBtb2RlbC5vbkRpZENoYW5nZUF0dGFjaGVkKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgb25seVZpc2libGUgPSBfdGhpcy5fZGVmYXVsdHMuZ2V0RGlhZ25vc3RpY3NPcHRpb25zKCkub25seVZpc2libGU7XG4gICAgICAgICAgICAgICAgaWYgKG9ubHlWaXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb2RlbC5pc0F0dGFjaGVkVG9FZGl0b3IoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBtb2RlbCBpcyBub3cgYXR0YWNoZWQgdG8gYW4gZWRpdG9yXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyA9PiBjb21wdXRlIGRpYWdub3N0aWNzXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXliZVZhbGlkYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIG1vZGVsIGlzIG5vIGxvbmdlciBhdHRhY2hlZCB0byBhbiBlZGl0b3JcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vID0+IGNsZWFyIGV4aXN0aW5nIGRpYWdub3N0aWNzXG4gICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3Iuc2V0TW9kZWxNYXJrZXJzKG1vZGVsLCBfdGhpcy5fc2VsZWN0b3IsIFtdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgX3RoaXMuX2xpc3RlbmVyW21vZGVsLnVyaS50b1N0cmluZygpXSA9IHtcbiAgICAgICAgICAgICAgICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZVN1YnNjcmlwdGlvbi5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIHZpc2libGVTdWJzY3JpcHRpb24uZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbWF5YmVWYWxpZGF0ZSgpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgb25Nb2RlbFJlbW92ZWQgPSBmdW5jdGlvbiAobW9kZWwpIHtcbiAgICAgICAgICAgIGVkaXRvci5zZXRNb2RlbE1hcmtlcnMobW9kZWwsIF90aGlzLl9zZWxlY3RvciwgW10pO1xuICAgICAgICAgICAgdmFyIGtleSA9IG1vZGVsLnVyaS50b1N0cmluZygpO1xuICAgICAgICAgICAgaWYgKF90aGlzLl9saXN0ZW5lcltrZXldKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2xpc3RlbmVyW2tleV0uZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBfdGhpcy5fbGlzdGVuZXJba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuX2Rpc3Bvc2FibGVzLnB1c2goZWRpdG9yLm9uRGlkQ3JlYXRlTW9kZWwoZnVuY3Rpb24gKG1vZGVsKSB7IHJldHVybiBvbk1vZGVsQWRkKG1vZGVsKTsgfSkpO1xuICAgICAgICBfdGhpcy5fZGlzcG9zYWJsZXMucHVzaChlZGl0b3Iub25XaWxsRGlzcG9zZU1vZGVsKG9uTW9kZWxSZW1vdmVkKSk7XG4gICAgICAgIF90aGlzLl9kaXNwb3NhYmxlcy5wdXNoKGVkaXRvci5vbkRpZENoYW5nZU1vZGVsTGFuZ3VhZ2UoZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBvbk1vZGVsUmVtb3ZlZChldmVudC5tb2RlbCk7XG4gICAgICAgICAgICBvbk1vZGVsQWRkKGV2ZW50Lm1vZGVsKTtcbiAgICAgICAgfSkpO1xuICAgICAgICBfdGhpcy5fZGlzcG9zYWJsZXMucHVzaCh7XG4gICAgICAgICAgICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IGVkaXRvci5nZXRNb2RlbHMoKTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1vZGVsID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgICAgICBvbk1vZGVsUmVtb3ZlZChtb2RlbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHJlY29tcHV0ZURpYWdvc3RpY3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyByZWRvIGRpYWdub3N0aWNzIHdoZW4gb3B0aW9ucyBjaGFuZ2VcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBlZGl0b3IuZ2V0TW9kZWxzKCk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1vZGVsID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgIG9uTW9kZWxSZW1vdmVkKG1vZGVsKTtcbiAgICAgICAgICAgICAgICBvbk1vZGVsQWRkKG1vZGVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuX2Rpc3Bvc2FibGVzLnB1c2goX3RoaXMuX2RlZmF1bHRzLm9uRGlkQ2hhbmdlKHJlY29tcHV0ZURpYWdvc3RpY3MpKTtcbiAgICAgICAgX3RoaXMuX2Rpc3Bvc2FibGVzLnB1c2goX3RoaXMuX2RlZmF1bHRzLm9uRGlkRXh0cmFMaWJzQ2hhbmdlKHJlY29tcHV0ZURpYWdvc3RpY3MpKTtcbiAgICAgICAgZWRpdG9yLmdldE1vZGVscygpLmZvckVhY2goZnVuY3Rpb24gKG1vZGVsKSB7IHJldHVybiBvbk1vZGVsQWRkKG1vZGVsKTsgfSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgRGlhZ25vc3RpY3NBZGFwdGVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9kaXNwb3NhYmxlcy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkICYmIGQuZGlzcG9zZSgpOyB9KTtcbiAgICAgICAgdGhpcy5fZGlzcG9zYWJsZXMgPSBbXTtcbiAgICB9O1xuICAgIERpYWdub3N0aWNzQWRhcHRlci5wcm90b3R5cGUuX2RvVmFsaWRhdGUgPSBmdW5jdGlvbiAobW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHdvcmtlciwgcHJvbWlzZXMsIF9hLCBub1N5bnRheFZhbGlkYXRpb24sIG5vU2VtYW50aWNWYWxpZGF0aW9uLCBub1N1Z2dlc3Rpb25EaWFnbm9zdGljcywgYWxsRGlhZ25vc3RpY3MsIGRpYWdub3N0aWNzLCByZWxhdGVkVXJpcztcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX3dvcmtlcihtb2RlbC51cmkpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgd29ya2VyID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGVsLmlzRGlzcG9zZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1vZGVsIHdhcyBkaXNwb3NlZCBpbiB0aGUgbWVhbnRpbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2EgPSB0aGlzLl9kZWZhdWx0cy5nZXREaWFnbm9zdGljc09wdGlvbnMoKSwgbm9TeW50YXhWYWxpZGF0aW9uID0gX2Eubm9TeW50YXhWYWxpZGF0aW9uLCBub1NlbWFudGljVmFsaWRhdGlvbiA9IF9hLm5vU2VtYW50aWNWYWxpZGF0aW9uLCBub1N1Z2dlc3Rpb25EaWFnbm9zdGljcyA9IF9hLm5vU3VnZ2VzdGlvbkRpYWdub3N0aWNzO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFub1N5bnRheFZhbGlkYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKHdvcmtlci5nZXRTeW50YWN0aWNEaWFnbm9zdGljcyhtb2RlbC51cmkudG9TdHJpbmcoKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFub1NlbWFudGljVmFsaWRhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2god29ya2VyLmdldFNlbWFudGljRGlhZ25vc3RpY3MobW9kZWwudXJpLnRvU3RyaW5nKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbm9TdWdnZXN0aW9uRGlhZ25vc3RpY3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKHdvcmtlci5nZXRTdWdnZXN0aW9uRGlhZ25vc3RpY3MobW9kZWwudXJpLnRvU3RyaW5nKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIFByb21pc2UuYWxsKHByb21pc2VzKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbERpYWdub3N0aWNzID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhbGxEaWFnbm9zdGljcyB8fCBtb2RlbC5pc0Rpc3Bvc2VkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBtb2RlbCB3YXMgZGlzcG9zZWQgaW4gdGhlIG1lYW50aW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZGlhZ25vc3RpY3MgPSBhbGxEaWFnbm9zdGljc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZWR1Y2UoZnVuY3Rpb24gKHAsIGMpIHsgcmV0dXJuIGMuY29uY2F0KHApOyB9LCBbXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChfdGhpcy5fZGVmYXVsdHMuZ2V0RGlhZ25vc3RpY3NPcHRpb25zKCkuZGlhZ25vc3RpY0NvZGVzVG9JZ25vcmUgfHwgW10pLmluZGV4T2YoZC5jb2RlKSA9PT1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbGF0ZWRVcmlzID0gZGlhZ25vc3RpY3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLnJlbGF0ZWRJbmZvcm1hdGlvbiB8fCBbXTsgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVkdWNlKGZ1bmN0aW9uIChwLCBjKSB7IHJldHVybiBjLmNvbmNhdChwKTsgfSwgW10pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAocmVsYXRlZEluZm9ybWF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlbGF0ZWRJbmZvcm1hdGlvbi5maWxlID8gVXJpLnBhcnNlKHJlbGF0ZWRJbmZvcm1hdGlvbi5maWxlLmZpbGVOYW1lKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX2xpYkZpbGVzLmZldGNoTGliRmlsZXNJZk5lY2Vzc2FyeShyZWxhdGVkVXJpcyldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobW9kZWwuaXNEaXNwb3NlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbW9kZWwgd2FzIGRpc3Bvc2VkIGluIHRoZSBtZWFudGltZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvci5zZXRNb2RlbE1hcmtlcnMobW9kZWwsIHRoaXMuX3NlbGVjdG9yLCBkaWFnbm9zdGljcy5tYXAoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIF90aGlzLl9jb252ZXJ0RGlhZ25vc3RpY3MobW9kZWwsIGQpOyB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgRGlhZ25vc3RpY3NBZGFwdGVyLnByb3RvdHlwZS5fY29udmVydERpYWdub3N0aWNzID0gZnVuY3Rpb24gKG1vZGVsLCBkaWFnKSB7XG4gICAgICAgIHZhciBkaWFnU3RhcnQgPSBkaWFnLnN0YXJ0IHx8IDA7XG4gICAgICAgIHZhciBkaWFnTGVuZ3RoID0gZGlhZy5sZW5ndGggfHwgMTtcbiAgICAgICAgdmFyIF9hID0gbW9kZWwuZ2V0UG9zaXRpb25BdChkaWFnU3RhcnQpLCBzdGFydExpbmVOdW1iZXIgPSBfYS5saW5lTnVtYmVyLCBzdGFydENvbHVtbiA9IF9hLmNvbHVtbjtcbiAgICAgICAgdmFyIF9iID0gbW9kZWwuZ2V0UG9zaXRpb25BdChkaWFnU3RhcnQgKyBkaWFnTGVuZ3RoKSwgZW5kTGluZU51bWJlciA9IF9iLmxpbmVOdW1iZXIsIGVuZENvbHVtbiA9IF9iLmNvbHVtbjtcbiAgICAgICAgdmFyIHRhZ3MgPSBbXTtcbiAgICAgICAgaWYgKGRpYWcucmVwb3J0c1VubmVjZXNzYXJ5KSB7XG4gICAgICAgICAgICB0YWdzLnB1c2goTWFya2VyVGFnLlVubmVjZXNzYXJ5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlhZy5yZXBvcnRzRGVwcmVjYXRlZCkge1xuICAgICAgICAgICAgdGFncy5wdXNoKE1hcmtlclRhZy5EZXByZWNhdGVkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2V2ZXJpdHk6IHRoaXMuX3RzRGlhZ25vc3RpY0NhdGVnb3J5VG9NYXJrZXJTZXZlcml0eShkaWFnLmNhdGVnb3J5KSxcbiAgICAgICAgICAgIHN0YXJ0TGluZU51bWJlcjogc3RhcnRMaW5lTnVtYmVyLFxuICAgICAgICAgICAgc3RhcnRDb2x1bW46IHN0YXJ0Q29sdW1uLFxuICAgICAgICAgICAgZW5kTGluZU51bWJlcjogZW5kTGluZU51bWJlcixcbiAgICAgICAgICAgIGVuZENvbHVtbjogZW5kQ29sdW1uLFxuICAgICAgICAgICAgbWVzc2FnZTogZmxhdHRlbkRpYWdub3N0aWNNZXNzYWdlVGV4dChkaWFnLm1lc3NhZ2VUZXh0LCAnXFxuJyksXG4gICAgICAgICAgICBjb2RlOiBkaWFnLmNvZGUudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIHRhZ3M6IHRhZ3MsXG4gICAgICAgICAgICByZWxhdGVkSW5mb3JtYXRpb246IHRoaXMuX2NvbnZlcnRSZWxhdGVkSW5mb3JtYXRpb24obW9kZWwsIGRpYWcucmVsYXRlZEluZm9ybWF0aW9uKVxuICAgICAgICB9O1xuICAgIH07XG4gICAgRGlhZ25vc3RpY3NBZGFwdGVyLnByb3RvdHlwZS5fY29udmVydFJlbGF0ZWRJbmZvcm1hdGlvbiA9IGZ1bmN0aW9uIChtb2RlbCwgcmVsYXRlZEluZm9ybWF0aW9uKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghcmVsYXRlZEluZm9ybWF0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICByZWxhdGVkSW5mb3JtYXRpb24uZm9yRWFjaChmdW5jdGlvbiAoaW5mbykge1xuICAgICAgICAgICAgdmFyIHJlbGF0ZWRSZXNvdXJjZSA9IG1vZGVsO1xuICAgICAgICAgICAgaWYgKGluZm8uZmlsZSkge1xuICAgICAgICAgICAgICAgIHZhciByZWxhdGVkUmVzb3VyY2VVcmkgPSBVcmkucGFyc2UoaW5mby5maWxlLmZpbGVOYW1lKTtcbiAgICAgICAgICAgICAgICByZWxhdGVkUmVzb3VyY2UgPSBfdGhpcy5fbGliRmlsZXMuZ2V0T3JDcmVhdGVNb2RlbChyZWxhdGVkUmVzb3VyY2VVcmkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFyZWxhdGVkUmVzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaW5mb1N0YXJ0ID0gaW5mby5zdGFydCB8fCAwO1xuICAgICAgICAgICAgdmFyIGluZm9MZW5ndGggPSBpbmZvLmxlbmd0aCB8fCAxO1xuICAgICAgICAgICAgdmFyIF9hID0gcmVsYXRlZFJlc291cmNlLmdldFBvc2l0aW9uQXQoaW5mb1N0YXJ0KSwgc3RhcnRMaW5lTnVtYmVyID0gX2EubGluZU51bWJlciwgc3RhcnRDb2x1bW4gPSBfYS5jb2x1bW47XG4gICAgICAgICAgICB2YXIgX2IgPSByZWxhdGVkUmVzb3VyY2UuZ2V0UG9zaXRpb25BdChpbmZvU3RhcnQgKyBpbmZvTGVuZ3RoKSwgZW5kTGluZU51bWJlciA9IF9iLmxpbmVOdW1iZXIsIGVuZENvbHVtbiA9IF9iLmNvbHVtbjtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICByZXNvdXJjZTogcmVsYXRlZFJlc291cmNlLnVyaSxcbiAgICAgICAgICAgICAgICBzdGFydExpbmVOdW1iZXI6IHN0YXJ0TGluZU51bWJlcixcbiAgICAgICAgICAgICAgICBzdGFydENvbHVtbjogc3RhcnRDb2x1bW4sXG4gICAgICAgICAgICAgICAgZW5kTGluZU51bWJlcjogZW5kTGluZU51bWJlcixcbiAgICAgICAgICAgICAgICBlbmRDb2x1bW46IGVuZENvbHVtbixcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBmbGF0dGVuRGlhZ25vc3RpY01lc3NhZ2VUZXh0KGluZm8ubWVzc2FnZVRleHQsICdcXG4nKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgRGlhZ25vc3RpY3NBZGFwdGVyLnByb3RvdHlwZS5fdHNEaWFnbm9zdGljQ2F0ZWdvcnlUb01hcmtlclNldmVyaXR5ID0gZnVuY3Rpb24gKGNhdGVnb3J5KSB7XG4gICAgICAgIHN3aXRjaCAoY2F0ZWdvcnkpIHtcbiAgICAgICAgICAgIGNhc2UgRGlhZ25vc3RpY0NhdGVnb3J5LkVycm9yOlxuICAgICAgICAgICAgICAgIHJldHVybiBNYXJrZXJTZXZlcml0eS5FcnJvcjtcbiAgICAgICAgICAgIGNhc2UgRGlhZ25vc3RpY0NhdGVnb3J5Lk1lc3NhZ2U6XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hcmtlclNldmVyaXR5LkluZm87XG4gICAgICAgICAgICBjYXNlIERpYWdub3N0aWNDYXRlZ29yeS5XYXJuaW5nOlxuICAgICAgICAgICAgICAgIHJldHVybiBNYXJrZXJTZXZlcml0eS5XYXJuaW5nO1xuICAgICAgICAgICAgY2FzZSBEaWFnbm9zdGljQ2F0ZWdvcnkuU3VnZ2VzdGlvbjpcbiAgICAgICAgICAgICAgICByZXR1cm4gTWFya2VyU2V2ZXJpdHkuSGludDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTWFya2VyU2V2ZXJpdHkuSW5mbztcbiAgICB9O1xuICAgIHJldHVybiBEaWFnbm9zdGljc0FkYXB0ZXI7XG59KEFkYXB0ZXIpKTtcbmV4cG9ydCB7IERpYWdub3N0aWNzQWRhcHRlciB9O1xudmFyIFN1Z2dlc3RBZGFwdGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTdWdnZXN0QWRhcHRlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTdWdnZXN0QWRhcHRlcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3VnZ2VzdEFkYXB0ZXIucHJvdG90eXBlLCBcInRyaWdnZXJDaGFyYWN0ZXJzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gWycuJ107XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBTdWdnZXN0QWRhcHRlci5wcm90b3R5cGUucHJvdmlkZUNvbXBsZXRpb25JdGVtcyA9IGZ1bmN0aW9uIChtb2RlbCwgcG9zaXRpb24sIF9jb250ZXh0LCB0b2tlbikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgd29yZEluZm8sIHdvcmRSYW5nZSwgcmVzb3VyY2UsIG9mZnNldCwgd29ya2VyLCBpbmZvLCBzdWdnZXN0aW9ucztcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmRJbmZvID0gbW9kZWwuZ2V0V29yZFVudGlsUG9zaXRpb24ocG9zaXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgd29yZFJhbmdlID0gbmV3IFJhbmdlKHBvc2l0aW9uLmxpbmVOdW1iZXIsIHdvcmRJbmZvLnN0YXJ0Q29sdW1uLCBwb3NpdGlvbi5saW5lTnVtYmVyLCB3b3JkSW5mby5lbmRDb2x1bW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2UgPSBtb2RlbC51cmk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSBtb2RlbC5nZXRPZmZzZXRBdChwb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl93b3JrZXIocmVzb3VyY2UpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgd29ya2VyID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGVsLmlzRGlzcG9zZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHdvcmtlci5nZXRDb21wbGV0aW9uc0F0UG9zaXRpb24ocmVzb3VyY2UudG9TdHJpbmcoKSwgb2Zmc2V0KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZm8gPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWluZm8gfHwgbW9kZWwuaXNEaXNwb3NlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc3VnZ2VzdGlvbnMgPSBpbmZvLmVudHJpZXMubWFwKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSB3b3JkUmFuZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVudHJ5LnJlcGxhY2VtZW50U3Bhbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcDEgPSBtb2RlbC5nZXRQb3NpdGlvbkF0KGVudHJ5LnJlcGxhY2VtZW50U3Bhbi5zdGFydCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwMiA9IG1vZGVsLmdldFBvc2l0aW9uQXQoZW50cnkucmVwbGFjZW1lbnRTcGFuLnN0YXJ0ICsgZW50cnkucmVwbGFjZW1lbnRTcGFuLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlID0gbmV3IFJhbmdlKHAxLmxpbmVOdW1iZXIsIHAxLmNvbHVtbiwgcDIubGluZU51bWJlciwgcDIuY29sdW1uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRhZ3MgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKChfYSA9IGVudHJ5LmtpbmRNb2RpZmllcnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pbmRleE9mKCdkZXByZWNhdGVkJykpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWdzLnB1c2gobGFuZ3VhZ2VzLkNvbXBsZXRpb25JdGVtVGFnLkRlcHJlY2F0ZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmk6IHJlc291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogcG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldDogb2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5nZTogcmFuZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBlbnRyeS5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnNlcnRUZXh0OiBlbnRyeS5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3J0VGV4dDogZW50cnkuc29ydFRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IFN1Z2dlc3RBZGFwdGVyLmNvbnZlcnRLaW5kKGVudHJ5LmtpbmQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWdzOiB0YWdzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VnZ2VzdGlvbnM6IHN1Z2dlc3Rpb25zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU3VnZ2VzdEFkYXB0ZXIucHJvdG90eXBlLnJlc29sdmVDb21wbGV0aW9uSXRlbSA9IGZ1bmN0aW9uIChpdGVtLCB0b2tlbikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbXlJdGVtLCByZXNvdXJjZSwgcG9zaXRpb24sIG9mZnNldCwgd29ya2VyLCBkZXRhaWxzO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgbXlJdGVtID0gaXRlbTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc291cmNlID0gbXlJdGVtLnVyaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gbXlJdGVtLnBvc2l0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gbXlJdGVtLm9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX3dvcmtlcihyZXNvdXJjZSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICB3b3JrZXIgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB3b3JrZXIuZ2V0Q29tcGxldGlvbkVudHJ5RGV0YWlscyhyZXNvdXJjZS50b1N0cmluZygpLCBvZmZzZXQsIG15SXRlbS5sYWJlbCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFkZXRhaWxzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG15SXRlbV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmk6IHJlc291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogcG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBkZXRhaWxzLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IFN1Z2dlc3RBZGFwdGVyLmNvbnZlcnRLaW5kKGRldGFpbHMua2luZCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbDogZGlzcGxheVBhcnRzVG9TdHJpbmcoZGV0YWlscy5kaXNwbGF5UGFydHMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudGF0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogU3VnZ2VzdEFkYXB0ZXIuY3JlYXRlRG9jdW1lbnRhdGlvblN0cmluZyhkZXRhaWxzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU3VnZ2VzdEFkYXB0ZXIuY29udmVydEtpbmQgPSBmdW5jdGlvbiAoa2luZCkge1xuICAgICAgICBzd2l0Y2ggKGtpbmQpIHtcbiAgICAgICAgICAgIGNhc2UgS2luZC5wcmltaXRpdmVUeXBlOlxuICAgICAgICAgICAgY2FzZSBLaW5kLmtleXdvcmQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxhbmd1YWdlcy5Db21wbGV0aW9uSXRlbUtpbmQuS2V5d29yZDtcbiAgICAgICAgICAgIGNhc2UgS2luZC52YXJpYWJsZTpcbiAgICAgICAgICAgIGNhc2UgS2luZC5sb2NhbFZhcmlhYmxlOlxuICAgICAgICAgICAgICAgIHJldHVybiBsYW5ndWFnZXMuQ29tcGxldGlvbkl0ZW1LaW5kLlZhcmlhYmxlO1xuICAgICAgICAgICAgY2FzZSBLaW5kLm1lbWJlclZhcmlhYmxlOlxuICAgICAgICAgICAgY2FzZSBLaW5kLm1lbWJlckdldEFjY2Vzc29yOlxuICAgICAgICAgICAgY2FzZSBLaW5kLm1lbWJlclNldEFjY2Vzc29yOlxuICAgICAgICAgICAgICAgIHJldHVybiBsYW5ndWFnZXMuQ29tcGxldGlvbkl0ZW1LaW5kLkZpZWxkO1xuICAgICAgICAgICAgY2FzZSBLaW5kLmZ1bmN0aW9uOlxuICAgICAgICAgICAgY2FzZSBLaW5kLm1lbWJlckZ1bmN0aW9uOlxuICAgICAgICAgICAgY2FzZSBLaW5kLmNvbnN0cnVjdFNpZ25hdHVyZTpcbiAgICAgICAgICAgIGNhc2UgS2luZC5jYWxsU2lnbmF0dXJlOlxuICAgICAgICAgICAgY2FzZSBLaW5kLmluZGV4U2lnbmF0dXJlOlxuICAgICAgICAgICAgICAgIHJldHVybiBsYW5ndWFnZXMuQ29tcGxldGlvbkl0ZW1LaW5kLkZ1bmN0aW9uO1xuICAgICAgICAgICAgY2FzZSBLaW5kLmVudW06XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxhbmd1YWdlcy5Db21wbGV0aW9uSXRlbUtpbmQuRW51bTtcbiAgICAgICAgICAgIGNhc2UgS2luZC5tb2R1bGU6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxhbmd1YWdlcy5Db21wbGV0aW9uSXRlbUtpbmQuTW9kdWxlO1xuICAgICAgICAgICAgY2FzZSBLaW5kLmNsYXNzOlxuICAgICAgICAgICAgICAgIHJldHVybiBsYW5ndWFnZXMuQ29tcGxldGlvbkl0ZW1LaW5kLkNsYXNzO1xuICAgICAgICAgICAgY2FzZSBLaW5kLmludGVyZmFjZTpcbiAgICAgICAgICAgICAgICByZXR1cm4gbGFuZ3VhZ2VzLkNvbXBsZXRpb25JdGVtS2luZC5JbnRlcmZhY2U7XG4gICAgICAgICAgICBjYXNlIEtpbmQud2FybmluZzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbGFuZ3VhZ2VzLkNvbXBsZXRpb25JdGVtS2luZC5GaWxlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsYW5ndWFnZXMuQ29tcGxldGlvbkl0ZW1LaW5kLlByb3BlcnR5O1xuICAgIH07XG4gICAgU3VnZ2VzdEFkYXB0ZXIuY3JlYXRlRG9jdW1lbnRhdGlvblN0cmluZyA9IGZ1bmN0aW9uIChkZXRhaWxzKSB7XG4gICAgICAgIHZhciBkb2N1bWVudGF0aW9uU3RyaW5nID0gZGlzcGxheVBhcnRzVG9TdHJpbmcoZGV0YWlscy5kb2N1bWVudGF0aW9uKTtcbiAgICAgICAgaWYgKGRldGFpbHMudGFncykge1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IGRldGFpbHMudGFnczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFnID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50YXRpb25TdHJpbmcgKz0gXCJcXG5cXG5cIiArIHRhZ1RvU3RyaW5nKHRhZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRvY3VtZW50YXRpb25TdHJpbmc7XG4gICAgfTtcbiAgICByZXR1cm4gU3VnZ2VzdEFkYXB0ZXI7XG59KEFkYXB0ZXIpKTtcbmV4cG9ydCB7IFN1Z2dlc3RBZGFwdGVyIH07XG5mdW5jdGlvbiB0YWdUb1N0cmluZyh0YWcpIHtcbiAgICB2YXIgdGFnTGFiZWwgPSBcIipAXCIgKyB0YWcubmFtZSArIFwiKlwiO1xuICAgIGlmICh0YWcubmFtZSA9PT0gJ3BhcmFtJyAmJiB0YWcudGV4dCkge1xuICAgICAgICB2YXIgX2EgPSB0YWcudGV4dC5zcGxpdCgnICcpLCBwYXJhbU5hbWUgPSBfYVswXSwgcmVzdCA9IF9hLnNsaWNlKDEpO1xuICAgICAgICB0YWdMYWJlbCArPSBcImBcIiArIHBhcmFtTmFtZSArIFwiYFwiO1xuICAgICAgICBpZiAocmVzdC5sZW5ndGggPiAwKVxuICAgICAgICAgICAgdGFnTGFiZWwgKz0gXCIgXFx1MjAxNCBcIiArIHJlc3Quam9pbignICcpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0YWcudGV4dCkge1xuICAgICAgICB0YWdMYWJlbCArPSBcIiBcXHUyMDE0IFwiICsgdGFnLnRleHQ7XG4gICAgfVxuICAgIHJldHVybiB0YWdMYWJlbDtcbn1cbnZhciBTaWduYXR1cmVIZWxwQWRhcHRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2lnbmF0dXJlSGVscEFkYXB0ZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU2lnbmF0dXJlSGVscEFkYXB0ZXIoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5zaWduYXR1cmVIZWxwVHJpZ2dlckNoYXJhY3RlcnMgPSBbJygnLCAnLCddO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFNpZ25hdHVyZUhlbHBBZGFwdGVyLl90b1NpZ25hdHVyZUhlbHBUcmlnZ2VyUmVhc29uID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgc3dpdGNoIChjb250ZXh0LnRyaWdnZXJLaW5kKSB7XG4gICAgICAgICAgICBjYXNlIGxhbmd1YWdlcy5TaWduYXR1cmVIZWxwVHJpZ2dlcktpbmQuVHJpZ2dlckNoYXJhY3RlcjpcbiAgICAgICAgICAgICAgICBpZiAoY29udGV4dC50cmlnZ2VyQ2hhcmFjdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250ZXh0LmlzUmV0cmlnZ2VyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBraW5kOiAncmV0cmlnZ2VyJywgdHJpZ2dlckNoYXJhY3RlcjogY29udGV4dC50cmlnZ2VyQ2hhcmFjdGVyIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBraW5kOiAnY2hhcmFjdGVyVHlwZWQnLCB0cmlnZ2VyQ2hhcmFjdGVyOiBjb250ZXh0LnRyaWdnZXJDaGFyYWN0ZXIgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsga2luZDogJ2ludm9rZWQnIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBsYW5ndWFnZXMuU2lnbmF0dXJlSGVscFRyaWdnZXJLaW5kLkNvbnRlbnRDaGFuZ2U6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuaXNSZXRyaWdnZXIgPyB7IGtpbmQ6ICdyZXRyaWdnZXInIH0gOiB7IGtpbmQ6ICdpbnZva2VkJyB9O1xuICAgICAgICAgICAgY2FzZSBsYW5ndWFnZXMuU2lnbmF0dXJlSGVscFRyaWdnZXJLaW5kLkludm9rZTpcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsga2luZDogJ2ludm9rZWQnIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNpZ25hdHVyZUhlbHBBZGFwdGVyLnByb3RvdHlwZS5wcm92aWRlU2lnbmF0dXJlSGVscCA9IGZ1bmN0aW9uIChtb2RlbCwgcG9zaXRpb24sIHRva2VuLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZXNvdXJjZSwgb2Zmc2V0LCB3b3JrZXIsIGluZm8sIHJldDtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc291cmNlID0gbW9kZWwudXJpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gbW9kZWwuZ2V0T2Zmc2V0QXQocG9zaXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5fd29ya2VyKHJlc291cmNlKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtlciA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtb2RlbC5pc0Rpc3Bvc2VkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB3b3JrZXIuZ2V0U2lnbmF0dXJlSGVscEl0ZW1zKHJlc291cmNlLnRvU3RyaW5nKCksIG9mZnNldCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyUmVhc29uOiBTaWduYXR1cmVIZWxwQWRhcHRlci5fdG9TaWduYXR1cmVIZWxwVHJpZ2dlclJlYXNvbihjb250ZXh0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgaW5mbyA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaW5mbyB8fCBtb2RlbC5pc0Rpc3Bvc2VkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlU2lnbmF0dXJlOiBpbmZvLnNlbGVjdGVkSXRlbUluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZVBhcmFtZXRlcjogaW5mby5hcmd1bWVudEluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZXM6IFtdXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5mby5pdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNpZ25hdHVyZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6ICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlLmRvY3VtZW50YXRpb24gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBkaXNwbGF5UGFydHNUb1N0cmluZyhpdGVtLmRvY3VtZW50YXRpb24pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmUubGFiZWwgKz0gZGlzcGxheVBhcnRzVG9TdHJpbmcoaXRlbS5wcmVmaXhEaXNwbGF5UGFydHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0ucGFyYW1ldGVycy5mb3JFYWNoKGZ1bmN0aW9uIChwLCBpLCBhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsYWJlbCA9IGRpc3BsYXlQYXJ0c1RvU3RyaW5nKHAuZGlzcGxheVBhcnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmFtZXRlciA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBsYWJlbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50YXRpb246IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZGlzcGxheVBhcnRzVG9TdHJpbmcocC5kb2N1bWVudGF0aW9uKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmUubGFiZWwgKz0gbGFiZWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZS5wYXJhbWV0ZXJzLnB1c2gocGFyYW1ldGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPCBhLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZS5sYWJlbCArPSBkaXNwbGF5UGFydHNUb1N0cmluZyhpdGVtLnNlcGFyYXRvckRpc3BsYXlQYXJ0cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmUubGFiZWwgKz0gZGlzcGxheVBhcnRzVG9TdHJpbmcoaXRlbS5zdWZmaXhEaXNwbGF5UGFydHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldC5zaWduYXR1cmVzLnB1c2goc2lnbmF0dXJlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHJldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcG9zZTogZnVuY3Rpb24gKCkgeyB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFNpZ25hdHVyZUhlbHBBZGFwdGVyO1xufShBZGFwdGVyKSk7XG5leHBvcnQgeyBTaWduYXR1cmVIZWxwQWRhcHRlciB9O1xuLy8gLS0tIGhvdmVyIC0tLS0tLVxudmFyIFF1aWNrSW5mb0FkYXB0ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFF1aWNrSW5mb0FkYXB0ZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUXVpY2tJbmZvQWRhcHRlcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBRdWlja0luZm9BZGFwdGVyLnByb3RvdHlwZS5wcm92aWRlSG92ZXIgPSBmdW5jdGlvbiAobW9kZWwsIHBvc2l0aW9uLCB0b2tlbikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVzb3VyY2UsIG9mZnNldCwgd29ya2VyLCBpbmZvLCBkb2N1bWVudGF0aW9uLCB0YWdzLCBjb250ZW50cztcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc291cmNlID0gbW9kZWwudXJpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gbW9kZWwuZ2V0T2Zmc2V0QXQocG9zaXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5fd29ya2VyKHJlc291cmNlKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtlciA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtb2RlbC5pc0Rpc3Bvc2VkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB3b3JrZXIuZ2V0UXVpY2tJbmZvQXRQb3NpdGlvbihyZXNvdXJjZS50b1N0cmluZygpLCBvZmZzZXQpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgaW5mbyA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaW5mbyB8fCBtb2RlbC5pc0Rpc3Bvc2VkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudGF0aW9uID0gZGlzcGxheVBhcnRzVG9TdHJpbmcoaW5mby5kb2N1bWVudGF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZ3MgPSBpbmZvLnRhZ3MgPyBpbmZvLnRhZ3MubWFwKGZ1bmN0aW9uICh0YWcpIHsgcmV0dXJuIHRhZ1RvU3RyaW5nKHRhZyk7IH0pLmpvaW4oJyAgXFxuXFxuJykgOiAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRzID0gZGlzcGxheVBhcnRzVG9TdHJpbmcoaW5mby5kaXNwbGF5UGFydHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IHRoaXMuX3RleHRTcGFuVG9SYW5nZShtb2RlbCwgaW5mby50ZXh0U3BhbiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6ICdgYGB0eXBlc2NyaXB0XFxuJyArIGNvbnRlbnRzICsgJ1xcbmBgYFxcbidcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGRvY3VtZW50YXRpb24gKyAodGFncyA/ICdcXG5cXG4nICsgdGFncyA6ICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFF1aWNrSW5mb0FkYXB0ZXI7XG59KEFkYXB0ZXIpKTtcbmV4cG9ydCB7IFF1aWNrSW5mb0FkYXB0ZXIgfTtcbi8vIC0tLSBvY2N1cnJlbmNlcyAtLS0tLS1cbnZhciBPY2N1cnJlbmNlc0FkYXB0ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE9jY3VycmVuY2VzQWRhcHRlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBPY2N1cnJlbmNlc0FkYXB0ZXIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgT2NjdXJyZW5jZXNBZGFwdGVyLnByb3RvdHlwZS5wcm92aWRlRG9jdW1lbnRIaWdobGlnaHRzID0gZnVuY3Rpb24gKG1vZGVsLCBwb3NpdGlvbiwgdG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJlc291cmNlLCBvZmZzZXQsIHdvcmtlciwgZW50cmllcztcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvdXJjZSA9IG1vZGVsLnVyaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IG1vZGVsLmdldE9mZnNldEF0KHBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX3dvcmtlcihyZXNvdXJjZSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICB3b3JrZXIgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobW9kZWwuaXNEaXNwb3NlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgd29ya2VyLmdldE9jY3VycmVuY2VzQXRQb3NpdGlvbihyZXNvdXJjZS50b1N0cmluZygpLCBvZmZzZXQpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgZW50cmllcyA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZW50cmllcyB8fCBtb2RlbC5pc0Rpc3Bvc2VkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZW50cmllcy5tYXAoZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5nZTogX3RoaXMuX3RleHRTcGFuVG9SYW5nZShtb2RlbCwgZW50cnkudGV4dFNwYW4pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogZW50cnkuaXNXcml0ZUFjY2Vzc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gbGFuZ3VhZ2VzLkRvY3VtZW50SGlnaGxpZ2h0S2luZC5Xcml0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogbGFuZ3VhZ2VzLkRvY3VtZW50SGlnaGxpZ2h0S2luZC5UZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBPY2N1cnJlbmNlc0FkYXB0ZXI7XG59KEFkYXB0ZXIpKTtcbmV4cG9ydCB7IE9jY3VycmVuY2VzQWRhcHRlciB9O1xuLy8gLS0tIGRlZmluaXRpb24gLS0tLS0tXG52YXIgRGVmaW5pdGlvbkFkYXB0ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERlZmluaXRpb25BZGFwdGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERlZmluaXRpb25BZGFwdGVyKF9saWJGaWxlcywgd29ya2VyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHdvcmtlcikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX2xpYkZpbGVzID0gX2xpYkZpbGVzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIERlZmluaXRpb25BZGFwdGVyLnByb3RvdHlwZS5wcm92aWRlRGVmaW5pdGlvbiA9IGZ1bmN0aW9uIChtb2RlbCwgcG9zaXRpb24sIHRva2VuKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZXNvdXJjZSwgb2Zmc2V0LCB3b3JrZXIsIGVudHJpZXMsIHJlc3VsdCwgX2ksIGVudHJpZXNfMSwgZW50cnksIHVyaSwgcmVmTW9kZWw7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvdXJjZSA9IG1vZGVsLnVyaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IG1vZGVsLmdldE9mZnNldEF0KHBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX3dvcmtlcihyZXNvdXJjZSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICB3b3JrZXIgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobW9kZWwuaXNEaXNwb3NlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgd29ya2VyLmdldERlZmluaXRpb25BdFBvc2l0aW9uKHJlc291cmNlLnRvU3RyaW5nKCksIG9mZnNldCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBlbnRyaWVzID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFlbnRyaWVzIHx8IG1vZGVsLmlzRGlzcG9zZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZldGNoIGxpYiBmaWxlcyBpZiBuZWNlc3NhcnlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX2xpYkZpbGVzLmZldGNoTGliRmlsZXNJZk5lY2Vzc2FyeShlbnRyaWVzLm1hcChmdW5jdGlvbiAoZW50cnkpIHsgcmV0dXJuIFVyaS5wYXJzZShlbnRyeS5maWxlTmFtZSk7IH0pKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZldGNoIGxpYiBmaWxlcyBpZiBuZWNlc3NhcnlcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtb2RlbC5pc0Rpc3Bvc2VkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoX2kgPSAwLCBlbnRyaWVzXzEgPSBlbnRyaWVzOyBfaSA8IGVudHJpZXNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnRyeSA9IGVudHJpZXNfMVtfaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJpID0gVXJpLnBhcnNlKGVudHJ5LmZpbGVOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZNb2RlbCA9IHRoaXMuX2xpYkZpbGVzLmdldE9yQ3JlYXRlTW9kZWwodXJpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVmTW9kZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJpOiB1cmksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5nZTogdGhpcy5fdGV4dFNwYW5Ub1JhbmdlKHJlZk1vZGVsLCBlbnRyeS50ZXh0U3BhbilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHJlc3VsdF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIERlZmluaXRpb25BZGFwdGVyO1xufShBZGFwdGVyKSk7XG5leHBvcnQgeyBEZWZpbml0aW9uQWRhcHRlciB9O1xuLy8gLS0tIHJlZmVyZW5jZXMgLS0tLS0tXG52YXIgUmVmZXJlbmNlQWRhcHRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVmZXJlbmNlQWRhcHRlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSZWZlcmVuY2VBZGFwdGVyKF9saWJGaWxlcywgd29ya2VyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHdvcmtlcikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX2xpYkZpbGVzID0gX2xpYkZpbGVzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFJlZmVyZW5jZUFkYXB0ZXIucHJvdG90eXBlLnByb3ZpZGVSZWZlcmVuY2VzID0gZnVuY3Rpb24gKG1vZGVsLCBwb3NpdGlvbiwgY29udGV4dCwgdG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJlc291cmNlLCBvZmZzZXQsIHdvcmtlciwgZW50cmllcywgcmVzdWx0LCBfaSwgZW50cmllc18yLCBlbnRyeSwgdXJpLCByZWZNb2RlbDtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc291cmNlID0gbW9kZWwudXJpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gbW9kZWwuZ2V0T2Zmc2V0QXQocG9zaXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5fd29ya2VyKHJlc291cmNlKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtlciA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtb2RlbC5pc0Rpc3Bvc2VkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB3b3JrZXIuZ2V0UmVmZXJlbmNlc0F0UG9zaXRpb24ocmVzb3VyY2UudG9TdHJpbmcoKSwgb2Zmc2V0KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudHJpZXMgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWVudHJpZXMgfHwgbW9kZWwuaXNEaXNwb3NlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmV0Y2ggbGliIGZpbGVzIGlmIG5lY2Vzc2FyeVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5fbGliRmlsZXMuZmV0Y2hMaWJGaWxlc0lmTmVjZXNzYXJ5KGVudHJpZXMubWFwKGZ1bmN0aW9uIChlbnRyeSkgeyByZXR1cm4gVXJpLnBhcnNlKGVudHJ5LmZpbGVOYW1lKTsgfSkpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmV0Y2ggbGliIGZpbGVzIGlmIG5lY2Vzc2FyeVxuICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGVsLmlzRGlzcG9zZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChfaSA9IDAsIGVudHJpZXNfMiA9IGVudHJpZXM7IF9pIDwgZW50cmllc18yLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5ID0gZW50cmllc18yW19pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmkgPSBVcmkucGFyc2UoZW50cnkuZmlsZU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZk1vZGVsID0gdGhpcy5fbGliRmlsZXMuZ2V0T3JDcmVhdGVNb2RlbCh1cmkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWZNb2RlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmk6IHVyaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlOiB0aGlzLl90ZXh0U3BhblRvUmFuZ2UocmVmTW9kZWwsIGVudHJ5LnRleHRTcGFuKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgcmVzdWx0XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gUmVmZXJlbmNlQWRhcHRlcjtcbn0oQWRhcHRlcikpO1xuZXhwb3J0IHsgUmVmZXJlbmNlQWRhcHRlciB9O1xuLy8gLS0tIG91dGxpbmUgLS0tLS0tXG52YXIgT3V0bGluZUFkYXB0ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE91dGxpbmVBZGFwdGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE91dGxpbmVBZGFwdGVyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIE91dGxpbmVBZGFwdGVyLnByb3RvdHlwZS5wcm92aWRlRG9jdW1lbnRTeW1ib2xzID0gZnVuY3Rpb24gKG1vZGVsLCB0b2tlbikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVzb3VyY2UsIHdvcmtlciwgaXRlbXMsIGNvbnZlcnQsIHJlc3VsdDtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvdXJjZSA9IG1vZGVsLnVyaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX3dvcmtlcihyZXNvdXJjZSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICB3b3JrZXIgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobW9kZWwuaXNEaXNwb3NlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgd29ya2VyLmdldE5hdmlnYXRpb25CYXJJdGVtcyhyZXNvdXJjZS50b1N0cmluZygpKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpdGVtcyB8fCBtb2RlbC5pc0Rpc3Bvc2VkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb252ZXJ0ID0gZnVuY3Rpb24gKGJ1Y2tldCwgaXRlbSwgY29udGFpbmVyTGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBpdGVtLnRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbDogJycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IChvdXRsaW5lVHlwZVRhYmxlW2l0ZW0ua2luZF0gfHwgbGFuZ3VhZ2VzLlN5bWJvbEtpbmQuVmFyaWFibGUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5nZTogX3RoaXMuX3RleHRTcGFuVG9SYW5nZShtb2RlbCwgaXRlbS5zcGFuc1swXSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvblJhbmdlOiBfdGhpcy5fdGV4dFNwYW5Ub1JhbmdlKG1vZGVsLCBpdGVtLnNwYW5zWzBdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnczogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lck5hbWU6IGNvbnRhaW5lckxhYmVsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5jaGlsZEl0ZW1zICYmIGl0ZW0uY2hpbGRJdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBpdGVtLmNoaWxkSXRlbXM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb252ZXJ0KGJ1Y2tldCwgY2hpbGQsIHJlc3VsdC5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWNrZXQucHVzaChyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gY29udmVydChyZXN1bHQsIGl0ZW0pOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCByZXN1bHRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBPdXRsaW5lQWRhcHRlcjtcbn0oQWRhcHRlcikpO1xuZXhwb3J0IHsgT3V0bGluZUFkYXB0ZXIgfTtcbnZhciBLaW5kID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEtpbmQoKSB7XG4gICAgfVxuICAgIEtpbmQudW5rbm93biA9ICcnO1xuICAgIEtpbmQua2V5d29yZCA9ICdrZXl3b3JkJztcbiAgICBLaW5kLnNjcmlwdCA9ICdzY3JpcHQnO1xuICAgIEtpbmQubW9kdWxlID0gJ21vZHVsZSc7XG4gICAgS2luZC5jbGFzcyA9ICdjbGFzcyc7XG4gICAgS2luZC5pbnRlcmZhY2UgPSAnaW50ZXJmYWNlJztcbiAgICBLaW5kLnR5cGUgPSAndHlwZSc7XG4gICAgS2luZC5lbnVtID0gJ2VudW0nO1xuICAgIEtpbmQudmFyaWFibGUgPSAndmFyJztcbiAgICBLaW5kLmxvY2FsVmFyaWFibGUgPSAnbG9jYWwgdmFyJztcbiAgICBLaW5kLmZ1bmN0aW9uID0gJ2Z1bmN0aW9uJztcbiAgICBLaW5kLmxvY2FsRnVuY3Rpb24gPSAnbG9jYWwgZnVuY3Rpb24nO1xuICAgIEtpbmQubWVtYmVyRnVuY3Rpb24gPSAnbWV0aG9kJztcbiAgICBLaW5kLm1lbWJlckdldEFjY2Vzc29yID0gJ2dldHRlcic7XG4gICAgS2luZC5tZW1iZXJTZXRBY2Nlc3NvciA9ICdzZXR0ZXInO1xuICAgIEtpbmQubWVtYmVyVmFyaWFibGUgPSAncHJvcGVydHknO1xuICAgIEtpbmQuY29uc3RydWN0b3JJbXBsZW1lbnRhdGlvbiA9ICdjb25zdHJ1Y3Rvcic7XG4gICAgS2luZC5jYWxsU2lnbmF0dXJlID0gJ2NhbGwnO1xuICAgIEtpbmQuaW5kZXhTaWduYXR1cmUgPSAnaW5kZXgnO1xuICAgIEtpbmQuY29uc3RydWN0U2lnbmF0dXJlID0gJ2NvbnN0cnVjdCc7XG4gICAgS2luZC5wYXJhbWV0ZXIgPSAncGFyYW1ldGVyJztcbiAgICBLaW5kLnR5cGVQYXJhbWV0ZXIgPSAndHlwZSBwYXJhbWV0ZXInO1xuICAgIEtpbmQucHJpbWl0aXZlVHlwZSA9ICdwcmltaXRpdmUgdHlwZSc7XG4gICAgS2luZC5sYWJlbCA9ICdsYWJlbCc7XG4gICAgS2luZC5hbGlhcyA9ICdhbGlhcyc7XG4gICAgS2luZC5jb25zdCA9ICdjb25zdCc7XG4gICAgS2luZC5sZXQgPSAnbGV0JztcbiAgICBLaW5kLndhcm5pbmcgPSAnd2FybmluZyc7XG4gICAgcmV0dXJuIEtpbmQ7XG59KCkpO1xuZXhwb3J0IHsgS2luZCB9O1xudmFyIG91dGxpbmVUeXBlVGFibGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xub3V0bGluZVR5cGVUYWJsZVtLaW5kLm1vZHVsZV0gPSBsYW5ndWFnZXMuU3ltYm9sS2luZC5Nb2R1bGU7XG5vdXRsaW5lVHlwZVRhYmxlW0tpbmQuY2xhc3NdID0gbGFuZ3VhZ2VzLlN5bWJvbEtpbmQuQ2xhc3M7XG5vdXRsaW5lVHlwZVRhYmxlW0tpbmQuZW51bV0gPSBsYW5ndWFnZXMuU3ltYm9sS2luZC5FbnVtO1xub3V0bGluZVR5cGVUYWJsZVtLaW5kLmludGVyZmFjZV0gPSBsYW5ndWFnZXMuU3ltYm9sS2luZC5JbnRlcmZhY2U7XG5vdXRsaW5lVHlwZVRhYmxlW0tpbmQubWVtYmVyRnVuY3Rpb25dID0gbGFuZ3VhZ2VzLlN5bWJvbEtpbmQuTWV0aG9kO1xub3V0bGluZVR5cGVUYWJsZVtLaW5kLm1lbWJlclZhcmlhYmxlXSA9IGxhbmd1YWdlcy5TeW1ib2xLaW5kLlByb3BlcnR5O1xub3V0bGluZVR5cGVUYWJsZVtLaW5kLm1lbWJlckdldEFjY2Vzc29yXSA9IGxhbmd1YWdlcy5TeW1ib2xLaW5kLlByb3BlcnR5O1xub3V0bGluZVR5cGVUYWJsZVtLaW5kLm1lbWJlclNldEFjY2Vzc29yXSA9IGxhbmd1YWdlcy5TeW1ib2xLaW5kLlByb3BlcnR5O1xub3V0bGluZVR5cGVUYWJsZVtLaW5kLnZhcmlhYmxlXSA9IGxhbmd1YWdlcy5TeW1ib2xLaW5kLlZhcmlhYmxlO1xub3V0bGluZVR5cGVUYWJsZVtLaW5kLmNvbnN0XSA9IGxhbmd1YWdlcy5TeW1ib2xLaW5kLlZhcmlhYmxlO1xub3V0bGluZVR5cGVUYWJsZVtLaW5kLmxvY2FsVmFyaWFibGVdID0gbGFuZ3VhZ2VzLlN5bWJvbEtpbmQuVmFyaWFibGU7XG5vdXRsaW5lVHlwZVRhYmxlW0tpbmQudmFyaWFibGVdID0gbGFuZ3VhZ2VzLlN5bWJvbEtpbmQuVmFyaWFibGU7XG5vdXRsaW5lVHlwZVRhYmxlW0tpbmQuZnVuY3Rpb25dID0gbGFuZ3VhZ2VzLlN5bWJvbEtpbmQuRnVuY3Rpb247XG5vdXRsaW5lVHlwZVRhYmxlW0tpbmQubG9jYWxGdW5jdGlvbl0gPSBsYW5ndWFnZXMuU3ltYm9sS2luZC5GdW5jdGlvbjtcbi8vIC0tLSBmb3JtYXR0aW5nIC0tLS1cbnZhciBGb3JtYXRIZWxwZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEZvcm1hdEhlbHBlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBGb3JtYXRIZWxwZXIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgRm9ybWF0SGVscGVyLl9jb252ZXJ0T3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBDb252ZXJ0VGFic1RvU3BhY2VzOiBvcHRpb25zLmluc2VydFNwYWNlcyxcbiAgICAgICAgICAgIFRhYlNpemU6IG9wdGlvbnMudGFiU2l6ZSxcbiAgICAgICAgICAgIEluZGVudFNpemU6IG9wdGlvbnMudGFiU2l6ZSxcbiAgICAgICAgICAgIEluZGVudFN0eWxlOiBJbmRlbnRTdHlsZS5TbWFydCxcbiAgICAgICAgICAgIE5ld0xpbmVDaGFyYWN0ZXI6ICdcXG4nLFxuICAgICAgICAgICAgSW5zZXJ0U3BhY2VBZnRlckNvbW1hRGVsaW1pdGVyOiB0cnVlLFxuICAgICAgICAgICAgSW5zZXJ0U3BhY2VBZnRlclNlbWljb2xvbkluRm9yU3RhdGVtZW50czogdHJ1ZSxcbiAgICAgICAgICAgIEluc2VydFNwYWNlQmVmb3JlQW5kQWZ0ZXJCaW5hcnlPcGVyYXRvcnM6IHRydWUsXG4gICAgICAgICAgICBJbnNlcnRTcGFjZUFmdGVyS2V5d29yZHNJbkNvbnRyb2xGbG93U3RhdGVtZW50czogdHJ1ZSxcbiAgICAgICAgICAgIEluc2VydFNwYWNlQWZ0ZXJGdW5jdGlvbktleXdvcmRGb3JBbm9ueW1vdXNGdW5jdGlvbnM6IHRydWUsXG4gICAgICAgICAgICBJbnNlcnRTcGFjZUFmdGVyT3BlbmluZ0FuZEJlZm9yZUNsb3NpbmdOb25lbXB0eVBhcmVudGhlc2lzOiBmYWxzZSxcbiAgICAgICAgICAgIEluc2VydFNwYWNlQWZ0ZXJPcGVuaW5nQW5kQmVmb3JlQ2xvc2luZ05vbmVtcHR5QnJhY2tldHM6IGZhbHNlLFxuICAgICAgICAgICAgSW5zZXJ0U3BhY2VBZnRlck9wZW5pbmdBbmRCZWZvcmVDbG9zaW5nVGVtcGxhdGVTdHJpbmdCcmFjZXM6IGZhbHNlLFxuICAgICAgICAgICAgUGxhY2VPcGVuQnJhY2VPbk5ld0xpbmVGb3JDb250cm9sQmxvY2tzOiBmYWxzZSxcbiAgICAgICAgICAgIFBsYWNlT3BlbkJyYWNlT25OZXdMaW5lRm9yRnVuY3Rpb25zOiBmYWxzZVxuICAgICAgICB9O1xuICAgIH07XG4gICAgRm9ybWF0SGVscGVyLnByb3RvdHlwZS5fY29udmVydFRleHRDaGFuZ2VzID0gZnVuY3Rpb24gKG1vZGVsLCBjaGFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRleHQ6IGNoYW5nZS5uZXdUZXh0LFxuICAgICAgICAgICAgcmFuZ2U6IHRoaXMuX3RleHRTcGFuVG9SYW5nZShtb2RlbCwgY2hhbmdlLnNwYW4pXG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gRm9ybWF0SGVscGVyO1xufShBZGFwdGVyKSk7XG5leHBvcnQgeyBGb3JtYXRIZWxwZXIgfTtcbnZhciBGb3JtYXRBZGFwdGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhGb3JtYXRBZGFwdGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEZvcm1hdEFkYXB0ZXIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgRm9ybWF0QWRhcHRlci5wcm90b3R5cGUucHJvdmlkZURvY3VtZW50UmFuZ2VGb3JtYXR0aW5nRWRpdHMgPSBmdW5jdGlvbiAobW9kZWwsIHJhbmdlLCBvcHRpb25zLCB0b2tlbikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVzb3VyY2UsIHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQsIHdvcmtlciwgZWRpdHM7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2UgPSBtb2RlbC51cmk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydE9mZnNldCA9IG1vZGVsLmdldE9mZnNldEF0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lTnVtYmVyOiByYW5nZS5zdGFydExpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uOiByYW5nZS5zdGFydENvbHVtblxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRPZmZzZXQgPSBtb2RlbC5nZXRPZmZzZXRBdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZU51bWJlcjogcmFuZ2UuZW5kTGluZU51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW46IHJhbmdlLmVuZENvbHVtblxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl93b3JrZXIocmVzb3VyY2UpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgd29ya2VyID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGVsLmlzRGlzcG9zZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHdvcmtlci5nZXRGb3JtYXR0aW5nRWRpdHNGb3JSYW5nZShyZXNvdXJjZS50b1N0cmluZygpLCBzdGFydE9mZnNldCwgZW5kT2Zmc2V0LCBGb3JtYXRIZWxwZXIuX2NvbnZlcnRPcHRpb25zKG9wdGlvbnMpKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRzID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFlZGl0cyB8fCBtb2RlbC5pc0Rpc3Bvc2VkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZWRpdHMubWFwKGZ1bmN0aW9uIChlZGl0KSB7IHJldHVybiBfdGhpcy5fY29udmVydFRleHRDaGFuZ2VzKG1vZGVsLCBlZGl0KTsgfSldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBGb3JtYXRBZGFwdGVyO1xufShGb3JtYXRIZWxwZXIpKTtcbmV4cG9ydCB7IEZvcm1hdEFkYXB0ZXIgfTtcbnZhciBGb3JtYXRPblR5cGVBZGFwdGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhGb3JtYXRPblR5cGVBZGFwdGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEZvcm1hdE9uVHlwZUFkYXB0ZXIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZvcm1hdE9uVHlwZUFkYXB0ZXIucHJvdG90eXBlLCBcImF1dG9Gb3JtYXRUcmlnZ2VyQ2hhcmFjdGVyc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIFsnOycsICd9JywgJ1xcbiddO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgRm9ybWF0T25UeXBlQWRhcHRlci5wcm90b3R5cGUucHJvdmlkZU9uVHlwZUZvcm1hdHRpbmdFZGl0cyA9IGZ1bmN0aW9uIChtb2RlbCwgcG9zaXRpb24sIGNoLCBvcHRpb25zLCB0b2tlbikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVzb3VyY2UsIG9mZnNldCwgd29ya2VyLCBlZGl0cztcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvdXJjZSA9IG1vZGVsLnVyaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IG1vZGVsLmdldE9mZnNldEF0KHBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX3dvcmtlcihyZXNvdXJjZSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICB3b3JrZXIgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobW9kZWwuaXNEaXNwb3NlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgd29ya2VyLmdldEZvcm1hdHRpbmdFZGl0c0FmdGVyS2V5c3Ryb2tlKHJlc291cmNlLnRvU3RyaW5nKCksIG9mZnNldCwgY2gsIEZvcm1hdEhlbHBlci5fY29udmVydE9wdGlvbnMob3B0aW9ucykpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgZWRpdHMgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWVkaXRzIHx8IG1vZGVsLmlzRGlzcG9zZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBlZGl0cy5tYXAoZnVuY3Rpb24gKGVkaXQpIHsgcmV0dXJuIF90aGlzLl9jb252ZXJ0VGV4dENoYW5nZXMobW9kZWwsIGVkaXQpOyB9KV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIEZvcm1hdE9uVHlwZUFkYXB0ZXI7XG59KEZvcm1hdEhlbHBlcikpO1xuZXhwb3J0IHsgRm9ybWF0T25UeXBlQWRhcHRlciB9O1xuLy8gLS0tIGNvZGUgYWN0aW9ucyAtLS0tLS1cbnZhciBDb2RlQWN0aW9uQWRhcHRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ29kZUFjdGlvbkFkYXB0b3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ29kZUFjdGlvbkFkYXB0b3IoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgQ29kZUFjdGlvbkFkYXB0b3IucHJvdG90eXBlLnByb3ZpZGVDb2RlQWN0aW9ucyA9IGZ1bmN0aW9uIChtb2RlbCwgcmFuZ2UsIGNvbnRleHQsIHRva2VuKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZXNvdXJjZSwgc3RhcnQsIGVuZCwgZm9ybWF0T3B0aW9ucywgZXJyb3JDb2Rlcywgd29ya2VyLCBjb2RlRml4ZXMsIGFjdGlvbnM7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2UgPSBtb2RlbC51cmk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IG1vZGVsLmdldE9mZnNldEF0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lTnVtYmVyOiByYW5nZS5zdGFydExpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uOiByYW5nZS5zdGFydENvbHVtblxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSBtb2RlbC5nZXRPZmZzZXRBdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZU51bWJlcjogcmFuZ2UuZW5kTGluZU51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW46IHJhbmdlLmVuZENvbHVtblxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXRPcHRpb25zID0gRm9ybWF0SGVscGVyLl9jb252ZXJ0T3B0aW9ucyhtb2RlbC5nZXRPcHRpb25zKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JDb2RlcyA9IGNvbnRleHQubWFya2Vyc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG0uY29kZTsgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChtKSB7IHJldHVybiBtLmNvZGU7IH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChOdW1iZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5fd29ya2VyKHJlc291cmNlKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtlciA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtb2RlbC5pc0Rpc3Bvc2VkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB3b3JrZXIuZ2V0Q29kZUZpeGVzQXRQb3NpdGlvbihyZXNvdXJjZS50b1N0cmluZygpLCBzdGFydCwgZW5kLCBlcnJvckNvZGVzLCBmb3JtYXRPcHRpb25zKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVGaXhlcyA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY29kZUZpeGVzIHx8IG1vZGVsLmlzRGlzcG9zZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB7IGFjdGlvbnM6IFtdLCBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7IH0gfV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb25zID0gY29kZUZpeGVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoZml4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlcyBhbnkgJ21ha2UgYSBuZXcgZmlsZSctdHlwZSBjb2RlIGZpeFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmaXguY2hhbmdlcy5maWx0ZXIoZnVuY3Rpb24gKGNoYW5nZSkgeyByZXR1cm4gY2hhbmdlLmlzTmV3RmlsZTsgfSkubGVuZ3RoID09PSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChmaXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX3RzQ29kZUZpeEFjdGlvblRvTW9uYWNvQ29kZUFjdGlvbihtb2RlbCwgY29udGV4dCwgZml4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uczogYWN0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcG9zZTogZnVuY3Rpb24gKCkgeyB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ29kZUFjdGlvbkFkYXB0b3IucHJvdG90eXBlLl90c0NvZGVGaXhBY3Rpb25Ub01vbmFjb0NvZGVBY3Rpb24gPSBmdW5jdGlvbiAobW9kZWwsIGNvbnRleHQsIGNvZGVGaXgpIHtcbiAgICAgICAgdmFyIGVkaXRzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBjb2RlRml4LmNoYW5nZXM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2hhbmdlID0gX2FbX2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgX2IgPSAwLCBfYyA9IGNoYW5nZS50ZXh0Q2hhbmdlczsgX2IgPCBfYy5sZW5ndGg7IF9iKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgdGV4dENoYW5nZSA9IF9jW19iXTtcbiAgICAgICAgICAgICAgICBlZGl0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2U6IG1vZGVsLnVyaSxcbiAgICAgICAgICAgICAgICAgICAgZWRpdDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IHRoaXMuX3RleHRTcGFuVG9SYW5nZShtb2RlbCwgdGV4dENoYW5nZS5zcGFuKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IHRleHRDaGFuZ2UubmV3VGV4dFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFjdGlvbiA9IHtcbiAgICAgICAgICAgIHRpdGxlOiBjb2RlRml4LmRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgZWRpdDogeyBlZGl0czogZWRpdHMgfSxcbiAgICAgICAgICAgIGRpYWdub3N0aWNzOiBjb250ZXh0Lm1hcmtlcnMsXG4gICAgICAgICAgICBraW5kOiAncXVpY2tmaXgnXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhY3Rpb247XG4gICAgfTtcbiAgICByZXR1cm4gQ29kZUFjdGlvbkFkYXB0b3I7XG59KEZvcm1hdEhlbHBlcikpO1xuZXhwb3J0IHsgQ29kZUFjdGlvbkFkYXB0b3IgfTtcbi8vIC0tLSByZW5hbWUgLS0tLVxudmFyIFJlbmFtZUFkYXB0ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJlbmFtZUFkYXB0ZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmVuYW1lQWRhcHRlcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBSZW5hbWVBZGFwdGVyLnByb3RvdHlwZS5wcm92aWRlUmVuYW1lRWRpdHMgPSBmdW5jdGlvbiAobW9kZWwsIHBvc2l0aW9uLCBuZXdOYW1lLCB0b2tlbikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVzb3VyY2UsIGZpbGVOYW1lLCBvZmZzZXQsIHdvcmtlciwgcmVuYW1lSW5mbywgcmVuYW1lTG9jYXRpb25zLCBlZGl0cywgX2ksIHJlbmFtZUxvY2F0aW9uc18xLCByZW5hbWVMb2NhdGlvbiwgcmVzb3VyY2VfMSwgbW9kZWxfMTtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc291cmNlID0gbW9kZWwudXJpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZU5hbWUgPSByZXNvdXJjZS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gbW9kZWwuZ2V0T2Zmc2V0QXQocG9zaXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5fd29ya2VyKHJlc291cmNlKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtlciA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtb2RlbC5pc0Rpc3Bvc2VkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB3b3JrZXIuZ2V0UmVuYW1lSW5mbyhmaWxlTmFtZSwgb2Zmc2V0LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93UmVuYW1lT2ZJbXBvcnRQYXRoOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVuYW1lSW5mbyA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZW5hbWVJbmZvLmNhblJlbmFtZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB1c2UgZXhwbGljaXQgY29tcGFyaXNvbiBzbyB0aGF0IHRoZSBkaXNjcmltaW5hdGVkIHVuaW9uIGdldHMgcmVzb2x2ZWQgcHJvcGVybHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWRpdHM6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0UmVhc29uOiByZW5hbWVJbmZvLmxvY2FsaXplZEVycm9yTWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZW5hbWVJbmZvLmZpbGVUb1JlbmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZW5hbWluZyBmaWxlcyBpcyBub3Qgc3VwcG9ydGVkLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgd29ya2VyLmZpbmRSZW5hbWVMb2NhdGlvbnMoZmlsZU5hbWUsIG9mZnNldCwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLypzdHJpbmdzKi8gZmFsc2UsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qY29tbWVudHMqLyBmYWxzZSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLypwcmVmaXhBbmRTdWZmaXgqLyBmYWxzZSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICByZW5hbWVMb2NhdGlvbnMgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJlbmFtZUxvY2F0aW9ucyB8fCBtb2RlbC5pc0Rpc3Bvc2VkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlZGl0cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChfaSA9IDAsIHJlbmFtZUxvY2F0aW9uc18xID0gcmVuYW1lTG9jYXRpb25zOyBfaSA8IHJlbmFtZUxvY2F0aW9uc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbmFtZUxvY2F0aW9uID0gcmVuYW1lTG9jYXRpb25zXzFbX2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc291cmNlXzEgPSBVcmkucGFyc2UocmVuYW1lTG9jYXRpb24uZmlsZU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsXzEgPSBlZGl0b3IuZ2V0TW9kZWwocmVzb3VyY2VfMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGVsXzEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWRpdHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvdXJjZTogcmVzb3VyY2VfMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkaXQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5nZTogdGhpcy5fdGV4dFNwYW5Ub1JhbmdlKG1vZGVsXzEsIHJlbmFtZUxvY2F0aW9uLnRleHRTcGFuKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBuZXdOYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBVUkkgXCIgKyByZXNvdXJjZV8xICsgXCIuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB7IGVkaXRzOiBlZGl0cyB9XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gUmVuYW1lQWRhcHRlcjtcbn0oQWRhcHRlcikpO1xuZXhwb3J0IHsgUmVuYW1lQWRhcHRlciB9O1xuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4ndXNlIHN0cmljdCc7XG5pbXBvcnQgeyBXb3JrZXJNYW5hZ2VyIH0gZnJvbSAnLi93b3JrZXJNYW5hZ2VyLmpzJztcbmltcG9ydCAqIGFzIGxhbmd1YWdlRmVhdHVyZXMgZnJvbSAnLi9sYW5ndWFnZUZlYXR1cmVzLmpzJztcbmltcG9ydCB7IGxhbmd1YWdlcyB9IGZyb20gJy4vZmlsbGVycy9tb25hY28tZWRpdG9yLWNvcmUuanMnO1xudmFyIGphdmFTY3JpcHRXb3JrZXI7XG52YXIgdHlwZVNjcmlwdFdvcmtlcjtcbmV4cG9ydCBmdW5jdGlvbiBzZXR1cFR5cGVTY3JpcHQoZGVmYXVsdHMpIHtcbiAgICB0eXBlU2NyaXB0V29ya2VyID0gc2V0dXBNb2RlKGRlZmF1bHRzLCAndHlwZXNjcmlwdCcpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNldHVwSmF2YVNjcmlwdChkZWZhdWx0cykge1xuICAgIGphdmFTY3JpcHRXb3JrZXIgPSBzZXR1cE1vZGUoZGVmYXVsdHMsICdqYXZhc2NyaXB0Jyk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0SmF2YVNjcmlwdFdvcmtlcigpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBpZiAoIWphdmFTY3JpcHRXb3JrZXIpIHtcbiAgICAgICAgICAgIHJldHVybiByZWplY3QoJ0phdmFTY3JpcHQgbm90IHJlZ2lzdGVyZWQhJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZShqYXZhU2NyaXB0V29ya2VyKTtcbiAgICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRUeXBlU2NyaXB0V29ya2VyKCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGlmICghdHlwZVNjcmlwdFdvcmtlcikge1xuICAgICAgICAgICAgcmV0dXJuIHJlamVjdCgnVHlwZVNjcmlwdCBub3QgcmVnaXN0ZXJlZCEnKTtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKHR5cGVTY3JpcHRXb3JrZXIpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gc2V0dXBNb2RlKGRlZmF1bHRzLCBtb2RlSWQpIHtcbiAgICB2YXIgY2xpZW50ID0gbmV3IFdvcmtlck1hbmFnZXIobW9kZUlkLCBkZWZhdWx0cyk7XG4gICAgdmFyIHdvcmtlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHVyaXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHVyaXNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2xpZW50LmdldExhbmd1YWdlU2VydmljZVdvcmtlci5hcHBseShjbGllbnQsIHVyaXMpO1xuICAgIH07XG4gICAgdmFyIGxpYkZpbGVzID0gbmV3IGxhbmd1YWdlRmVhdHVyZXMuTGliRmlsZXMod29ya2VyKTtcbiAgICBsYW5ndWFnZXMucmVnaXN0ZXJDb21wbGV0aW9uSXRlbVByb3ZpZGVyKG1vZGVJZCwgbmV3IGxhbmd1YWdlRmVhdHVyZXMuU3VnZ2VzdEFkYXB0ZXIod29ya2VyKSk7XG4gICAgbGFuZ3VhZ2VzLnJlZ2lzdGVyU2lnbmF0dXJlSGVscFByb3ZpZGVyKG1vZGVJZCwgbmV3IGxhbmd1YWdlRmVhdHVyZXMuU2lnbmF0dXJlSGVscEFkYXB0ZXIod29ya2VyKSk7XG4gICAgbGFuZ3VhZ2VzLnJlZ2lzdGVySG92ZXJQcm92aWRlcihtb2RlSWQsIG5ldyBsYW5ndWFnZUZlYXR1cmVzLlF1aWNrSW5mb0FkYXB0ZXIod29ya2VyKSk7XG4gICAgbGFuZ3VhZ2VzLnJlZ2lzdGVyRG9jdW1lbnRIaWdobGlnaHRQcm92aWRlcihtb2RlSWQsIG5ldyBsYW5ndWFnZUZlYXR1cmVzLk9jY3VycmVuY2VzQWRhcHRlcih3b3JrZXIpKTtcbiAgICBsYW5ndWFnZXMucmVnaXN0ZXJEZWZpbml0aW9uUHJvdmlkZXIobW9kZUlkLCBuZXcgbGFuZ3VhZ2VGZWF0dXJlcy5EZWZpbml0aW9uQWRhcHRlcihsaWJGaWxlcywgd29ya2VyKSk7XG4gICAgbGFuZ3VhZ2VzLnJlZ2lzdGVyUmVmZXJlbmNlUHJvdmlkZXIobW9kZUlkLCBuZXcgbGFuZ3VhZ2VGZWF0dXJlcy5SZWZlcmVuY2VBZGFwdGVyKGxpYkZpbGVzLCB3b3JrZXIpKTtcbiAgICBsYW5ndWFnZXMucmVnaXN0ZXJEb2N1bWVudFN5bWJvbFByb3ZpZGVyKG1vZGVJZCwgbmV3IGxhbmd1YWdlRmVhdHVyZXMuT3V0bGluZUFkYXB0ZXIod29ya2VyKSk7XG4gICAgbGFuZ3VhZ2VzLnJlZ2lzdGVyRG9jdW1lbnRSYW5nZUZvcm1hdHRpbmdFZGl0UHJvdmlkZXIobW9kZUlkLCBuZXcgbGFuZ3VhZ2VGZWF0dXJlcy5Gb3JtYXRBZGFwdGVyKHdvcmtlcikpO1xuICAgIGxhbmd1YWdlcy5yZWdpc3Rlck9uVHlwZUZvcm1hdHRpbmdFZGl0UHJvdmlkZXIobW9kZUlkLCBuZXcgbGFuZ3VhZ2VGZWF0dXJlcy5Gb3JtYXRPblR5cGVBZGFwdGVyKHdvcmtlcikpO1xuICAgIGxhbmd1YWdlcy5yZWdpc3RlckNvZGVBY3Rpb25Qcm92aWRlcihtb2RlSWQsIG5ldyBsYW5ndWFnZUZlYXR1cmVzLkNvZGVBY3Rpb25BZGFwdG9yKHdvcmtlcikpO1xuICAgIGxhbmd1YWdlcy5yZWdpc3RlclJlbmFtZVByb3ZpZGVyKG1vZGVJZCwgbmV3IGxhbmd1YWdlRmVhdHVyZXMuUmVuYW1lQWRhcHRlcih3b3JrZXIpKTtcbiAgICBuZXcgbGFuZ3VhZ2VGZWF0dXJlcy5EaWFnbm9zdGljc0FkYXB0ZXIobGliRmlsZXMsIGRlZmF1bHRzLCBtb2RlSWQsIHdvcmtlcik7XG4gICAgcmV0dXJuIHdvcmtlcjtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///32501\n")}}]);