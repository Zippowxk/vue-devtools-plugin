/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_vue_devtools"] = self["webpackChunk_vue_devtools"] || []).push([["vendors-node_modules_monaco-editor_esm_vs_basic-languages_elixir_elixir_js"],{

/***/ "../../node_modules/monaco-editor/esm/vs/basic-languages/elixir/elixir.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/monaco-editor/esm/vs/basic-languages/elixir/elixir.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"conf\": () => (/* binding */ conf),\n/* harmony export */   \"language\": () => (/* binding */ language)\n/* harmony export */ });\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar conf = {\n    comments: {\n        lineComment: '#'\n    },\n    brackets: [\n        ['{', '}'],\n        ['[', ']'],\n        ['(', ')']\n    ],\n    surroundingPairs: [\n        { open: '{', close: '}' },\n        { open: '[', close: ']' },\n        { open: '(', close: ')' },\n        { open: \"'\", close: \"'\" },\n        { open: '\"', close: '\"' }\n    ],\n    autoClosingPairs: [\n        { open: \"'\", close: \"'\", notIn: ['string', 'comment'] },\n        { open: '\"', close: '\"', notIn: ['comment'] },\n        { open: '\"\"\"', close: '\"\"\"' },\n        { open: '`', close: '`', notIn: ['string', 'comment'] },\n        { open: '(', close: ')' },\n        { open: '{', close: '}' },\n        { open: '[', close: ']' },\n        { open: '<<', close: '>>' }\n    ],\n    indentationRules: {\n        increaseIndentPattern: /^\\s*(after|else|catch|rescue|fn|[^#]*(do|<\\-|\\->|\\{|\\[|\\=))\\s*$/,\n        decreaseIndentPattern: /^\\s*((\\}|\\])\\s*$|(after|else|catch|rescue|end)\\b)/\n    }\n};\n/**\n * A Monarch lexer for the Elixir language.\n *\n * References:\n *\n * * Monarch documentation - https://microsoft.github.io/monaco-editor/monarch.html\n * * Elixir lexer - https://github.com/elixir-makeup/makeup_elixir/blob/master/lib/makeup/lexers/elixir_lexer.ex\n * * TextMate lexer (elixir-tmbundle) - https://github.com/elixir-editors/elixir-tmbundle/blob/master/Syntaxes/Elixir.tmLanguage\n * * TextMate lexer (vscode-elixir-ls) - https://github.com/elixir-lsp/vscode-elixir-ls/blob/master/syntaxes/elixir.json\n */\nvar language = {\n    defaultToken: 'source',\n    tokenPostfix: '.elixir',\n    brackets: [\n        { open: '[', close: ']', token: 'delimiter.square' },\n        { open: '(', close: ')', token: 'delimiter.parenthesis' },\n        { open: '{', close: '}', token: 'delimiter.curly' },\n        { open: '<<', close: '>>', token: 'delimiter.angle.special' }\n    ],\n    // Below are lists/regexps to which we reference later.\n    declarationKeywords: [\n        'def',\n        'defp',\n        'defn',\n        'defnp',\n        'defguard',\n        'defguardp',\n        'defmacro',\n        'defmacrop',\n        'defdelegate',\n        'defcallback',\n        'defmacrocallback',\n        'defmodule',\n        'defprotocol',\n        'defexception',\n        'defimpl',\n        'defstruct'\n    ],\n    operatorKeywords: ['and', 'in', 'not', 'or', 'when'],\n    namespaceKeywords: ['alias', 'import', 'require', 'use'],\n    otherKeywords: [\n        'after',\n        'case',\n        'catch',\n        'cond',\n        'do',\n        'else',\n        'end',\n        'fn',\n        'for',\n        'if',\n        'quote',\n        'raise',\n        'receive',\n        'rescue',\n        'super',\n        'throw',\n        'try',\n        'unless',\n        'unquote_splicing',\n        'unquote',\n        'with'\n    ],\n    constants: ['true', 'false', 'nil'],\n    nameBuiltin: ['__MODULE__', '__DIR__', '__ENV__', '__CALLER__', '__STACKTRACE__'],\n    // Matches any of the operator names:\n    // <<< >>> ||| &&& ^^^ ~~~ === !== ~>> <~> |~> <|> == != <= >= && || \\\\ <> ++ -- |> =~ -> <- ~> <~ :: .. = < > + - * / | . ^ & !\n    operator: /-[->]?|!={0,2}|\\*|\\/|\\\\\\\\|&{1,3}|\\.\\.?|\\^(?:\\^\\^)?|\\+\\+?|<(?:-|<<|=|>|\\|>|~>?)?|=~|={1,3}|>(?:=|>>)?|\\|~>|\\|>|\\|{1,3}|~>>?|~~~|::/,\n    // See https://hexdocs.pm/elixir/syntax-reference.html#variables\n    variableName: /[a-z_][a-zA-Z0-9_]*[?!]?/,\n    // See https://hexdocs.pm/elixir/syntax-reference.html#atoms\n    atomName: /[a-zA-Z_][a-zA-Z0-9_@]*[?!]?|@specialAtomName|@operator/,\n    specialAtomName: /\\.\\.\\.|<<>>|%\\{\\}|%|\\{\\}/,\n    aliasPart: /[A-Z][a-zA-Z0-9_]*/,\n    moduleName: /@aliasPart(?:\\.@aliasPart)*/,\n    // Sigil pairs are: \"\"\" \"\"\", ''' ''', \" \", ' ', / /, | |, < >, { }, [ ], ( )\n    sigilSymmetricDelimiter: /\"\"\"|'''|\"|'|\\/|\\|/,\n    sigilStartDelimiter: /@sigilSymmetricDelimiter|<|\\{|\\[|\\(/,\n    sigilEndDelimiter: /@sigilSymmetricDelimiter|>|\\}|\\]|\\)/,\n    decimal: /\\d(?:_?\\d)*/,\n    hex: /[0-9a-fA-F](_?[0-9a-fA-F])*/,\n    octal: /[0-7](_?[0-7])*/,\n    binary: /[01](_?[01])*/,\n    // See https://hexdocs.pm/elixir/master/String.html#module-escape-characters\n    escape: /\\\\u[0-9a-fA-F]{4}|\\\\x[0-9a-fA-F]{2}|\\\\./,\n    // The keys below correspond to tokenizer states.\n    // We start from the root state and match against its rules\n    // until we explicitly transition into another state.\n    // The `include` simply brings in all operations from the given state\n    // and is useful for improving readability.\n    tokenizer: {\n        root: [\n            { include: '@whitespace' },\n            { include: '@comments' },\n            // Keywords start as either an identifier or a string,\n            // but end with a : so it's important to match this first.\n            { include: '@keywordsShorthand' },\n            { include: '@numbers' },\n            { include: '@identifiers' },\n            { include: '@strings' },\n            { include: '@atoms' },\n            { include: '@sigils' },\n            { include: '@attributes' },\n            { include: '@symbols' }\n        ],\n        // Whitespace\n        whitespace: [[/\\s+/, 'white']],\n        // Comments\n        comments: [[/(#)(.*)/, ['comment.punctuation', 'comment']]],\n        // Keyword list shorthand\n        keywordsShorthand: [\n            [/(@atomName)(:)/, ['constant', 'constant.punctuation']],\n            // Use positive look-ahead to ensure the string is followed by :\n            // and should be considered a keyword.\n            [\n                /\"(?=([^\"]|#\\{.*?\\}|\\\\\")*\":)/,\n                { token: 'constant.delimiter', next: '@doubleQuotedStringKeyword' }\n            ],\n            [\n                /'(?=([^']|#\\{.*?\\}|\\\\')*':)/,\n                { token: 'constant.delimiter', next: '@singleQuotedStringKeyword' }\n            ]\n        ],\n        doubleQuotedStringKeyword: [\n            [/\":/, { token: 'constant.delimiter', next: '@pop' }],\n            { include: '@stringConstantContentInterpol' }\n        ],\n        singleQuotedStringKeyword: [\n            [/':/, { token: 'constant.delimiter', next: '@pop' }],\n            { include: '@stringConstantContentInterpol' }\n        ],\n        // Numbers\n        numbers: [\n            [/0b@binary/, 'number.binary'],\n            [/0o@octal/, 'number.octal'],\n            [/0x@hex/, 'number.hex'],\n            [/@decimal\\.@decimal([eE]-?@decimal)?/, 'number.float'],\n            [/@decimal/, 'number']\n        ],\n        // Identifiers\n        identifiers: [\n            // Tokenize identifier name in function-like definitions.\n            // Note: given `def a + b, do: nil`, `a` is not a function name,\n            // so we use negative look-ahead to ensure there's no operator.\n            [\n                /\\b(defp?|defnp?|defmacrop?|defguardp?|defdelegate)(\\s+)(@variableName)(?!\\s+@operator)/,\n                [\n                    'keyword.declaration',\n                    'white',\n                    {\n                        cases: {\n                            unquote: 'keyword',\n                            '@default': 'function'\n                        }\n                    }\n                ]\n            ],\n            // Tokenize function calls\n            [\n                // In-scope call - an identifier followed by ( or .(\n                /(@variableName)(?=\\s*\\.?\\s*\\()/,\n                {\n                    cases: {\n                        // Tokenize as keyword in cases like `if(..., do: ..., else: ...)`\n                        '@declarationKeywords': 'keyword.declaration',\n                        '@namespaceKeywords': 'keyword',\n                        '@otherKeywords': 'keyword',\n                        '@default': 'function.call'\n                    }\n                }\n            ],\n            [\n                // Referencing function in a module\n                /(@moduleName)(\\s*)(\\.)(\\s*)(@variableName)/,\n                ['type.identifier', 'white', 'operator', 'white', 'function.call']\n            ],\n            [\n                // Referencing function in an Erlang module\n                /(:)(@atomName)(\\s*)(\\.)(\\s*)(@variableName)/,\n                ['constant.punctuation', 'constant', 'white', 'operator', 'white', 'function.call']\n            ],\n            [\n                // Piping into a function (tokenized separately as it may not have parentheses)\n                /(\\|>)(\\s*)(@variableName)/,\n                [\n                    'operator',\n                    'white',\n                    {\n                        cases: {\n                            '@otherKeywords': 'keyword',\n                            '@default': 'function.call'\n                        }\n                    }\n                ]\n            ],\n            [\n                // Function reference passed to another function\n                /(&)(\\s*)(@variableName)/,\n                ['operator', 'white', 'function.call']\n            ],\n            // Language keywords, builtins, constants and variables\n            [\n                /@variableName/,\n                {\n                    cases: {\n                        '@declarationKeywords': 'keyword.declaration',\n                        '@operatorKeywords': 'keyword.operator',\n                        '@namespaceKeywords': 'keyword',\n                        '@otherKeywords': 'keyword',\n                        '@constants': 'constant.language',\n                        '@nameBuiltin': 'variable.language',\n                        '_.*': 'comment.unused',\n                        '@default': 'identifier'\n                    }\n                }\n            ],\n            // Module names\n            [/@moduleName/, 'type.identifier']\n        ],\n        // Strings\n        strings: [\n            [/\"\"\"/, { token: 'string.delimiter', next: '@doubleQuotedHeredoc' }],\n            [/'''/, { token: 'string.delimiter', next: '@singleQuotedHeredoc' }],\n            [/\"/, { token: 'string.delimiter', next: '@doubleQuotedString' }],\n            [/'/, { token: 'string.delimiter', next: '@singleQuotedString' }]\n        ],\n        doubleQuotedHeredoc: [\n            [/\"\"\"/, { token: 'string.delimiter', next: '@pop' }],\n            { include: '@stringContentInterpol' }\n        ],\n        singleQuotedHeredoc: [\n            [/'''/, { token: 'string.delimiter', next: '@pop' }],\n            { include: '@stringContentInterpol' }\n        ],\n        doubleQuotedString: [\n            [/\"/, { token: 'string.delimiter', next: '@pop' }],\n            { include: '@stringContentInterpol' }\n        ],\n        singleQuotedString: [\n            [/'/, { token: 'string.delimiter', next: '@pop' }],\n            { include: '@stringContentInterpol' }\n        ],\n        // Atoms\n        atoms: [\n            [/(:)(@atomName)/, ['constant.punctuation', 'constant']],\n            [/:\"/, { token: 'constant.delimiter', next: '@doubleQuotedStringAtom' }],\n            [/:'/, { token: 'constant.delimiter', next: '@singleQuotedStringAtom' }]\n        ],\n        doubleQuotedStringAtom: [\n            [/\"/, { token: 'constant.delimiter', next: '@pop' }],\n            { include: '@stringConstantContentInterpol' }\n        ],\n        singleQuotedStringAtom: [\n            [/'/, { token: 'constant.delimiter', next: '@pop' }],\n            { include: '@stringConstantContentInterpol' }\n        ],\n        // Sigils\n        // See https://elixir-lang.org/getting-started/sigils.html\n        // Sigils allow for typing values using their textual representation.\n        // All sigils start with ~ followed by a letter indicating sigil type\n        // and then a delimiter pair enclosing the textual representation.\n        // Optional modifiers are allowed after the closing delimiter.\n        // For instance a regular expressions can be written as:\n        // ~r/foo|bar/ ~r{foo|bar} ~r/foo|bar/g\n        //\n        // In general lowercase sigils allow for interpolation\n        // and escaped characters, whereas uppercase sigils don't\n        //\n        // During tokenization we want to distinguish some\n        // specific sigil types, namely string and regexp,\n        // so that they cen be themed separately.\n        //\n        // To reasonably handle all those combinations we leverage\n        // dot-separated states, so if we transition to @sigilStart.interpol.s.{.}\n        // then \"sigilStart.interpol.s\" state will match and also all\n        // the individual dot-separated parameters can be accessed.\n        sigils: [\n            [/~[a-z]@sigilStartDelimiter/, { token: '@rematch', next: '@sigil.interpol' }],\n            [/~[A-Z]@sigilStartDelimiter/, { token: '@rematch', next: '@sigil.noInterpol' }]\n        ],\n        sigil: [\n            [/~([a-zA-Z])\\{/, { token: '@rematch', switchTo: '@sigilStart.$S2.$1.{.}' }],\n            [/~([a-zA-Z])\\[/, { token: '@rematch', switchTo: '@sigilStart.$S2.$1.[.]' }],\n            [/~([a-zA-Z])\\(/, { token: '@rematch', switchTo: '@sigilStart.$S2.$1.(.)' }],\n            [/~([a-zA-Z])\\</, { token: '@rematch', switchTo: '@sigilStart.$S2.$1.<.>' }],\n            [\n                /~([a-zA-Z])(@sigilSymmetricDelimiter)/,\n                { token: '@rematch', switchTo: '@sigilStart.$S2.$1.$2.$2' }\n            ]\n        ],\n        // The definitions below expect states to be of the form:\n        //\n        // sigilStart.<interpol-or-noInterpol>.<sigil-letter>.<start-delimiter>.<end-delimiter>\n        // sigilContinue.<interpol-or-noInterpol>.<sigil-letter>.<start-delimiter>.<end-delimiter>\n        //\n        // The sigilStart state is used only to properly classify the token (as string/regex/sigil)\n        // and immediately switches to the sigilContinue sate, which handles the actual content\n        // and waits for the corresponding end delimiter.\n        'sigilStart.interpol.s': [\n            [\n                /~s@sigilStartDelimiter/,\n                {\n                    token: 'string.delimiter',\n                    switchTo: '@sigilContinue.$S2.$S3.$S4.$S5'\n                }\n            ]\n        ],\n        'sigilContinue.interpol.s': [\n            [\n                /(@sigilEndDelimiter)[a-zA-Z]*/,\n                {\n                    cases: {\n                        '$1==$S5': { token: 'string.delimiter', next: '@pop' },\n                        '@default': 'string'\n                    }\n                }\n            ],\n            { include: '@stringContentInterpol' }\n        ],\n        'sigilStart.noInterpol.S': [\n            [\n                /~S@sigilStartDelimiter/,\n                {\n                    token: 'string.delimiter',\n                    switchTo: '@sigilContinue.$S2.$S3.$S4.$S5'\n                }\n            ]\n        ],\n        'sigilContinue.noInterpol.S': [\n            // Ignore escaped sigil end\n            [/(^|[^\\\\])\\\\@sigilEndDelimiter/, 'string'],\n            [\n                /(@sigilEndDelimiter)[a-zA-Z]*/,\n                {\n                    cases: {\n                        '$1==$S5': { token: 'string.delimiter', next: '@pop' },\n                        '@default': 'string'\n                    }\n                }\n            ],\n            { include: '@stringContent' }\n        ],\n        'sigilStart.interpol.r': [\n            [\n                /~r@sigilStartDelimiter/,\n                {\n                    token: 'regexp.delimiter',\n                    switchTo: '@sigilContinue.$S2.$S3.$S4.$S5'\n                }\n            ]\n        ],\n        'sigilContinue.interpol.r': [\n            [\n                /(@sigilEndDelimiter)[a-zA-Z]*/,\n                {\n                    cases: {\n                        '$1==$S5': { token: 'regexp.delimiter', next: '@pop' },\n                        '@default': 'regexp'\n                    }\n                }\n            ],\n            { include: '@regexpContentInterpol' }\n        ],\n        'sigilStart.noInterpol.R': [\n            [\n                /~R@sigilStartDelimiter/,\n                {\n                    token: 'regexp.delimiter',\n                    switchTo: '@sigilContinue.$S2.$S3.$S4.$S5'\n                }\n            ]\n        ],\n        'sigilContinue.noInterpol.R': [\n            // Ignore escaped sigil end\n            [/(^|[^\\\\])\\\\@sigilEndDelimiter/, 'regexp'],\n            [\n                /(@sigilEndDelimiter)[a-zA-Z]*/,\n                {\n                    cases: {\n                        '$1==$S5': { token: 'regexp.delimiter', next: '@pop' },\n                        '@default': 'regexp'\n                    }\n                }\n            ],\n            { include: '@regexpContent' }\n        ],\n        // Fallback to the generic sigil by default\n        'sigilStart.interpol': [\n            [\n                /~([a-zA-Z])@sigilStartDelimiter/,\n                {\n                    token: 'sigil.delimiter',\n                    switchTo: '@sigilContinue.$S2.$S3.$S4.$S5'\n                }\n            ]\n        ],\n        'sigilContinue.interpol': [\n            [\n                /(@sigilEndDelimiter)[a-zA-Z]*/,\n                {\n                    cases: {\n                        '$1==$S5': { token: 'sigil.delimiter', next: '@pop' },\n                        '@default': 'sigil'\n                    }\n                }\n            ],\n            { include: '@sigilContentInterpol' }\n        ],\n        'sigilStart.noInterpol': [\n            [\n                /~([a-zA-Z])@sigilStartDelimiter/,\n                {\n                    token: 'sigil.delimiter',\n                    switchTo: '@sigilContinue.$S2.$S3.$S4.$S5'\n                }\n            ]\n        ],\n        'sigilContinue.noInterpol': [\n            // Ignore escaped sigil end\n            [/(^|[^\\\\])\\\\@sigilEndDelimiter/, 'sigil'],\n            [\n                /(@sigilEndDelimiter)[a-zA-Z]*/,\n                {\n                    cases: {\n                        '$1==$S5': { token: 'sigil.delimiter', next: '@pop' },\n                        '@default': 'sigil'\n                    }\n                }\n            ],\n            { include: '@sigilContent' }\n        ],\n        // Attributes\n        attributes: [\n            // Module @doc* attributes - tokenized as comments\n            [\n                /\\@(module|type)?doc (~[sS])?\"\"\"/,\n                {\n                    token: 'comment.block.documentation',\n                    next: '@doubleQuotedHeredocDocstring'\n                }\n            ],\n            [\n                /\\@(module|type)?doc (~[sS])?\"/,\n                {\n                    token: 'comment.block.documentation',\n                    next: '@doubleQuotedStringDocstring'\n                }\n            ],\n            [/\\@(module|type)?doc false/, 'comment.block.documentation'],\n            // Module attributes\n            [/\\@(@variableName)/, 'variable']\n        ],\n        doubleQuotedHeredocDocstring: [\n            [/\"\"\"/, { token: 'comment.block.documentation', next: '@pop' }],\n            { include: '@docstringContent' }\n        ],\n        doubleQuotedStringDocstring: [\n            [/\"/, { token: 'comment.block.documentation', next: '@pop' }],\n            { include: '@docstringContent' }\n        ],\n        // Operators, punctuation, brackets\n        symbols: [\n            // Code point operator (either with regular character ?a or an escaped one ?\\n)\n            [/\\?(\\\\.|[^\\\\\\s])/, 'number.constant'],\n            // Anonymous function arguments\n            [/&\\d+/, 'operator'],\n            // Bitshift operators (must go before delimiters, so that << >> don't match first)\n            [/<<<|>>>/, 'operator'],\n            // Delimiter pairs\n            [/[()\\[\\]\\{\\}]|<<|>>/, '@brackets'],\n            // Triple dot is a valid name (must go before operators, so that .. doesn't match instead)\n            [/\\.\\.\\./, 'identifier'],\n            // Punctuation => (must go before operators, so it's not tokenized as = then >)\n            [/=>/, 'punctuation'],\n            // Operators\n            [/@operator/, 'operator'],\n            // Punctuation\n            [/[:;,.%]/, 'punctuation']\n        ],\n        // Generic helpers\n        stringContentInterpol: [\n            { include: '@interpolation' },\n            { include: '@escapeChar' },\n            { include: '@stringContent' }\n        ],\n        stringContent: [[/./, 'string']],\n        stringConstantContentInterpol: [\n            { include: '@interpolation' },\n            { include: '@escapeChar' },\n            { include: '@stringConstantContent' }\n        ],\n        stringConstantContent: [[/./, 'constant']],\n        regexpContentInterpol: [\n            { include: '@interpolation' },\n            { include: '@escapeChar' },\n            { include: '@regexpContent' }\n        ],\n        regexpContent: [\n            // # may be a regular regexp char, so we use a heuristic\n            // assuming a # surrounded by whitespace is actually a comment.\n            [/(\\s)(#)(\\s.*)$/, ['white', 'comment.punctuation', 'comment']],\n            [/./, 'regexp']\n        ],\n        sigilContentInterpol: [\n            { include: '@interpolation' },\n            { include: '@escapeChar' },\n            { include: '@sigilContent' }\n        ],\n        sigilContent: [[/./, 'sigil']],\n        docstringContent: [[/./, 'comment.block.documentation']],\n        escapeChar: [[/@escape/, 'constant.character.escape']],\n        interpolation: [\n            [/#{/, { token: 'delimiter.bracket.embed', next: '@interpolationContinue' }]\n        ],\n        interpolationContinue: [\n            [/}/, { token: 'delimiter.bracket.embed', next: '@pop' }],\n            // Interpolation brackets may contain arbitrary code,\n            // so we simply match against all the root rules,\n            // until we reach interpolation end (the above matches).\n            { include: '@root' }\n        ]\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AdnVlL2RldnRvb2xzLy4uLy4uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9iYXNpYy1sYW5ndWFnZXMvZWxpeGlyL2VsaXhpci5qcz82ZTFmIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxXQUFXLEtBQUs7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLFNBQVMsWUFBWSxHQUFHO0FBQ2pDLFNBQVMsd0JBQXdCO0FBQ2pDLFNBQVMsd0JBQXdCO0FBQ2pDLFNBQVMsd0JBQXdCO0FBQ2pDLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUyxzREFBc0Q7QUFDL0QsU0FBUyw0Q0FBNEM7QUFDckQsU0FBUyw0QkFBNEI7QUFDckMsU0FBUyxzREFBc0Q7QUFDL0QsU0FBUyx3QkFBd0I7QUFDakMsU0FBUyxTQUFTLFlBQVksR0FBRztBQUNqQyxTQUFTLHdCQUF3QjtBQUNqQyxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG1GQUFtRjtBQUNuRix3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTLG1EQUFtRDtBQUM1RCxTQUFTLHdEQUF3RDtBQUNqRSxTQUFTLFNBQVMsWUFBWSw2QkFBNkI7QUFDM0QsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLElBQUksY0FBYyxJQUFJLHFEQUFxRCxJQUFJLHdCQUF3QixJQUFJO0FBQ3BJO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLEVBQUUsS0FBSyxFQUFFO0FBQzlDO0FBQ0E7QUFDQSxvRUFBb0UsRUFBRTtBQUN0RTtBQUNBLHVEQUF1RDtBQUN2RCxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixFQUFFLGdCQUFnQixFQUFFO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSx5QkFBeUI7QUFDdEMsYUFBYSx1QkFBdUI7QUFDcEM7QUFDQTtBQUNBLGFBQWEsZ0NBQWdDO0FBQzdDLGFBQWEsc0JBQXNCO0FBQ25DLGFBQWEsMEJBQTBCO0FBQ3ZDLGFBQWEsc0JBQXNCO0FBQ25DLGFBQWEsb0JBQW9CO0FBQ2pDLGFBQWEscUJBQXFCO0FBQ2xDLGFBQWEseUJBQXlCO0FBQ3RDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLEtBQUs7QUFDbkMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSw4QkFBOEIsS0FBSztBQUNuQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDRDQUE0QztBQUNoRSxhQUFhO0FBQ2I7QUFDQTtBQUNBLG9CQUFvQiw0Q0FBNEM7QUFDaEUsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDBEQUEwRDtBQUMvRSxxQkFBcUIsMERBQTBEO0FBQy9FLG1CQUFtQix5REFBeUQ7QUFDNUUsbUJBQW1CLHlEQUF5RDtBQUM1RTtBQUNBO0FBQ0EscUJBQXFCLDBDQUEwQztBQUMvRCxhQUFhO0FBQ2I7QUFDQTtBQUNBLHFCQUFxQiwwQ0FBMEM7QUFDL0QsYUFBYTtBQUNiO0FBQ0E7QUFDQSxtQkFBbUIsMENBQTBDO0FBQzdELGFBQWE7QUFDYjtBQUNBO0FBQ0EsbUJBQW1CLDBDQUEwQztBQUM3RCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsK0RBQStEO0FBQ25GLG9CQUFvQiwrREFBK0Q7QUFDbkY7QUFDQTtBQUNBLG1CQUFtQiw0Q0FBNEM7QUFDL0QsYUFBYTtBQUNiO0FBQ0E7QUFDQSxtQkFBbUIsNENBQTRDO0FBQy9ELGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFFBQVE7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qyw2Q0FBNkM7QUFDekYsNENBQTRDLCtDQUErQztBQUMzRjtBQUNBO0FBQ0EsMkJBQTJCLElBQUksbURBQW1ELEVBQUUsR0FBRztBQUN2RiwrQkFBK0Isd0RBQXdEO0FBQ3ZGLCtCQUErQix3REFBd0Q7QUFDdkYsK0JBQStCLHdEQUF3RDtBQUN2RjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQywwQ0FBMEM7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQywwQ0FBMEM7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDBDQUEwQztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDBDQUEwQztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyx5Q0FBeUM7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyx5Q0FBeUM7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixxREFBcUQ7QUFDMUUsYUFBYTtBQUNiO0FBQ0E7QUFDQSxtQkFBbUIscURBQXFEO0FBQ3hFLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixFQUFFO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGFBQWEsNEJBQTRCO0FBQ3pDLGFBQWEseUJBQXlCO0FBQ3RDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhLDRCQUE0QjtBQUN6QyxhQUFhLHlCQUF5QjtBQUN0QyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYSw0QkFBNEI7QUFDekMsYUFBYSx5QkFBeUI7QUFDdEMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDRCQUE0QjtBQUN6QyxhQUFhLHlCQUF5QjtBQUN0QyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixJQUFJLG1FQUFtRTtBQUN2RjtBQUNBO0FBQ0EsZUFBZSxJQUFJLGlEQUFpRDtBQUNwRTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBIiwiZmlsZSI6Ii4uLy4uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9iYXNpYy1sYW5ndWFnZXMvZWxpeGlyL2VsaXhpci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuZXhwb3J0IHZhciBjb25mID0ge1xuICAgIGNvbW1lbnRzOiB7XG4gICAgICAgIGxpbmVDb21tZW50OiAnIydcbiAgICB9LFxuICAgIGJyYWNrZXRzOiBbXG4gICAgICAgIFsneycsICd9J10sXG4gICAgICAgIFsnWycsICddJ10sXG4gICAgICAgIFsnKCcsICcpJ11cbiAgICBdLFxuICAgIHN1cnJvdW5kaW5nUGFpcnM6IFtcbiAgICAgICAgeyBvcGVuOiAneycsIGNsb3NlOiAnfScgfSxcbiAgICAgICAgeyBvcGVuOiAnWycsIGNsb3NlOiAnXScgfSxcbiAgICAgICAgeyBvcGVuOiAnKCcsIGNsb3NlOiAnKScgfSxcbiAgICAgICAgeyBvcGVuOiBcIidcIiwgY2xvc2U6IFwiJ1wiIH0sXG4gICAgICAgIHsgb3BlbjogJ1wiJywgY2xvc2U6ICdcIicgfVxuICAgIF0sXG4gICAgYXV0b0Nsb3NpbmdQYWlyczogW1xuICAgICAgICB7IG9wZW46IFwiJ1wiLCBjbG9zZTogXCInXCIsIG5vdEluOiBbJ3N0cmluZycsICdjb21tZW50J10gfSxcbiAgICAgICAgeyBvcGVuOiAnXCInLCBjbG9zZTogJ1wiJywgbm90SW46IFsnY29tbWVudCddIH0sXG4gICAgICAgIHsgb3BlbjogJ1wiXCJcIicsIGNsb3NlOiAnXCJcIlwiJyB9LFxuICAgICAgICB7IG9wZW46ICdgJywgY2xvc2U6ICdgJywgbm90SW46IFsnc3RyaW5nJywgJ2NvbW1lbnQnXSB9LFxuICAgICAgICB7IG9wZW46ICcoJywgY2xvc2U6ICcpJyB9LFxuICAgICAgICB7IG9wZW46ICd7JywgY2xvc2U6ICd9JyB9LFxuICAgICAgICB7IG9wZW46ICdbJywgY2xvc2U6ICddJyB9LFxuICAgICAgICB7IG9wZW46ICc8PCcsIGNsb3NlOiAnPj4nIH1cbiAgICBdLFxuICAgIGluZGVudGF0aW9uUnVsZXM6IHtcbiAgICAgICAgaW5jcmVhc2VJbmRlbnRQYXR0ZXJuOiAvXlxccyooYWZ0ZXJ8ZWxzZXxjYXRjaHxyZXNjdWV8Zm58W14jXSooZG98PFxcLXxcXC0+fFxce3xcXFt8XFw9KSlcXHMqJC8sXG4gICAgICAgIGRlY3JlYXNlSW5kZW50UGF0dGVybjogL15cXHMqKChcXH18XFxdKVxccyokfChhZnRlcnxlbHNlfGNhdGNofHJlc2N1ZXxlbmQpXFxiKS9cbiAgICB9XG59O1xuLyoqXG4gKiBBIE1vbmFyY2ggbGV4ZXIgZm9yIHRoZSBFbGl4aXIgbGFuZ3VhZ2UuXG4gKlxuICogUmVmZXJlbmNlczpcbiAqXG4gKiAqIE1vbmFyY2ggZG9jdW1lbnRhdGlvbiAtIGh0dHBzOi8vbWljcm9zb2Z0LmdpdGh1Yi5pby9tb25hY28tZWRpdG9yL21vbmFyY2guaHRtbFxuICogKiBFbGl4aXIgbGV4ZXIgLSBodHRwczovL2dpdGh1Yi5jb20vZWxpeGlyLW1ha2V1cC9tYWtldXBfZWxpeGlyL2Jsb2IvbWFzdGVyL2xpYi9tYWtldXAvbGV4ZXJzL2VsaXhpcl9sZXhlci5leFxuICogKiBUZXh0TWF0ZSBsZXhlciAoZWxpeGlyLXRtYnVuZGxlKSAtIGh0dHBzOi8vZ2l0aHViLmNvbS9lbGl4aXItZWRpdG9ycy9lbGl4aXItdG1idW5kbGUvYmxvYi9tYXN0ZXIvU3ludGF4ZXMvRWxpeGlyLnRtTGFuZ3VhZ2VcbiAqICogVGV4dE1hdGUgbGV4ZXIgKHZzY29kZS1lbGl4aXItbHMpIC0gaHR0cHM6Ly9naXRodWIuY29tL2VsaXhpci1sc3AvdnNjb2RlLWVsaXhpci1scy9ibG9iL21hc3Rlci9zeW50YXhlcy9lbGl4aXIuanNvblxuICovXG5leHBvcnQgdmFyIGxhbmd1YWdlID0ge1xuICAgIGRlZmF1bHRUb2tlbjogJ3NvdXJjZScsXG4gICAgdG9rZW5Qb3N0Zml4OiAnLmVsaXhpcicsXG4gICAgYnJhY2tldHM6IFtcbiAgICAgICAgeyBvcGVuOiAnWycsIGNsb3NlOiAnXScsIHRva2VuOiAnZGVsaW1pdGVyLnNxdWFyZScgfSxcbiAgICAgICAgeyBvcGVuOiAnKCcsIGNsb3NlOiAnKScsIHRva2VuOiAnZGVsaW1pdGVyLnBhcmVudGhlc2lzJyB9LFxuICAgICAgICB7IG9wZW46ICd7JywgY2xvc2U6ICd9JywgdG9rZW46ICdkZWxpbWl0ZXIuY3VybHknIH0sXG4gICAgICAgIHsgb3BlbjogJzw8JywgY2xvc2U6ICc+PicsIHRva2VuOiAnZGVsaW1pdGVyLmFuZ2xlLnNwZWNpYWwnIH1cbiAgICBdLFxuICAgIC8vIEJlbG93IGFyZSBsaXN0cy9yZWdleHBzIHRvIHdoaWNoIHdlIHJlZmVyZW5jZSBsYXRlci5cbiAgICBkZWNsYXJhdGlvbktleXdvcmRzOiBbXG4gICAgICAgICdkZWYnLFxuICAgICAgICAnZGVmcCcsXG4gICAgICAgICdkZWZuJyxcbiAgICAgICAgJ2RlZm5wJyxcbiAgICAgICAgJ2RlZmd1YXJkJyxcbiAgICAgICAgJ2RlZmd1YXJkcCcsXG4gICAgICAgICdkZWZtYWNybycsXG4gICAgICAgICdkZWZtYWNyb3AnLFxuICAgICAgICAnZGVmZGVsZWdhdGUnLFxuICAgICAgICAnZGVmY2FsbGJhY2snLFxuICAgICAgICAnZGVmbWFjcm9jYWxsYmFjaycsXG4gICAgICAgICdkZWZtb2R1bGUnLFxuICAgICAgICAnZGVmcHJvdG9jb2wnLFxuICAgICAgICAnZGVmZXhjZXB0aW9uJyxcbiAgICAgICAgJ2RlZmltcGwnLFxuICAgICAgICAnZGVmc3RydWN0J1xuICAgIF0sXG4gICAgb3BlcmF0b3JLZXl3b3JkczogWydhbmQnLCAnaW4nLCAnbm90JywgJ29yJywgJ3doZW4nXSxcbiAgICBuYW1lc3BhY2VLZXl3b3JkczogWydhbGlhcycsICdpbXBvcnQnLCAncmVxdWlyZScsICd1c2UnXSxcbiAgICBvdGhlcktleXdvcmRzOiBbXG4gICAgICAgICdhZnRlcicsXG4gICAgICAgICdjYXNlJyxcbiAgICAgICAgJ2NhdGNoJyxcbiAgICAgICAgJ2NvbmQnLFxuICAgICAgICAnZG8nLFxuICAgICAgICAnZWxzZScsXG4gICAgICAgICdlbmQnLFxuICAgICAgICAnZm4nLFxuICAgICAgICAnZm9yJyxcbiAgICAgICAgJ2lmJyxcbiAgICAgICAgJ3F1b3RlJyxcbiAgICAgICAgJ3JhaXNlJyxcbiAgICAgICAgJ3JlY2VpdmUnLFxuICAgICAgICAncmVzY3VlJyxcbiAgICAgICAgJ3N1cGVyJyxcbiAgICAgICAgJ3Rocm93JyxcbiAgICAgICAgJ3RyeScsXG4gICAgICAgICd1bmxlc3MnLFxuICAgICAgICAndW5xdW90ZV9zcGxpY2luZycsXG4gICAgICAgICd1bnF1b3RlJyxcbiAgICAgICAgJ3dpdGgnXG4gICAgXSxcbiAgICBjb25zdGFudHM6IFsndHJ1ZScsICdmYWxzZScsICduaWwnXSxcbiAgICBuYW1lQnVpbHRpbjogWydfX01PRFVMRV9fJywgJ19fRElSX18nLCAnX19FTlZfXycsICdfX0NBTExFUl9fJywgJ19fU1RBQ0tUUkFDRV9fJ10sXG4gICAgLy8gTWF0Y2hlcyBhbnkgb2YgdGhlIG9wZXJhdG9yIG5hbWVzOlxuICAgIC8vIDw8PCA+Pj4gfHx8ICYmJiBeXl4gfn5+ID09PSAhPT0gfj4+IDx+PiB8fj4gPHw+ID09ICE9IDw9ID49ICYmIHx8IFxcXFwgPD4gKysgLS0gfD4gPX4gLT4gPC0gfj4gPH4gOjogLi4gPSA8ID4gKyAtICogLyB8IC4gXiAmICFcbiAgICBvcGVyYXRvcjogLy1bLT5dP3whPXswLDJ9fFxcKnxcXC98XFxcXFxcXFx8JnsxLDN9fFxcLlxcLj98XFxeKD86XFxeXFxeKT98XFwrXFwrP3w8KD86LXw8PHw9fD58XFx8Pnx+Pj8pP3w9fnw9ezEsM318Pig/Oj18Pj4pP3xcXHx+PnxcXHw+fFxcfHsxLDN9fH4+Pj98fn5+fDo6LyxcbiAgICAvLyBTZWUgaHR0cHM6Ly9oZXhkb2NzLnBtL2VsaXhpci9zeW50YXgtcmVmZXJlbmNlLmh0bWwjdmFyaWFibGVzXG4gICAgdmFyaWFibGVOYW1lOiAvW2Etel9dW2EtekEtWjAtOV9dKls/IV0/LyxcbiAgICAvLyBTZWUgaHR0cHM6Ly9oZXhkb2NzLnBtL2VsaXhpci9zeW50YXgtcmVmZXJlbmNlLmh0bWwjYXRvbXNcbiAgICBhdG9tTmFtZTogL1thLXpBLVpfXVthLXpBLVowLTlfQF0qWz8hXT98QHNwZWNpYWxBdG9tTmFtZXxAb3BlcmF0b3IvLFxuICAgIHNwZWNpYWxBdG9tTmFtZTogL1xcLlxcLlxcLnw8PD4+fCVcXHtcXH18JXxcXHtcXH0vLFxuICAgIGFsaWFzUGFydDogL1tBLVpdW2EtekEtWjAtOV9dKi8sXG4gICAgbW9kdWxlTmFtZTogL0BhbGlhc1BhcnQoPzpcXC5AYWxpYXNQYXJ0KSovLFxuICAgIC8vIFNpZ2lsIHBhaXJzIGFyZTogXCJcIlwiIFwiXCJcIiwgJycnICcnJywgXCIgXCIsICcgJywgLyAvLCB8IHwsIDwgPiwgeyB9LCBbIF0sICggKVxuICAgIHNpZ2lsU3ltbWV0cmljRGVsaW1pdGVyOiAvXCJcIlwifCcnJ3xcInwnfFxcL3xcXHwvLFxuICAgIHNpZ2lsU3RhcnREZWxpbWl0ZXI6IC9Ac2lnaWxTeW1tZXRyaWNEZWxpbWl0ZXJ8PHxcXHt8XFxbfFxcKC8sXG4gICAgc2lnaWxFbmREZWxpbWl0ZXI6IC9Ac2lnaWxTeW1tZXRyaWNEZWxpbWl0ZXJ8PnxcXH18XFxdfFxcKS8sXG4gICAgZGVjaW1hbDogL1xcZCg/Ol8/XFxkKSovLFxuICAgIGhleDogL1swLTlhLWZBLUZdKF8/WzAtOWEtZkEtRl0pKi8sXG4gICAgb2N0YWw6IC9bMC03XShfP1swLTddKSovLFxuICAgIGJpbmFyeTogL1swMV0oXz9bMDFdKSovLFxuICAgIC8vIFNlZSBodHRwczovL2hleGRvY3MucG0vZWxpeGlyL21hc3Rlci9TdHJpbmcuaHRtbCNtb2R1bGUtZXNjYXBlLWNoYXJhY3RlcnNcbiAgICBlc2NhcGU6IC9cXFxcdVswLTlhLWZBLUZdezR9fFxcXFx4WzAtOWEtZkEtRl17Mn18XFxcXC4vLFxuICAgIC8vIFRoZSBrZXlzIGJlbG93IGNvcnJlc3BvbmQgdG8gdG9rZW5pemVyIHN0YXRlcy5cbiAgICAvLyBXZSBzdGFydCBmcm9tIHRoZSByb290IHN0YXRlIGFuZCBtYXRjaCBhZ2FpbnN0IGl0cyBydWxlc1xuICAgIC8vIHVudGlsIHdlIGV4cGxpY2l0bHkgdHJhbnNpdGlvbiBpbnRvIGFub3RoZXIgc3RhdGUuXG4gICAgLy8gVGhlIGBpbmNsdWRlYCBzaW1wbHkgYnJpbmdzIGluIGFsbCBvcGVyYXRpb25zIGZyb20gdGhlIGdpdmVuIHN0YXRlXG4gICAgLy8gYW5kIGlzIHVzZWZ1bCBmb3IgaW1wcm92aW5nIHJlYWRhYmlsaXR5LlxuICAgIHRva2VuaXplcjoge1xuICAgICAgICByb290OiBbXG4gICAgICAgICAgICB7IGluY2x1ZGU6ICdAd2hpdGVzcGFjZScgfSxcbiAgICAgICAgICAgIHsgaW5jbHVkZTogJ0Bjb21tZW50cycgfSxcbiAgICAgICAgICAgIC8vIEtleXdvcmRzIHN0YXJ0IGFzIGVpdGhlciBhbiBpZGVudGlmaWVyIG9yIGEgc3RyaW5nLFxuICAgICAgICAgICAgLy8gYnV0IGVuZCB3aXRoIGEgOiBzbyBpdCdzIGltcG9ydGFudCB0byBtYXRjaCB0aGlzIGZpcnN0LlxuICAgICAgICAgICAgeyBpbmNsdWRlOiAnQGtleXdvcmRzU2hvcnRoYW5kJyB9LFxuICAgICAgICAgICAgeyBpbmNsdWRlOiAnQG51bWJlcnMnIH0sXG4gICAgICAgICAgICB7IGluY2x1ZGU6ICdAaWRlbnRpZmllcnMnIH0sXG4gICAgICAgICAgICB7IGluY2x1ZGU6ICdAc3RyaW5ncycgfSxcbiAgICAgICAgICAgIHsgaW5jbHVkZTogJ0BhdG9tcycgfSxcbiAgICAgICAgICAgIHsgaW5jbHVkZTogJ0BzaWdpbHMnIH0sXG4gICAgICAgICAgICB7IGluY2x1ZGU6ICdAYXR0cmlidXRlcycgfSxcbiAgICAgICAgICAgIHsgaW5jbHVkZTogJ0BzeW1ib2xzJyB9XG4gICAgICAgIF0sXG4gICAgICAgIC8vIFdoaXRlc3BhY2VcbiAgICAgICAgd2hpdGVzcGFjZTogW1svXFxzKy8sICd3aGl0ZSddXSxcbiAgICAgICAgLy8gQ29tbWVudHNcbiAgICAgICAgY29tbWVudHM6IFtbLygjKSguKikvLCBbJ2NvbW1lbnQucHVuY3R1YXRpb24nLCAnY29tbWVudCddXV0sXG4gICAgICAgIC8vIEtleXdvcmQgbGlzdCBzaG9ydGhhbmRcbiAgICAgICAga2V5d29yZHNTaG9ydGhhbmQ6IFtcbiAgICAgICAgICAgIFsvKEBhdG9tTmFtZSkoOikvLCBbJ2NvbnN0YW50JywgJ2NvbnN0YW50LnB1bmN0dWF0aW9uJ11dLFxuICAgICAgICAgICAgLy8gVXNlIHBvc2l0aXZlIGxvb2stYWhlYWQgdG8gZW5zdXJlIHRoZSBzdHJpbmcgaXMgZm9sbG93ZWQgYnkgOlxuICAgICAgICAgICAgLy8gYW5kIHNob3VsZCBiZSBjb25zaWRlcmVkIGEga2V5d29yZC5cbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAvXCIoPz0oW15cIl18I1xcey4qP1xcfXxcXFxcXCIpKlwiOikvLFxuICAgICAgICAgICAgICAgIHsgdG9rZW46ICdjb25zdGFudC5kZWxpbWl0ZXInLCBuZXh0OiAnQGRvdWJsZVF1b3RlZFN0cmluZ0tleXdvcmQnIH1cbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgLycoPz0oW14nXXwjXFx7Lio/XFx9fFxcXFwnKSonOikvLFxuICAgICAgICAgICAgICAgIHsgdG9rZW46ICdjb25zdGFudC5kZWxpbWl0ZXInLCBuZXh0OiAnQHNpbmdsZVF1b3RlZFN0cmluZ0tleXdvcmQnIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgXSxcbiAgICAgICAgZG91YmxlUXVvdGVkU3RyaW5nS2V5d29yZDogW1xuICAgICAgICAgICAgWy9cIjovLCB7IHRva2VuOiAnY29uc3RhbnQuZGVsaW1pdGVyJywgbmV4dDogJ0Bwb3AnIH1dLFxuICAgICAgICAgICAgeyBpbmNsdWRlOiAnQHN0cmluZ0NvbnN0YW50Q29udGVudEludGVycG9sJyB9XG4gICAgICAgIF0sXG4gICAgICAgIHNpbmdsZVF1b3RlZFN0cmluZ0tleXdvcmQ6IFtcbiAgICAgICAgICAgIFsvJzovLCB7IHRva2VuOiAnY29uc3RhbnQuZGVsaW1pdGVyJywgbmV4dDogJ0Bwb3AnIH1dLFxuICAgICAgICAgICAgeyBpbmNsdWRlOiAnQHN0cmluZ0NvbnN0YW50Q29udGVudEludGVycG9sJyB9XG4gICAgICAgIF0sXG4gICAgICAgIC8vIE51bWJlcnNcbiAgICAgICAgbnVtYmVyczogW1xuICAgICAgICAgICAgWy8wYkBiaW5hcnkvLCAnbnVtYmVyLmJpbmFyeSddLFxuICAgICAgICAgICAgWy8wb0BvY3RhbC8sICdudW1iZXIub2N0YWwnXSxcbiAgICAgICAgICAgIFsvMHhAaGV4LywgJ251bWJlci5oZXgnXSxcbiAgICAgICAgICAgIFsvQGRlY2ltYWxcXC5AZGVjaW1hbChbZUVdLT9AZGVjaW1hbCk/LywgJ251bWJlci5mbG9hdCddLFxuICAgICAgICAgICAgWy9AZGVjaW1hbC8sICdudW1iZXInXVxuICAgICAgICBdLFxuICAgICAgICAvLyBJZGVudGlmaWVyc1xuICAgICAgICBpZGVudGlmaWVyczogW1xuICAgICAgICAgICAgLy8gVG9rZW5pemUgaWRlbnRpZmllciBuYW1lIGluIGZ1bmN0aW9uLWxpa2UgZGVmaW5pdGlvbnMuXG4gICAgICAgICAgICAvLyBOb3RlOiBnaXZlbiBgZGVmIGEgKyBiLCBkbzogbmlsYCwgYGFgIGlzIG5vdCBhIGZ1bmN0aW9uIG5hbWUsXG4gICAgICAgICAgICAvLyBzbyB3ZSB1c2UgbmVnYXRpdmUgbG9vay1haGVhZCB0byBlbnN1cmUgdGhlcmUncyBubyBvcGVyYXRvci5cbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAvXFxiKGRlZnA/fGRlZm5wP3xkZWZtYWNyb3A/fGRlZmd1YXJkcD98ZGVmZGVsZWdhdGUpKFxccyspKEB2YXJpYWJsZU5hbWUpKD8hXFxzK0BvcGVyYXRvcikvLFxuICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgJ2tleXdvcmQuZGVjbGFyYXRpb24nLFxuICAgICAgICAgICAgICAgICAgICAnd2hpdGUnLFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVucXVvdGU6ICdrZXl3b3JkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnQGRlZmF1bHQnOiAnZnVuY3Rpb24nXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgLy8gVG9rZW5pemUgZnVuY3Rpb24gY2FsbHNcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAvLyBJbi1zY29wZSBjYWxsIC0gYW4gaWRlbnRpZmllciBmb2xsb3dlZCBieSAoIG9yIC4oXG4gICAgICAgICAgICAgICAgLyhAdmFyaWFibGVOYW1lKSg/PVxccypcXC4/XFxzKlxcKCkvLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRva2VuaXplIGFzIGtleXdvcmQgaW4gY2FzZXMgbGlrZSBgaWYoLi4uLCBkbzogLi4uLCBlbHNlOiAuLi4pYFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0BkZWNsYXJhdGlvbktleXdvcmRzJzogJ2tleXdvcmQuZGVjbGFyYXRpb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0BuYW1lc3BhY2VLZXl3b3Jkcyc6ICdrZXl3b3JkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdAb3RoZXJLZXl3b3Jkcyc6ICdrZXl3b3JkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdAZGVmYXVsdCc6ICdmdW5jdGlvbi5jYWxsJ1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAvLyBSZWZlcmVuY2luZyBmdW5jdGlvbiBpbiBhIG1vZHVsZVxuICAgICAgICAgICAgICAgIC8oQG1vZHVsZU5hbWUpKFxccyopKFxcLikoXFxzKikoQHZhcmlhYmxlTmFtZSkvLFxuICAgICAgICAgICAgICAgIFsndHlwZS5pZGVudGlmaWVyJywgJ3doaXRlJywgJ29wZXJhdG9yJywgJ3doaXRlJywgJ2Z1bmN0aW9uLmNhbGwnXVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAvLyBSZWZlcmVuY2luZyBmdW5jdGlvbiBpbiBhbiBFcmxhbmcgbW9kdWxlXG4gICAgICAgICAgICAgICAgLyg6KShAYXRvbU5hbWUpKFxccyopKFxcLikoXFxzKikoQHZhcmlhYmxlTmFtZSkvLFxuICAgICAgICAgICAgICAgIFsnY29uc3RhbnQucHVuY3R1YXRpb24nLCAnY29uc3RhbnQnLCAnd2hpdGUnLCAnb3BlcmF0b3InLCAnd2hpdGUnLCAnZnVuY3Rpb24uY2FsbCddXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIC8vIFBpcGluZyBpbnRvIGEgZnVuY3Rpb24gKHRva2VuaXplZCBzZXBhcmF0ZWx5IGFzIGl0IG1heSBub3QgaGF2ZSBwYXJlbnRoZXNlcylcbiAgICAgICAgICAgICAgICAvKFxcfD4pKFxccyopKEB2YXJpYWJsZU5hbWUpLyxcbiAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgICdvcGVyYXRvcicsXG4gICAgICAgICAgICAgICAgICAgICd3aGl0ZScsXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2VzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0BvdGhlcktleXdvcmRzJzogJ2tleXdvcmQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdAZGVmYXVsdCc6ICdmdW5jdGlvbi5jYWxsJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAvLyBGdW5jdGlvbiByZWZlcmVuY2UgcGFzc2VkIHRvIGFub3RoZXIgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICAvKCYpKFxccyopKEB2YXJpYWJsZU5hbWUpLyxcbiAgICAgICAgICAgICAgICBbJ29wZXJhdG9yJywgJ3doaXRlJywgJ2Z1bmN0aW9uLmNhbGwnXVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIC8vIExhbmd1YWdlIGtleXdvcmRzLCBidWlsdGlucywgY29uc3RhbnRzIGFuZCB2YXJpYWJsZXNcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAvQHZhcmlhYmxlTmFtZS8sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjYXNlczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ0BkZWNsYXJhdGlvbktleXdvcmRzJzogJ2tleXdvcmQuZGVjbGFyYXRpb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0BvcGVyYXRvcktleXdvcmRzJzogJ2tleXdvcmQub3BlcmF0b3InLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0BuYW1lc3BhY2VLZXl3b3Jkcyc6ICdrZXl3b3JkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdAb3RoZXJLZXl3b3Jkcyc6ICdrZXl3b3JkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdAY29uc3RhbnRzJzogJ2NvbnN0YW50Lmxhbmd1YWdlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdAbmFtZUJ1aWx0aW4nOiAndmFyaWFibGUubGFuZ3VhZ2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ18uKic6ICdjb21tZW50LnVudXNlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnQGRlZmF1bHQnOiAnaWRlbnRpZmllcidcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAvLyBNb2R1bGUgbmFtZXNcbiAgICAgICAgICAgIFsvQG1vZHVsZU5hbWUvLCAndHlwZS5pZGVudGlmaWVyJ11cbiAgICAgICAgXSxcbiAgICAgICAgLy8gU3RyaW5nc1xuICAgICAgICBzdHJpbmdzOiBbXG4gICAgICAgICAgICBbL1wiXCJcIi8sIHsgdG9rZW46ICdzdHJpbmcuZGVsaW1pdGVyJywgbmV4dDogJ0Bkb3VibGVRdW90ZWRIZXJlZG9jJyB9XSxcbiAgICAgICAgICAgIFsvJycnLywgeyB0b2tlbjogJ3N0cmluZy5kZWxpbWl0ZXInLCBuZXh0OiAnQHNpbmdsZVF1b3RlZEhlcmVkb2MnIH1dLFxuICAgICAgICAgICAgWy9cIi8sIHsgdG9rZW46ICdzdHJpbmcuZGVsaW1pdGVyJywgbmV4dDogJ0Bkb3VibGVRdW90ZWRTdHJpbmcnIH1dLFxuICAgICAgICAgICAgWy8nLywgeyB0b2tlbjogJ3N0cmluZy5kZWxpbWl0ZXInLCBuZXh0OiAnQHNpbmdsZVF1b3RlZFN0cmluZycgfV1cbiAgICAgICAgXSxcbiAgICAgICAgZG91YmxlUXVvdGVkSGVyZWRvYzogW1xuICAgICAgICAgICAgWy9cIlwiXCIvLCB7IHRva2VuOiAnc3RyaW5nLmRlbGltaXRlcicsIG5leHQ6ICdAcG9wJyB9XSxcbiAgICAgICAgICAgIHsgaW5jbHVkZTogJ0BzdHJpbmdDb250ZW50SW50ZXJwb2wnIH1cbiAgICAgICAgXSxcbiAgICAgICAgc2luZ2xlUXVvdGVkSGVyZWRvYzogW1xuICAgICAgICAgICAgWy8nJycvLCB7IHRva2VuOiAnc3RyaW5nLmRlbGltaXRlcicsIG5leHQ6ICdAcG9wJyB9XSxcbiAgICAgICAgICAgIHsgaW5jbHVkZTogJ0BzdHJpbmdDb250ZW50SW50ZXJwb2wnIH1cbiAgICAgICAgXSxcbiAgICAgICAgZG91YmxlUXVvdGVkU3RyaW5nOiBbXG4gICAgICAgICAgICBbL1wiLywgeyB0b2tlbjogJ3N0cmluZy5kZWxpbWl0ZXInLCBuZXh0OiAnQHBvcCcgfV0sXG4gICAgICAgICAgICB7IGluY2x1ZGU6ICdAc3RyaW5nQ29udGVudEludGVycG9sJyB9XG4gICAgICAgIF0sXG4gICAgICAgIHNpbmdsZVF1b3RlZFN0cmluZzogW1xuICAgICAgICAgICAgWy8nLywgeyB0b2tlbjogJ3N0cmluZy5kZWxpbWl0ZXInLCBuZXh0OiAnQHBvcCcgfV0sXG4gICAgICAgICAgICB7IGluY2x1ZGU6ICdAc3RyaW5nQ29udGVudEludGVycG9sJyB9XG4gICAgICAgIF0sXG4gICAgICAgIC8vIEF0b21zXG4gICAgICAgIGF0b21zOiBbXG4gICAgICAgICAgICBbLyg6KShAYXRvbU5hbWUpLywgWydjb25zdGFudC5wdW5jdHVhdGlvbicsICdjb25zdGFudCddXSxcbiAgICAgICAgICAgIFsvOlwiLywgeyB0b2tlbjogJ2NvbnN0YW50LmRlbGltaXRlcicsIG5leHQ6ICdAZG91YmxlUXVvdGVkU3RyaW5nQXRvbScgfV0sXG4gICAgICAgICAgICBbLzonLywgeyB0b2tlbjogJ2NvbnN0YW50LmRlbGltaXRlcicsIG5leHQ6ICdAc2luZ2xlUXVvdGVkU3RyaW5nQXRvbScgfV1cbiAgICAgICAgXSxcbiAgICAgICAgZG91YmxlUXVvdGVkU3RyaW5nQXRvbTogW1xuICAgICAgICAgICAgWy9cIi8sIHsgdG9rZW46ICdjb25zdGFudC5kZWxpbWl0ZXInLCBuZXh0OiAnQHBvcCcgfV0sXG4gICAgICAgICAgICB7IGluY2x1ZGU6ICdAc3RyaW5nQ29uc3RhbnRDb250ZW50SW50ZXJwb2wnIH1cbiAgICAgICAgXSxcbiAgICAgICAgc2luZ2xlUXVvdGVkU3RyaW5nQXRvbTogW1xuICAgICAgICAgICAgWy8nLywgeyB0b2tlbjogJ2NvbnN0YW50LmRlbGltaXRlcicsIG5leHQ6ICdAcG9wJyB9XSxcbiAgICAgICAgICAgIHsgaW5jbHVkZTogJ0BzdHJpbmdDb25zdGFudENvbnRlbnRJbnRlcnBvbCcgfVxuICAgICAgICBdLFxuICAgICAgICAvLyBTaWdpbHNcbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZWxpeGlyLWxhbmcub3JnL2dldHRpbmctc3RhcnRlZC9zaWdpbHMuaHRtbFxuICAgICAgICAvLyBTaWdpbHMgYWxsb3cgZm9yIHR5cGluZyB2YWx1ZXMgdXNpbmcgdGhlaXIgdGV4dHVhbCByZXByZXNlbnRhdGlvbi5cbiAgICAgICAgLy8gQWxsIHNpZ2lscyBzdGFydCB3aXRoIH4gZm9sbG93ZWQgYnkgYSBsZXR0ZXIgaW5kaWNhdGluZyBzaWdpbCB0eXBlXG4gICAgICAgIC8vIGFuZCB0aGVuIGEgZGVsaW1pdGVyIHBhaXIgZW5jbG9zaW5nIHRoZSB0ZXh0dWFsIHJlcHJlc2VudGF0aW9uLlxuICAgICAgICAvLyBPcHRpb25hbCBtb2RpZmllcnMgYXJlIGFsbG93ZWQgYWZ0ZXIgdGhlIGNsb3NpbmcgZGVsaW1pdGVyLlxuICAgICAgICAvLyBGb3IgaW5zdGFuY2UgYSByZWd1bGFyIGV4cHJlc3Npb25zIGNhbiBiZSB3cml0dGVuIGFzOlxuICAgICAgICAvLyB+ci9mb298YmFyLyB+cntmb298YmFyfSB+ci9mb298YmFyL2dcbiAgICAgICAgLy9cbiAgICAgICAgLy8gSW4gZ2VuZXJhbCBsb3dlcmNhc2Ugc2lnaWxzIGFsbG93IGZvciBpbnRlcnBvbGF0aW9uXG4gICAgICAgIC8vIGFuZCBlc2NhcGVkIGNoYXJhY3RlcnMsIHdoZXJlYXMgdXBwZXJjYXNlIHNpZ2lscyBkb24ndFxuICAgICAgICAvL1xuICAgICAgICAvLyBEdXJpbmcgdG9rZW5pemF0aW9uIHdlIHdhbnQgdG8gZGlzdGluZ3Vpc2ggc29tZVxuICAgICAgICAvLyBzcGVjaWZpYyBzaWdpbCB0eXBlcywgbmFtZWx5IHN0cmluZyBhbmQgcmVnZXhwLFxuICAgICAgICAvLyBzbyB0aGF0IHRoZXkgY2VuIGJlIHRoZW1lZCBzZXBhcmF0ZWx5LlxuICAgICAgICAvL1xuICAgICAgICAvLyBUbyByZWFzb25hYmx5IGhhbmRsZSBhbGwgdGhvc2UgY29tYmluYXRpb25zIHdlIGxldmVyYWdlXG4gICAgICAgIC8vIGRvdC1zZXBhcmF0ZWQgc3RhdGVzLCBzbyBpZiB3ZSB0cmFuc2l0aW9uIHRvIEBzaWdpbFN0YXJ0LmludGVycG9sLnMuey59XG4gICAgICAgIC8vIHRoZW4gXCJzaWdpbFN0YXJ0LmludGVycG9sLnNcIiBzdGF0ZSB3aWxsIG1hdGNoIGFuZCBhbHNvIGFsbFxuICAgICAgICAvLyB0aGUgaW5kaXZpZHVhbCBkb3Qtc2VwYXJhdGVkIHBhcmFtZXRlcnMgY2FuIGJlIGFjY2Vzc2VkLlxuICAgICAgICBzaWdpbHM6IFtcbiAgICAgICAgICAgIFsvflthLXpdQHNpZ2lsU3RhcnREZWxpbWl0ZXIvLCB7IHRva2VuOiAnQHJlbWF0Y2gnLCBuZXh0OiAnQHNpZ2lsLmludGVycG9sJyB9XSxcbiAgICAgICAgICAgIFsvfltBLVpdQHNpZ2lsU3RhcnREZWxpbWl0ZXIvLCB7IHRva2VuOiAnQHJlbWF0Y2gnLCBuZXh0OiAnQHNpZ2lsLm5vSW50ZXJwb2wnIH1dXG4gICAgICAgIF0sXG4gICAgICAgIHNpZ2lsOiBbXG4gICAgICAgICAgICBbL34oW2EtekEtWl0pXFx7LywgeyB0b2tlbjogJ0ByZW1hdGNoJywgc3dpdGNoVG86ICdAc2lnaWxTdGFydC4kUzIuJDEuey59JyB9XSxcbiAgICAgICAgICAgIFsvfihbYS16QS1aXSlcXFsvLCB7IHRva2VuOiAnQHJlbWF0Y2gnLCBzd2l0Y2hUbzogJ0BzaWdpbFN0YXJ0LiRTMi4kMS5bLl0nIH1dLFxuICAgICAgICAgICAgWy9+KFthLXpBLVpdKVxcKC8sIHsgdG9rZW46ICdAcmVtYXRjaCcsIHN3aXRjaFRvOiAnQHNpZ2lsU3RhcnQuJFMyLiQxLiguKScgfV0sXG4gICAgICAgICAgICBbL34oW2EtekEtWl0pXFw8LywgeyB0b2tlbjogJ0ByZW1hdGNoJywgc3dpdGNoVG86ICdAc2lnaWxTdGFydC4kUzIuJDEuPC4+JyB9XSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAvfihbYS16QS1aXSkoQHNpZ2lsU3ltbWV0cmljRGVsaW1pdGVyKS8sXG4gICAgICAgICAgICAgICAgeyB0b2tlbjogJ0ByZW1hdGNoJywgc3dpdGNoVG86ICdAc2lnaWxTdGFydC4kUzIuJDEuJDIuJDInIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgXSxcbiAgICAgICAgLy8gVGhlIGRlZmluaXRpb25zIGJlbG93IGV4cGVjdCBzdGF0ZXMgdG8gYmUgb2YgdGhlIGZvcm06XG4gICAgICAgIC8vXG4gICAgICAgIC8vIHNpZ2lsU3RhcnQuPGludGVycG9sLW9yLW5vSW50ZXJwb2w+LjxzaWdpbC1sZXR0ZXI+LjxzdGFydC1kZWxpbWl0ZXI+LjxlbmQtZGVsaW1pdGVyPlxuICAgICAgICAvLyBzaWdpbENvbnRpbnVlLjxpbnRlcnBvbC1vci1ub0ludGVycG9sPi48c2lnaWwtbGV0dGVyPi48c3RhcnQtZGVsaW1pdGVyPi48ZW5kLWRlbGltaXRlcj5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gVGhlIHNpZ2lsU3RhcnQgc3RhdGUgaXMgdXNlZCBvbmx5IHRvIHByb3Blcmx5IGNsYXNzaWZ5IHRoZSB0b2tlbiAoYXMgc3RyaW5nL3JlZ2V4L3NpZ2lsKVxuICAgICAgICAvLyBhbmQgaW1tZWRpYXRlbHkgc3dpdGNoZXMgdG8gdGhlIHNpZ2lsQ29udGludWUgc2F0ZSwgd2hpY2ggaGFuZGxlcyB0aGUgYWN0dWFsIGNvbnRlbnRcbiAgICAgICAgLy8gYW5kIHdhaXRzIGZvciB0aGUgY29ycmVzcG9uZGluZyBlbmQgZGVsaW1pdGVyLlxuICAgICAgICAnc2lnaWxTdGFydC5pbnRlcnBvbC5zJzogW1xuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIC9+c0BzaWdpbFN0YXJ0RGVsaW1pdGVyLyxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuOiAnc3RyaW5nLmRlbGltaXRlcicsXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaFRvOiAnQHNpZ2lsQ29udGludWUuJFMyLiRTMy4kUzQuJFM1J1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgXSxcbiAgICAgICAgJ3NpZ2lsQ29udGludWUuaW50ZXJwb2wucyc6IFtcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAvKEBzaWdpbEVuZERlbGltaXRlcilbYS16QS1aXSovLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICckMT09JFM1JzogeyB0b2tlbjogJ3N0cmluZy5kZWxpbWl0ZXInLCBuZXh0OiAnQHBvcCcgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdAZGVmYXVsdCc6ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgeyBpbmNsdWRlOiAnQHN0cmluZ0NvbnRlbnRJbnRlcnBvbCcgfVxuICAgICAgICBdLFxuICAgICAgICAnc2lnaWxTdGFydC5ub0ludGVycG9sLlMnOiBbXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgL35TQHNpZ2lsU3RhcnREZWxpbWl0ZXIvLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW46ICdzdHJpbmcuZGVsaW1pdGVyJyxcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoVG86ICdAc2lnaWxDb250aW51ZS4kUzIuJFMzLiRTNC4kUzUnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICBdLFxuICAgICAgICAnc2lnaWxDb250aW51ZS5ub0ludGVycG9sLlMnOiBbXG4gICAgICAgICAgICAvLyBJZ25vcmUgZXNjYXBlZCBzaWdpbCBlbmRcbiAgICAgICAgICAgIFsvKF58W15cXFxcXSlcXFxcQHNpZ2lsRW5kRGVsaW1pdGVyLywgJ3N0cmluZyddLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIC8oQHNpZ2lsRW5kRGVsaW1pdGVyKVthLXpBLVpdKi8sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjYXNlczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJyQxPT0kUzUnOiB7IHRva2VuOiAnc3RyaW5nLmRlbGltaXRlcicsIG5leHQ6ICdAcG9wJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0BkZWZhdWx0JzogJ3N0cmluZydcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB7IGluY2x1ZGU6ICdAc3RyaW5nQ29udGVudCcgfVxuICAgICAgICBdLFxuICAgICAgICAnc2lnaWxTdGFydC5pbnRlcnBvbC5yJzogW1xuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIC9+ckBzaWdpbFN0YXJ0RGVsaW1pdGVyLyxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuOiAncmVnZXhwLmRlbGltaXRlcicsXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaFRvOiAnQHNpZ2lsQ29udGludWUuJFMyLiRTMy4kUzQuJFM1J1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgXSxcbiAgICAgICAgJ3NpZ2lsQ29udGludWUuaW50ZXJwb2wucic6IFtcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAvKEBzaWdpbEVuZERlbGltaXRlcilbYS16QS1aXSovLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICckMT09JFM1JzogeyB0b2tlbjogJ3JlZ2V4cC5kZWxpbWl0ZXInLCBuZXh0OiAnQHBvcCcgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdAZGVmYXVsdCc6ICdyZWdleHAnXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgeyBpbmNsdWRlOiAnQHJlZ2V4cENvbnRlbnRJbnRlcnBvbCcgfVxuICAgICAgICBdLFxuICAgICAgICAnc2lnaWxTdGFydC5ub0ludGVycG9sLlInOiBbXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgL35SQHNpZ2lsU3RhcnREZWxpbWl0ZXIvLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW46ICdyZWdleHAuZGVsaW1pdGVyJyxcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoVG86ICdAc2lnaWxDb250aW51ZS4kUzIuJFMzLiRTNC4kUzUnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICBdLFxuICAgICAgICAnc2lnaWxDb250aW51ZS5ub0ludGVycG9sLlInOiBbXG4gICAgICAgICAgICAvLyBJZ25vcmUgZXNjYXBlZCBzaWdpbCBlbmRcbiAgICAgICAgICAgIFsvKF58W15cXFxcXSlcXFxcQHNpZ2lsRW5kRGVsaW1pdGVyLywgJ3JlZ2V4cCddLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIC8oQHNpZ2lsRW5kRGVsaW1pdGVyKVthLXpBLVpdKi8sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjYXNlczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJyQxPT0kUzUnOiB7IHRva2VuOiAncmVnZXhwLmRlbGltaXRlcicsIG5leHQ6ICdAcG9wJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0BkZWZhdWx0JzogJ3JlZ2V4cCdcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB7IGluY2x1ZGU6ICdAcmVnZXhwQ29udGVudCcgfVxuICAgICAgICBdLFxuICAgICAgICAvLyBGYWxsYmFjayB0byB0aGUgZ2VuZXJpYyBzaWdpbCBieSBkZWZhdWx0XG4gICAgICAgICdzaWdpbFN0YXJ0LmludGVycG9sJzogW1xuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIC9+KFthLXpBLVpdKUBzaWdpbFN0YXJ0RGVsaW1pdGVyLyxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuOiAnc2lnaWwuZGVsaW1pdGVyJyxcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoVG86ICdAc2lnaWxDb250aW51ZS4kUzIuJFMzLiRTNC4kUzUnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICBdLFxuICAgICAgICAnc2lnaWxDb250aW51ZS5pbnRlcnBvbCc6IFtcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAvKEBzaWdpbEVuZERlbGltaXRlcilbYS16QS1aXSovLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICckMT09JFM1JzogeyB0b2tlbjogJ3NpZ2lsLmRlbGltaXRlcicsIG5leHQ6ICdAcG9wJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0BkZWZhdWx0JzogJ3NpZ2lsJ1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIHsgaW5jbHVkZTogJ0BzaWdpbENvbnRlbnRJbnRlcnBvbCcgfVxuICAgICAgICBdLFxuICAgICAgICAnc2lnaWxTdGFydC5ub0ludGVycG9sJzogW1xuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIC9+KFthLXpBLVpdKUBzaWdpbFN0YXJ0RGVsaW1pdGVyLyxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuOiAnc2lnaWwuZGVsaW1pdGVyJyxcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoVG86ICdAc2lnaWxDb250aW51ZS4kUzIuJFMzLiRTNC4kUzUnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICBdLFxuICAgICAgICAnc2lnaWxDb250aW51ZS5ub0ludGVycG9sJzogW1xuICAgICAgICAgICAgLy8gSWdub3JlIGVzY2FwZWQgc2lnaWwgZW5kXG4gICAgICAgICAgICBbLyhefFteXFxcXF0pXFxcXEBzaWdpbEVuZERlbGltaXRlci8sICdzaWdpbCddLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIC8oQHNpZ2lsRW5kRGVsaW1pdGVyKVthLXpBLVpdKi8sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjYXNlczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJyQxPT0kUzUnOiB7IHRva2VuOiAnc2lnaWwuZGVsaW1pdGVyJywgbmV4dDogJ0Bwb3AnIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAnQGRlZmF1bHQnOiAnc2lnaWwnXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgeyBpbmNsdWRlOiAnQHNpZ2lsQ29udGVudCcgfVxuICAgICAgICBdLFxuICAgICAgICAvLyBBdHRyaWJ1dGVzXG4gICAgICAgIGF0dHJpYnV0ZXM6IFtcbiAgICAgICAgICAgIC8vIE1vZHVsZSBAZG9jKiBhdHRyaWJ1dGVzIC0gdG9rZW5pemVkIGFzIGNvbW1lbnRzXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgL1xcQChtb2R1bGV8dHlwZSk/ZG9jICh+W3NTXSk/XCJcIlwiLyxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuOiAnY29tbWVudC5ibG9jay5kb2N1bWVudGF0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgbmV4dDogJ0Bkb3VibGVRdW90ZWRIZXJlZG9jRG9jc3RyaW5nJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgL1xcQChtb2R1bGV8dHlwZSk/ZG9jICh+W3NTXSk/XCIvLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW46ICdjb21tZW50LmJsb2NrLmRvY3VtZW50YXRpb24nLFxuICAgICAgICAgICAgICAgICAgICBuZXh0OiAnQGRvdWJsZVF1b3RlZFN0cmluZ0RvY3N0cmluZydcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgWy9cXEAobW9kdWxlfHR5cGUpP2RvYyBmYWxzZS8sICdjb21tZW50LmJsb2NrLmRvY3VtZW50YXRpb24nXSxcbiAgICAgICAgICAgIC8vIE1vZHVsZSBhdHRyaWJ1dGVzXG4gICAgICAgICAgICBbL1xcQChAdmFyaWFibGVOYW1lKS8sICd2YXJpYWJsZSddXG4gICAgICAgIF0sXG4gICAgICAgIGRvdWJsZVF1b3RlZEhlcmVkb2NEb2NzdHJpbmc6IFtcbiAgICAgICAgICAgIFsvXCJcIlwiLywgeyB0b2tlbjogJ2NvbW1lbnQuYmxvY2suZG9jdW1lbnRhdGlvbicsIG5leHQ6ICdAcG9wJyB9XSxcbiAgICAgICAgICAgIHsgaW5jbHVkZTogJ0Bkb2NzdHJpbmdDb250ZW50JyB9XG4gICAgICAgIF0sXG4gICAgICAgIGRvdWJsZVF1b3RlZFN0cmluZ0RvY3N0cmluZzogW1xuICAgICAgICAgICAgWy9cIi8sIHsgdG9rZW46ICdjb21tZW50LmJsb2NrLmRvY3VtZW50YXRpb24nLCBuZXh0OiAnQHBvcCcgfV0sXG4gICAgICAgICAgICB7IGluY2x1ZGU6ICdAZG9jc3RyaW5nQ29udGVudCcgfVxuICAgICAgICBdLFxuICAgICAgICAvLyBPcGVyYXRvcnMsIHB1bmN0dWF0aW9uLCBicmFja2V0c1xuICAgICAgICBzeW1ib2xzOiBbXG4gICAgICAgICAgICAvLyBDb2RlIHBvaW50IG9wZXJhdG9yIChlaXRoZXIgd2l0aCByZWd1bGFyIGNoYXJhY3RlciA/YSBvciBhbiBlc2NhcGVkIG9uZSA/XFxuKVxuICAgICAgICAgICAgWy9cXD8oXFxcXC58W15cXFxcXFxzXSkvLCAnbnVtYmVyLmNvbnN0YW50J10sXG4gICAgICAgICAgICAvLyBBbm9ueW1vdXMgZnVuY3Rpb24gYXJndW1lbnRzXG4gICAgICAgICAgICBbLyZcXGQrLywgJ29wZXJhdG9yJ10sXG4gICAgICAgICAgICAvLyBCaXRzaGlmdCBvcGVyYXRvcnMgKG11c3QgZ28gYmVmb3JlIGRlbGltaXRlcnMsIHNvIHRoYXQgPDwgPj4gZG9uJ3QgbWF0Y2ggZmlyc3QpXG4gICAgICAgICAgICBbLzw8PHw+Pj4vLCAnb3BlcmF0b3InXSxcbiAgICAgICAgICAgIC8vIERlbGltaXRlciBwYWlyc1xuICAgICAgICAgICAgWy9bKClcXFtcXF1cXHtcXH1dfDw8fD4+LywgJ0BicmFja2V0cyddLFxuICAgICAgICAgICAgLy8gVHJpcGxlIGRvdCBpcyBhIHZhbGlkIG5hbWUgKG11c3QgZ28gYmVmb3JlIG9wZXJhdG9ycywgc28gdGhhdCAuLiBkb2Vzbid0IG1hdGNoIGluc3RlYWQpXG4gICAgICAgICAgICBbL1xcLlxcLlxcLi8sICdpZGVudGlmaWVyJ10sXG4gICAgICAgICAgICAvLyBQdW5jdHVhdGlvbiA9PiAobXVzdCBnbyBiZWZvcmUgb3BlcmF0b3JzLCBzbyBpdCdzIG5vdCB0b2tlbml6ZWQgYXMgPSB0aGVuID4pXG4gICAgICAgICAgICBbLz0+LywgJ3B1bmN0dWF0aW9uJ10sXG4gICAgICAgICAgICAvLyBPcGVyYXRvcnNcbiAgICAgICAgICAgIFsvQG9wZXJhdG9yLywgJ29wZXJhdG9yJ10sXG4gICAgICAgICAgICAvLyBQdW5jdHVhdGlvblxuICAgICAgICAgICAgWy9bOjssLiVdLywgJ3B1bmN0dWF0aW9uJ11cbiAgICAgICAgXSxcbiAgICAgICAgLy8gR2VuZXJpYyBoZWxwZXJzXG4gICAgICAgIHN0cmluZ0NvbnRlbnRJbnRlcnBvbDogW1xuICAgICAgICAgICAgeyBpbmNsdWRlOiAnQGludGVycG9sYXRpb24nIH0sXG4gICAgICAgICAgICB7IGluY2x1ZGU6ICdAZXNjYXBlQ2hhcicgfSxcbiAgICAgICAgICAgIHsgaW5jbHVkZTogJ0BzdHJpbmdDb250ZW50JyB9XG4gICAgICAgIF0sXG4gICAgICAgIHN0cmluZ0NvbnRlbnQ6IFtbLy4vLCAnc3RyaW5nJ11dLFxuICAgICAgICBzdHJpbmdDb25zdGFudENvbnRlbnRJbnRlcnBvbDogW1xuICAgICAgICAgICAgeyBpbmNsdWRlOiAnQGludGVycG9sYXRpb24nIH0sXG4gICAgICAgICAgICB7IGluY2x1ZGU6ICdAZXNjYXBlQ2hhcicgfSxcbiAgICAgICAgICAgIHsgaW5jbHVkZTogJ0BzdHJpbmdDb25zdGFudENvbnRlbnQnIH1cbiAgICAgICAgXSxcbiAgICAgICAgc3RyaW5nQ29uc3RhbnRDb250ZW50OiBbWy8uLywgJ2NvbnN0YW50J11dLFxuICAgICAgICByZWdleHBDb250ZW50SW50ZXJwb2w6IFtcbiAgICAgICAgICAgIHsgaW5jbHVkZTogJ0BpbnRlcnBvbGF0aW9uJyB9LFxuICAgICAgICAgICAgeyBpbmNsdWRlOiAnQGVzY2FwZUNoYXInIH0sXG4gICAgICAgICAgICB7IGluY2x1ZGU6ICdAcmVnZXhwQ29udGVudCcgfVxuICAgICAgICBdLFxuICAgICAgICByZWdleHBDb250ZW50OiBbXG4gICAgICAgICAgICAvLyAjIG1heSBiZSBhIHJlZ3VsYXIgcmVnZXhwIGNoYXIsIHNvIHdlIHVzZSBhIGhldXJpc3RpY1xuICAgICAgICAgICAgLy8gYXNzdW1pbmcgYSAjIHN1cnJvdW5kZWQgYnkgd2hpdGVzcGFjZSBpcyBhY3R1YWxseSBhIGNvbW1lbnQuXG4gICAgICAgICAgICBbLyhcXHMpKCMpKFxccy4qKSQvLCBbJ3doaXRlJywgJ2NvbW1lbnQucHVuY3R1YXRpb24nLCAnY29tbWVudCddXSxcbiAgICAgICAgICAgIFsvLi8sICdyZWdleHAnXVxuICAgICAgICBdLFxuICAgICAgICBzaWdpbENvbnRlbnRJbnRlcnBvbDogW1xuICAgICAgICAgICAgeyBpbmNsdWRlOiAnQGludGVycG9sYXRpb24nIH0sXG4gICAgICAgICAgICB7IGluY2x1ZGU6ICdAZXNjYXBlQ2hhcicgfSxcbiAgICAgICAgICAgIHsgaW5jbHVkZTogJ0BzaWdpbENvbnRlbnQnIH1cbiAgICAgICAgXSxcbiAgICAgICAgc2lnaWxDb250ZW50OiBbWy8uLywgJ3NpZ2lsJ11dLFxuICAgICAgICBkb2NzdHJpbmdDb250ZW50OiBbWy8uLywgJ2NvbW1lbnQuYmxvY2suZG9jdW1lbnRhdGlvbiddXSxcbiAgICAgICAgZXNjYXBlQ2hhcjogW1svQGVzY2FwZS8sICdjb25zdGFudC5jaGFyYWN0ZXIuZXNjYXBlJ11dLFxuICAgICAgICBpbnRlcnBvbGF0aW9uOiBbXG4gICAgICAgICAgICBbLyN7LywgeyB0b2tlbjogJ2RlbGltaXRlci5icmFja2V0LmVtYmVkJywgbmV4dDogJ0BpbnRlcnBvbGF0aW9uQ29udGludWUnIH1dXG4gICAgICAgIF0sXG4gICAgICAgIGludGVycG9sYXRpb25Db250aW51ZTogW1xuICAgICAgICAgICAgWy99LywgeyB0b2tlbjogJ2RlbGltaXRlci5icmFja2V0LmVtYmVkJywgbmV4dDogJ0Bwb3AnIH1dLFxuICAgICAgICAgICAgLy8gSW50ZXJwb2xhdGlvbiBicmFja2V0cyBtYXkgY29udGFpbiBhcmJpdHJhcnkgY29kZSxcbiAgICAgICAgICAgIC8vIHNvIHdlIHNpbXBseSBtYXRjaCBhZ2FpbnN0IGFsbCB0aGUgcm9vdCBydWxlcyxcbiAgICAgICAgICAgIC8vIHVudGlsIHdlIHJlYWNoIGludGVycG9sYXRpb24gZW5kICh0aGUgYWJvdmUgbWF0Y2hlcykuXG4gICAgICAgICAgICB7IGluY2x1ZGU6ICdAcm9vdCcgfVxuICAgICAgICBdXG4gICAgfVxufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/monaco-editor/esm/vs/basic-languages/elixir/elixir.js\n");

/***/ })

}]);