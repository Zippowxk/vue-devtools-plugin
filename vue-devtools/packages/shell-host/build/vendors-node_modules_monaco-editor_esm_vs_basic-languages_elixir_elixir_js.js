/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_vue_devtools_shell_host"] = self["webpackChunk_vue_devtools_shell_host"] || []).push([["vendors-node_modules_monaco-editor_esm_vs_basic-languages_elixir_elixir_js"],{

/***/ "../../node_modules/monaco-editor/esm/vs/basic-languages/elixir/elixir.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/monaco-editor/esm/vs/basic-languages/elixir/elixir.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"conf\": () => (/* binding */ conf),\n/* harmony export */   \"language\": () => (/* binding */ language)\n/* harmony export */ });\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar conf = {\n    comments: {\n        lineComment: '#'\n    },\n    brackets: [\n        ['{', '}'],\n        ['[', ']'],\n        ['(', ')']\n    ],\n    surroundingPairs: [\n        { open: '{', close: '}' },\n        { open: '[', close: ']' },\n        { open: '(', close: ')' },\n        { open: \"'\", close: \"'\" },\n        { open: '\"', close: '\"' }\n    ],\n    autoClosingPairs: [\n        { open: \"'\", close: \"'\", notIn: ['string', 'comment'] },\n        { open: '\"', close: '\"', notIn: ['comment'] },\n        { open: '\"\"\"', close: '\"\"\"' },\n        { open: '`', close: '`', notIn: ['string', 'comment'] },\n        { open: '(', close: ')' },\n        { open: '{', close: '}' },\n        { open: '[', close: ']' },\n        { open: '<<', close: '>>' }\n    ],\n    indentationRules: {\n        increaseIndentPattern: /^\\s*(after|else|catch|rescue|fn|[^#]*(do|<\\-|\\->|\\{|\\[|\\=))\\s*$/,\n        decreaseIndentPattern: /^\\s*((\\}|\\])\\s*$|(after|else|catch|rescue|end)\\b)/\n    }\n};\n/**\n * A Monarch lexer for the Elixir language.\n *\n * References:\n *\n * * Monarch documentation - https://microsoft.github.io/monaco-editor/monarch.html\n * * Elixir lexer - https://github.com/elixir-makeup/makeup_elixir/blob/master/lib/makeup/lexers/elixir_lexer.ex\n * * TextMate lexer (elixir-tmbundle) - https://github.com/elixir-editors/elixir-tmbundle/blob/master/Syntaxes/Elixir.tmLanguage\n * * TextMate lexer (vscode-elixir-ls) - https://github.com/elixir-lsp/vscode-elixir-ls/blob/master/syntaxes/elixir.json\n */\nvar language = {\n    defaultToken: 'source',\n    tokenPostfix: '.elixir',\n    brackets: [\n        { open: '[', close: ']', token: 'delimiter.square' },\n        { open: '(', close: ')', token: 'delimiter.parenthesis' },\n        { open: '{', close: '}', token: 'delimiter.curly' },\n        { open: '<<', close: '>>', token: 'delimiter.angle.special' }\n    ],\n    // Below are lists/regexps to which we reference later.\n    declarationKeywords: [\n        'def',\n        'defp',\n        'defn',\n        'defnp',\n        'defguard',\n        'defguardp',\n        'defmacro',\n        'defmacrop',\n        'defdelegate',\n        'defcallback',\n        'defmacrocallback',\n        'defmodule',\n        'defprotocol',\n        'defexception',\n        'defimpl',\n        'defstruct'\n    ],\n    operatorKeywords: ['and', 'in', 'not', 'or', 'when'],\n    namespaceKeywords: ['alias', 'import', 'require', 'use'],\n    otherKeywords: [\n        'after',\n        'case',\n        'catch',\n        'cond',\n        'do',\n        'else',\n        'end',\n        'fn',\n        'for',\n        'if',\n        'quote',\n        'raise',\n        'receive',\n        'rescue',\n        'super',\n        'throw',\n        'try',\n        'unless',\n        'unquote_splicing',\n        'unquote',\n        'with'\n    ],\n    constants: ['true', 'false', 'nil'],\n    nameBuiltin: ['__MODULE__', '__DIR__', '__ENV__', '__CALLER__', '__STACKTRACE__'],\n    // Matches any of the operator names:\n    // <<< >>> ||| &&& ^^^ ~~~ === !== ~>> <~> |~> <|> == != <= >= && || \\\\ <> ++ -- |> =~ -> <- ~> <~ :: .. = < > + - * / | . ^ & !\n    operator: /-[->]?|!={0,2}|\\*|\\/|\\\\\\\\|&{1,3}|\\.\\.?|\\^(?:\\^\\^)?|\\+\\+?|<(?:-|<<|=|>|\\|>|~>?)?|=~|={1,3}|>(?:=|>>)?|\\|~>|\\|>|\\|{1,3}|~>>?|~~~|::/,\n    // See https://hexdocs.pm/elixir/syntax-reference.html#variables\n    variableName: /[a-z_][a-zA-Z0-9_]*[?!]?/,\n    // See https://hexdocs.pm/elixir/syntax-reference.html#atoms\n    atomName: /[a-zA-Z_][a-zA-Z0-9_@]*[?!]?|@specialAtomName|@operator/,\n    specialAtomName: /\\.\\.\\.|<<>>|%\\{\\}|%|\\{\\}/,\n    aliasPart: /[A-Z][a-zA-Z0-9_]*/,\n    moduleName: /@aliasPart(?:\\.@aliasPart)*/,\n    // Sigil pairs are: \"\"\" \"\"\", ''' ''', \" \", ' ', / /, | |, < >, { }, [ ], ( )\n    sigilSymmetricDelimiter: /\"\"\"|'''|\"|'|\\/|\\|/,\n    sigilStartDelimiter: /@sigilSymmetricDelimiter|<|\\{|\\[|\\(/,\n    sigilEndDelimiter: /@sigilSymmetricDelimiter|>|\\}|\\]|\\)/,\n    decimal: /\\d(?:_?\\d)*/,\n    hex: /[0-9a-fA-F](_?[0-9a-fA-F])*/,\n    octal: /[0-7](_?[0-7])*/,\n    binary: /[01](_?[01])*/,\n    // See https://hexdocs.pm/elixir/master/String.html#module-escape-characters\n    escape: /\\\\u[0-9a-fA-F]{4}|\\\\x[0-9a-fA-F]{2}|\\\\./,\n    // The keys below correspond to tokenizer states.\n    // We start from the root state and match against its rules\n    // until we explicitly transition into another state.\n    // The `include` simply brings in all operations from the given state\n    // and is useful for improving readability.\n    tokenizer: {\n        root: [\n            { include: '@whitespace' },\n            { include: '@comments' },\n            // Keywords start as either an identifier or a string,\n            // but end with a : so it's important to match this first.\n            { include: '@keywordsShorthand' },\n            { include: '@numbers' },\n            { include: '@identifiers' },\n            { include: '@strings' },\n            { include: '@atoms' },\n            { include: '@sigils' },\n            { include: '@attributes' },\n            { include: '@symbols' }\n        ],\n        // Whitespace\n        whitespace: [[/\\s+/, 'white']],\n        // Comments\n        comments: [[/(#)(.*)/, ['comment.punctuation', 'comment']]],\n        // Keyword list shorthand\n        keywordsShorthand: [\n            [/(@atomName)(:)/, ['constant', 'constant.punctuation']],\n            // Use positive look-ahead to ensure the string is followed by :\n            // and should be considered a keyword.\n            [\n                /\"(?=([^\"]|#\\{.*?\\}|\\\\\")*\":)/,\n                { token: 'constant.delimiter', next: '@doubleQuotedStringKeyword' }\n            ],\n            [\n                /'(?=([^']|#\\{.*?\\}|\\\\')*':)/,\n                { token: 'constant.delimiter', next: '@singleQuotedStringKeyword' }\n            ]\n        ],\n        doubleQuotedStringKeyword: [\n            [/\":/, { token: 'constant.delimiter', next: '@pop' }],\n            { include: '@stringConstantContentInterpol' }\n        ],\n        singleQuotedStringKeyword: [\n            [/':/, { token: 'constant.delimiter', next: '@pop' }],\n            { include: '@stringConstantContentInterpol' }\n        ],\n        // Numbers\n        numbers: [\n            [/0b@binary/, 'number.binary'],\n            [/0o@octal/, 'number.octal'],\n            [/0x@hex/, 'number.hex'],\n            [/@decimal\\.@decimal([eE]-?@decimal)?/, 'number.float'],\n            [/@decimal/, 'number']\n        ],\n        // Identifiers\n        identifiers: [\n            // Tokenize identifier name in function-like definitions.\n            // Note: given `def a + b, do: nil`, `a` is not a function name,\n            // so we use negative look-ahead to ensure there's no operator.\n            [\n                /\\b(defp?|defnp?|defmacrop?|defguardp?|defdelegate)(\\s+)(@variableName)(?!\\s+@operator)/,\n                [\n                    'keyword.declaration',\n                    'white',\n                    {\n                        cases: {\n                            unquote: 'keyword',\n                            '@default': 'function'\n                        }\n                    }\n                ]\n            ],\n            // Tokenize function calls\n            [\n                // In-scope call - an identifier followed by ( or .(\n                /(@variableName)(?=\\s*\\.?\\s*\\()/,\n                {\n                    cases: {\n                        // Tokenize as keyword in cases like `if(..., do: ..., else: ...)`\n                        '@declarationKeywords': 'keyword.declaration',\n                        '@namespaceKeywords': 'keyword',\n                        '@otherKeywords': 'keyword',\n                        '@default': 'function.call'\n                    }\n                }\n            ],\n            [\n                // Referencing function in a module\n                /(@moduleName)(\\s*)(\\.)(\\s*)(@variableName)/,\n                ['type.identifier', 'white', 'operator', 'white', 'function.call']\n            ],\n            [\n                // Referencing function in an Erlang module\n                /(:)(@atomName)(\\s*)(\\.)(\\s*)(@variableName)/,\n                ['constant.punctuation', 'constant', 'white', 'operator', 'white', 'function.call']\n            ],\n            [\n                // Piping into a function (tokenized separately as it may not have parentheses)\n                /(\\|>)(\\s*)(@variableName)/,\n                [\n                    'operator',\n                    'white',\n                    {\n                        cases: {\n                            '@otherKeywords': 'keyword',\n                            '@default': 'function.call'\n                        }\n                    }\n                ]\n            ],\n            [\n                // Function reference passed to another function\n                /(&)(\\s*)(@variableName)/,\n                ['operator', 'white', 'function.call']\n            ],\n            // Language keywords, builtins, constants and variables\n            [\n                /@variableName/,\n                {\n                    cases: {\n                        '@declarationKeywords': 'keyword.declaration',\n                        '@operatorKeywords': 'keyword.operator',\n                        '@namespaceKeywords': 'keyword',\n                        '@otherKeywords': 'keyword',\n                        '@constants': 'constant.language',\n                        '@nameBuiltin': 'variable.language',\n                        '_.*': 'comment.unused',\n                        '@default': 'identifier'\n                    }\n                }\n            ],\n            // Module names\n            [/@moduleName/, 'type.identifier']\n        ],\n        // Strings\n        strings: [\n            [/\"\"\"/, { token: 'string.delimiter', next: '@doubleQuotedHeredoc' }],\n            [/'''/, { token: 'string.delimiter', next: '@singleQuotedHeredoc' }],\n            [/\"/, { token: 'string.delimiter', next: '@doubleQuotedString' }],\n            [/'/, { token: 'string.delimiter', next: '@singleQuotedString' }]\n        ],\n        doubleQuotedHeredoc: [\n            [/\"\"\"/, { token: 'string.delimiter', next: '@pop' }],\n            { include: '@stringContentInterpol' }\n        ],\n        singleQuotedHeredoc: [\n            [/'''/, { token: 'string.delimiter', next: '@pop' }],\n            { include: '@stringContentInterpol' }\n        ],\n        doubleQuotedString: [\n            [/\"/, { token: 'string.delimiter', next: '@pop' }],\n            { include: '@stringContentInterpol' }\n        ],\n        singleQuotedString: [\n            [/'/, { token: 'string.delimiter', next: '@pop' }],\n            { include: '@stringContentInterpol' }\n        ],\n        // Atoms\n        atoms: [\n            [/(:)(@atomName)/, ['constant.punctuation', 'constant']],\n            [/:\"/, { token: 'constant.delimiter', next: '@doubleQuotedStringAtom' }],\n            [/:'/, { token: 'constant.delimiter', next: '@singleQuotedStringAtom' }]\n        ],\n        doubleQuotedStringAtom: [\n            [/\"/, { token: 'constant.delimiter', next: '@pop' }],\n            { include: '@stringConstantContentInterpol' }\n        ],\n        singleQuotedStringAtom: [\n            [/'/, { token: 'constant.delimiter', next: '@pop' }],\n            { include: '@stringConstantContentInterpol' }\n        ],\n        // Sigils\n        // See https://elixir-lang.org/getting-started/sigils.html\n        // Sigils allow for typing values using their textual representation.\n        // All sigils start with ~ followed by a letter indicating sigil type\n        // and then a delimiter pair enclosing the textual representation.\n        // Optional modifiers are allowed after the closing delimiter.\n        // For instance a regular expressions can be written as:\n        // ~r/foo|bar/ ~r{foo|bar} ~r/foo|bar/g\n        //\n        // In general lowercase sigils allow for interpolation\n        // and escaped characters, whereas uppercase sigils don't\n        //\n        // During tokenization we want to distinguish some\n        // specific sigil types, namely string and regexp,\n        // so that they cen be themed separately.\n        //\n        // To reasonably handle all those combinations we leverage\n        // dot-separated states, so if we transition to @sigilStart.interpol.s.{.}\n        // then \"sigilStart.interpol.s\" state will match and also all\n        // the individual dot-separated parameters can be accessed.\n        sigils: [\n            [/~[a-z]@sigilStartDelimiter/, { token: '@rematch', next: '@sigil.interpol' }],\n            [/~[A-Z]@sigilStartDelimiter/, { token: '@rematch', next: '@sigil.noInterpol' }]\n        ],\n        sigil: [\n            [/~([a-zA-Z])\\{/, { token: '@rematch', switchTo: '@sigilStart.$S2.$1.{.}' }],\n            [/~([a-zA-Z])\\[/, { token: '@rematch', switchTo: '@sigilStart.$S2.$1.[.]' }],\n            [/~([a-zA-Z])\\(/, { token: '@rematch', switchTo: '@sigilStart.$S2.$1.(.)' }],\n            [/~([a-zA-Z])\\</, { token: '@rematch', switchTo: '@sigilStart.$S2.$1.<.>' }],\n            [\n                /~([a-zA-Z])(@sigilSymmetricDelimiter)/,\n                { token: '@rematch', switchTo: '@sigilStart.$S2.$1.$2.$2' }\n            ]\n        ],\n        // The definitions below expect states to be of the form:\n        //\n        // sigilStart.<interpol-or-noInterpol>.<sigil-letter>.<start-delimiter>.<end-delimiter>\n        // sigilContinue.<interpol-or-noInterpol>.<sigil-letter>.<start-delimiter>.<end-delimiter>\n        //\n        // The sigilStart state is used only to properly classify the token (as string/regex/sigil)\n        // and immediately switches to the sigilContinue sate, which handles the actual content\n        // and waits for the corresponding end delimiter.\n        'sigilStart.interpol.s': [\n            [\n                /~s@sigilStartDelimiter/,\n                {\n                    token: 'string.delimiter',\n                    switchTo: '@sigilContinue.$S2.$S3.$S4.$S5'\n                }\n            ]\n        ],\n        'sigilContinue.interpol.s': [\n            [\n                /(@sigilEndDelimiter)[a-zA-Z]*/,\n                {\n                    cases: {\n                        '$1==$S5': { token: 'string.delimiter', next: '@pop' },\n                        '@default': 'string'\n                    }\n                }\n            ],\n            { include: '@stringContentInterpol' }\n        ],\n        'sigilStart.noInterpol.S': [\n            [\n                /~S@sigilStartDelimiter/,\n                {\n                    token: 'string.delimiter',\n                    switchTo: '@sigilContinue.$S2.$S3.$S4.$S5'\n                }\n            ]\n        ],\n        'sigilContinue.noInterpol.S': [\n            // Ignore escaped sigil end\n            [/(^|[^\\\\])\\\\@sigilEndDelimiter/, 'string'],\n            [\n                /(@sigilEndDelimiter)[a-zA-Z]*/,\n                {\n                    cases: {\n                        '$1==$S5': { token: 'string.delimiter', next: '@pop' },\n                        '@default': 'string'\n                    }\n                }\n            ],\n            { include: '@stringContent' }\n        ],\n        'sigilStart.interpol.r': [\n            [\n                /~r@sigilStartDelimiter/,\n                {\n                    token: 'regexp.delimiter',\n                    switchTo: '@sigilContinue.$S2.$S3.$S4.$S5'\n                }\n            ]\n        ],\n        'sigilContinue.interpol.r': [\n            [\n                /(@sigilEndDelimiter)[a-zA-Z]*/,\n                {\n                    cases: {\n                        '$1==$S5': { token: 'regexp.delimiter', next: '@pop' },\n                        '@default': 'regexp'\n                    }\n                }\n            ],\n            { include: '@regexpContentInterpol' }\n        ],\n        'sigilStart.noInterpol.R': [\n            [\n                /~R@sigilStartDelimiter/,\n                {\n                    token: 'regexp.delimiter',\n                    switchTo: '@sigilContinue.$S2.$S3.$S4.$S5'\n                }\n            ]\n        ],\n        'sigilContinue.noInterpol.R': [\n            // Ignore escaped sigil end\n            [/(^|[^\\\\])\\\\@sigilEndDelimiter/, 'regexp'],\n            [\n                /(@sigilEndDelimiter)[a-zA-Z]*/,\n                {\n                    cases: {\n                        '$1==$S5': { token: 'regexp.delimiter', next: '@pop' },\n                        '@default': 'regexp'\n                    }\n                }\n            ],\n            { include: '@regexpContent' }\n        ],\n        // Fallback to the generic sigil by default\n        'sigilStart.interpol': [\n            [\n                /~([a-zA-Z])@sigilStartDelimiter/,\n                {\n                    token: 'sigil.delimiter',\n                    switchTo: '@sigilContinue.$S2.$S3.$S4.$S5'\n                }\n            ]\n        ],\n        'sigilContinue.interpol': [\n            [\n                /(@sigilEndDelimiter)[a-zA-Z]*/,\n                {\n                    cases: {\n                        '$1==$S5': { token: 'sigil.delimiter', next: '@pop' },\n                        '@default': 'sigil'\n                    }\n                }\n            ],\n            { include: '@sigilContentInterpol' }\n        ],\n        'sigilStart.noInterpol': [\n            [\n                /~([a-zA-Z])@sigilStartDelimiter/,\n                {\n                    token: 'sigil.delimiter',\n                    switchTo: '@sigilContinue.$S2.$S3.$S4.$S5'\n                }\n            ]\n        ],\n        'sigilContinue.noInterpol': [\n            // Ignore escaped sigil end\n            [/(^|[^\\\\])\\\\@sigilEndDelimiter/, 'sigil'],\n            [\n                /(@sigilEndDelimiter)[a-zA-Z]*/,\n                {\n                    cases: {\n                        '$1==$S5': { token: 'sigil.delimiter', next: '@pop' },\n                        '@default': 'sigil'\n                    }\n                }\n            ],\n            { include: '@sigilContent' }\n        ],\n        // Attributes\n        attributes: [\n            // Module @doc* attributes - tokenized as comments\n            [\n                /\\@(module|type)?doc (~[sS])?\"\"\"/,\n                {\n                    token: 'comment.block.documentation',\n                    next: '@doubleQuotedHeredocDocstring'\n                }\n            ],\n            [\n                /\\@(module|type)?doc (~[sS])?\"/,\n                {\n                    token: 'comment.block.documentation',\n                    next: '@doubleQuotedStringDocstring'\n                }\n            ],\n            [/\\@(module|type)?doc false/, 'comment.block.documentation'],\n            // Module attributes\n            [/\\@(@variableName)/, 'variable']\n        ],\n        doubleQuotedHeredocDocstring: [\n            [/\"\"\"/, { token: 'comment.block.documentation', next: '@pop' }],\n            { include: '@docstringContent' }\n        ],\n        doubleQuotedStringDocstring: [\n            [/\"/, { token: 'comment.block.documentation', next: '@pop' }],\n            { include: '@docstringContent' }\n        ],\n        // Operators, punctuation, brackets\n        symbols: [\n            // Code point operator (either with regular character ?a or an escaped one ?\\n)\n            [/\\?(\\\\.|[^\\\\\\s])/, 'number.constant'],\n            // Anonymous function arguments\n            [/&\\d+/, 'operator'],\n            // Bitshift operators (must go before delimiters, so that << >> don't match first)\n            [/<<<|>>>/, 'operator'],\n            // Delimiter pairs\n            [/[()\\[\\]\\{\\}]|<<|>>/, '@brackets'],\n            // Triple dot is a valid name (must go before operators, so that .. doesn't match instead)\n            [/\\.\\.\\./, 'identifier'],\n            // Punctuation => (must go before operators, so it's not tokenized as = then >)\n            [/=>/, 'punctuation'],\n            // Operators\n            [/@operator/, 'operator'],\n            // Punctuation\n            [/[:;,.%]/, 'punctuation']\n        ],\n        // Generic helpers\n        stringContentInterpol: [\n            { include: '@interpolation' },\n            { include: '@escapeChar' },\n            { include: '@stringContent' }\n        ],\n        stringContent: [[/./, 'string']],\n        stringConstantContentInterpol: [\n            { include: '@interpolation' },\n            { include: '@escapeChar' },\n            { include: '@stringConstantContent' }\n        ],\n        stringConstantContent: [[/./, 'constant']],\n        regexpContentInterpol: [\n            { include: '@interpolation' },\n            { include: '@escapeChar' },\n            { include: '@regexpContent' }\n        ],\n        regexpContent: [\n            // # may be a regular regexp char, so we use a heuristic\n            // assuming a # surrounded by whitespace is actually a comment.\n            [/(\\s)(#)(\\s.*)$/, ['white', 'comment.punctuation', 'comment']],\n            [/./, 'regexp']\n        ],\n        sigilContentInterpol: [\n            { include: '@interpolation' },\n            { include: '@escapeChar' },\n            { include: '@sigilContent' }\n        ],\n        sigilContent: [[/./, 'sigil']],\n        docstringContent: [[/./, 'comment.block.documentation']],\n        escapeChar: [[/@escape/, 'constant.character.escape']],\n        interpolation: [\n            [/#{/, { token: 'delimiter.bracket.embed', next: '@interpolationContinue' }]\n        ],\n        interpolationContinue: [\n            [/}/, { token: 'delimiter.bracket.embed', next: '@pop' }],\n            // Interpolation brackets may contain arbitrary code,\n            // so we simply match against all the root rules,\n            // until we reach interpolation end (the above matches).\n            { include: '@root' }\n        ]\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AdnVlLWRldnRvb2xzL3NoZWxsLWhvc3QvLi4vLi4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2Jhc2ljLWxhbmd1YWdlcy9lbGl4aXIvZWxpeGlyLmpzPzZlMWYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLFdBQVcsS0FBSztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsU0FBUyxZQUFZLEdBQUc7QUFDakMsU0FBUyx3QkFBd0I7QUFDakMsU0FBUyx3QkFBd0I7QUFDakMsU0FBUyx3QkFBd0I7QUFDakMsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTLHNEQUFzRDtBQUMvRCxTQUFTLDRDQUE0QztBQUNyRCxTQUFTLDRCQUE0QjtBQUNyQyxTQUFTLHNEQUFzRDtBQUMvRCxTQUFTLHdCQUF3QjtBQUNqQyxTQUFTLFNBQVMsWUFBWSxHQUFHO0FBQ2pDLFNBQVMsd0JBQXdCO0FBQ2pDLFNBQVM7QUFDVDtBQUNBO0FBQ0EsbUZBQW1GO0FBQ25GLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVMsbURBQW1EO0FBQzVELFNBQVMsd0RBQXdEO0FBQ2pFLFNBQVMsU0FBUyxZQUFZLDZCQUE2QjtBQUMzRCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsSUFBSSxjQUFjLElBQUkscURBQXFELElBQUksd0JBQXdCLElBQUk7QUFDcEk7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsRUFBRSxLQUFLLEVBQUU7QUFDOUM7QUFDQTtBQUNBLG9FQUFvRSxFQUFFO0FBQ3RFO0FBQ0EsdURBQXVEO0FBQ3ZELHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLEVBQUUsZ0JBQWdCLEVBQUU7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHlCQUF5QjtBQUN0QyxhQUFhLHVCQUF1QjtBQUNwQztBQUNBO0FBQ0EsYUFBYSxnQ0FBZ0M7QUFDN0MsYUFBYSxzQkFBc0I7QUFDbkMsYUFBYSwwQkFBMEI7QUFDdkMsYUFBYSxzQkFBc0I7QUFDbkMsYUFBYSxvQkFBb0I7QUFDakMsYUFBYSxxQkFBcUI7QUFDbEMsYUFBYSx5QkFBeUI7QUFDdEMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsS0FBSztBQUNuQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLDhCQUE4QixLQUFLO0FBQ25DLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNENBQTRDO0FBQ2hFLGFBQWE7QUFDYjtBQUNBO0FBQ0Esb0JBQW9CLDRDQUE0QztBQUNoRSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMERBQTBEO0FBQy9FLHFCQUFxQiwwREFBMEQ7QUFDL0UsbUJBQW1CLHlEQUF5RDtBQUM1RSxtQkFBbUIseURBQXlEO0FBQzVFO0FBQ0E7QUFDQSxxQkFBcUIsMENBQTBDO0FBQy9ELGFBQWE7QUFDYjtBQUNBO0FBQ0EscUJBQXFCLDBDQUEwQztBQUMvRCxhQUFhO0FBQ2I7QUFDQTtBQUNBLG1CQUFtQiwwQ0FBMEM7QUFDN0QsYUFBYTtBQUNiO0FBQ0E7QUFDQSxtQkFBbUIsMENBQTBDO0FBQzdELGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwrREFBK0Q7QUFDbkYsb0JBQW9CLCtEQUErRDtBQUNuRjtBQUNBO0FBQ0EsbUJBQW1CLDRDQUE0QztBQUMvRCxhQUFhO0FBQ2I7QUFDQTtBQUNBLG1CQUFtQiw0Q0FBNEM7QUFDL0QsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsUUFBUTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0Y7QUFDaEY7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLDZDQUE2QztBQUN6Riw0Q0FBNEMsK0NBQStDO0FBQzNGO0FBQ0E7QUFDQSwyQkFBMkIsSUFBSSxtREFBbUQsRUFBRSxHQUFHO0FBQ3ZGLCtCQUErQix3REFBd0Q7QUFDdkYsK0JBQStCLHdEQUF3RDtBQUN2RiwrQkFBK0Isd0RBQXdEO0FBQ3ZGO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDBDQUEwQztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDBDQUEwQztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsMENBQTBDO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsMENBQTBDO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHlDQUF5QztBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHlDQUF5QztBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHFEQUFxRDtBQUMxRSxhQUFhO0FBQ2I7QUFDQTtBQUNBLG1CQUFtQixxREFBcUQ7QUFDeEUsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLEVBQUU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsYUFBYSw0QkFBNEI7QUFDekMsYUFBYSx5QkFBeUI7QUFDdEMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWEsNEJBQTRCO0FBQ3pDLGFBQWEseUJBQXlCO0FBQ3RDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhLDRCQUE0QjtBQUN6QyxhQUFhLHlCQUF5QjtBQUN0QyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsNEJBQTRCO0FBQ3pDLGFBQWEseUJBQXlCO0FBQ3RDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLElBQUksbUVBQW1FO0FBQ3ZGO0FBQ0E7QUFDQSxlQUFlLElBQUksaURBQWlEO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EiLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2Jhc2ljLWxhbmd1YWdlcy9lbGl4aXIvZWxpeGlyLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5leHBvcnQgdmFyIGNvbmYgPSB7XG4gICAgY29tbWVudHM6IHtcbiAgICAgICAgbGluZUNvbW1lbnQ6ICcjJ1xuICAgIH0sXG4gICAgYnJhY2tldHM6IFtcbiAgICAgICAgWyd7JywgJ30nXSxcbiAgICAgICAgWydbJywgJ10nXSxcbiAgICAgICAgWycoJywgJyknXVxuICAgIF0sXG4gICAgc3Vycm91bmRpbmdQYWlyczogW1xuICAgICAgICB7IG9wZW46ICd7JywgY2xvc2U6ICd9JyB9LFxuICAgICAgICB7IG9wZW46ICdbJywgY2xvc2U6ICddJyB9LFxuICAgICAgICB7IG9wZW46ICcoJywgY2xvc2U6ICcpJyB9LFxuICAgICAgICB7IG9wZW46IFwiJ1wiLCBjbG9zZTogXCInXCIgfSxcbiAgICAgICAgeyBvcGVuOiAnXCInLCBjbG9zZTogJ1wiJyB9XG4gICAgXSxcbiAgICBhdXRvQ2xvc2luZ1BhaXJzOiBbXG4gICAgICAgIHsgb3BlbjogXCInXCIsIGNsb3NlOiBcIidcIiwgbm90SW46IFsnc3RyaW5nJywgJ2NvbW1lbnQnXSB9LFxuICAgICAgICB7IG9wZW46ICdcIicsIGNsb3NlOiAnXCInLCBub3RJbjogWydjb21tZW50J10gfSxcbiAgICAgICAgeyBvcGVuOiAnXCJcIlwiJywgY2xvc2U6ICdcIlwiXCInIH0sXG4gICAgICAgIHsgb3BlbjogJ2AnLCBjbG9zZTogJ2AnLCBub3RJbjogWydzdHJpbmcnLCAnY29tbWVudCddIH0sXG4gICAgICAgIHsgb3BlbjogJygnLCBjbG9zZTogJyknIH0sXG4gICAgICAgIHsgb3BlbjogJ3snLCBjbG9zZTogJ30nIH0sXG4gICAgICAgIHsgb3BlbjogJ1snLCBjbG9zZTogJ10nIH0sXG4gICAgICAgIHsgb3BlbjogJzw8JywgY2xvc2U6ICc+PicgfVxuICAgIF0sXG4gICAgaW5kZW50YXRpb25SdWxlczoge1xuICAgICAgICBpbmNyZWFzZUluZGVudFBhdHRlcm46IC9eXFxzKihhZnRlcnxlbHNlfGNhdGNofHJlc2N1ZXxmbnxbXiNdKihkb3w8XFwtfFxcLT58XFx7fFxcW3xcXD0pKVxccyokLyxcbiAgICAgICAgZGVjcmVhc2VJbmRlbnRQYXR0ZXJuOiAvXlxccyooKFxcfXxcXF0pXFxzKiR8KGFmdGVyfGVsc2V8Y2F0Y2h8cmVzY3VlfGVuZClcXGIpL1xuICAgIH1cbn07XG4vKipcbiAqIEEgTW9uYXJjaCBsZXhlciBmb3IgdGhlIEVsaXhpciBsYW5ndWFnZS5cbiAqXG4gKiBSZWZlcmVuY2VzOlxuICpcbiAqICogTW9uYXJjaCBkb2N1bWVudGF0aW9uIC0gaHR0cHM6Ly9taWNyb3NvZnQuZ2l0aHViLmlvL21vbmFjby1lZGl0b3IvbW9uYXJjaC5odG1sXG4gKiAqIEVsaXhpciBsZXhlciAtIGh0dHBzOi8vZ2l0aHViLmNvbS9lbGl4aXItbWFrZXVwL21ha2V1cF9lbGl4aXIvYmxvYi9tYXN0ZXIvbGliL21ha2V1cC9sZXhlcnMvZWxpeGlyX2xleGVyLmV4XG4gKiAqIFRleHRNYXRlIGxleGVyIChlbGl4aXItdG1idW5kbGUpIC0gaHR0cHM6Ly9naXRodWIuY29tL2VsaXhpci1lZGl0b3JzL2VsaXhpci10bWJ1bmRsZS9ibG9iL21hc3Rlci9TeW50YXhlcy9FbGl4aXIudG1MYW5ndWFnZVxuICogKiBUZXh0TWF0ZSBsZXhlciAodnNjb2RlLWVsaXhpci1scykgLSBodHRwczovL2dpdGh1Yi5jb20vZWxpeGlyLWxzcC92c2NvZGUtZWxpeGlyLWxzL2Jsb2IvbWFzdGVyL3N5bnRheGVzL2VsaXhpci5qc29uXG4gKi9cbmV4cG9ydCB2YXIgbGFuZ3VhZ2UgPSB7XG4gICAgZGVmYXVsdFRva2VuOiAnc291cmNlJyxcbiAgICB0b2tlblBvc3RmaXg6ICcuZWxpeGlyJyxcbiAgICBicmFja2V0czogW1xuICAgICAgICB7IG9wZW46ICdbJywgY2xvc2U6ICddJywgdG9rZW46ICdkZWxpbWl0ZXIuc3F1YXJlJyB9LFxuICAgICAgICB7IG9wZW46ICcoJywgY2xvc2U6ICcpJywgdG9rZW46ICdkZWxpbWl0ZXIucGFyZW50aGVzaXMnIH0sXG4gICAgICAgIHsgb3BlbjogJ3snLCBjbG9zZTogJ30nLCB0b2tlbjogJ2RlbGltaXRlci5jdXJseScgfSxcbiAgICAgICAgeyBvcGVuOiAnPDwnLCBjbG9zZTogJz4+JywgdG9rZW46ICdkZWxpbWl0ZXIuYW5nbGUuc3BlY2lhbCcgfVxuICAgIF0sXG4gICAgLy8gQmVsb3cgYXJlIGxpc3RzL3JlZ2V4cHMgdG8gd2hpY2ggd2UgcmVmZXJlbmNlIGxhdGVyLlxuICAgIGRlY2xhcmF0aW9uS2V5d29yZHM6IFtcbiAgICAgICAgJ2RlZicsXG4gICAgICAgICdkZWZwJyxcbiAgICAgICAgJ2RlZm4nLFxuICAgICAgICAnZGVmbnAnLFxuICAgICAgICAnZGVmZ3VhcmQnLFxuICAgICAgICAnZGVmZ3VhcmRwJyxcbiAgICAgICAgJ2RlZm1hY3JvJyxcbiAgICAgICAgJ2RlZm1hY3JvcCcsXG4gICAgICAgICdkZWZkZWxlZ2F0ZScsXG4gICAgICAgICdkZWZjYWxsYmFjaycsXG4gICAgICAgICdkZWZtYWNyb2NhbGxiYWNrJyxcbiAgICAgICAgJ2RlZm1vZHVsZScsXG4gICAgICAgICdkZWZwcm90b2NvbCcsXG4gICAgICAgICdkZWZleGNlcHRpb24nLFxuICAgICAgICAnZGVmaW1wbCcsXG4gICAgICAgICdkZWZzdHJ1Y3QnXG4gICAgXSxcbiAgICBvcGVyYXRvcktleXdvcmRzOiBbJ2FuZCcsICdpbicsICdub3QnLCAnb3InLCAnd2hlbiddLFxuICAgIG5hbWVzcGFjZUtleXdvcmRzOiBbJ2FsaWFzJywgJ2ltcG9ydCcsICdyZXF1aXJlJywgJ3VzZSddLFxuICAgIG90aGVyS2V5d29yZHM6IFtcbiAgICAgICAgJ2FmdGVyJyxcbiAgICAgICAgJ2Nhc2UnLFxuICAgICAgICAnY2F0Y2gnLFxuICAgICAgICAnY29uZCcsXG4gICAgICAgICdkbycsXG4gICAgICAgICdlbHNlJyxcbiAgICAgICAgJ2VuZCcsXG4gICAgICAgICdmbicsXG4gICAgICAgICdmb3InLFxuICAgICAgICAnaWYnLFxuICAgICAgICAncXVvdGUnLFxuICAgICAgICAncmFpc2UnLFxuICAgICAgICAncmVjZWl2ZScsXG4gICAgICAgICdyZXNjdWUnLFxuICAgICAgICAnc3VwZXInLFxuICAgICAgICAndGhyb3cnLFxuICAgICAgICAndHJ5JyxcbiAgICAgICAgJ3VubGVzcycsXG4gICAgICAgICd1bnF1b3RlX3NwbGljaW5nJyxcbiAgICAgICAgJ3VucXVvdGUnLFxuICAgICAgICAnd2l0aCdcbiAgICBdLFxuICAgIGNvbnN0YW50czogWyd0cnVlJywgJ2ZhbHNlJywgJ25pbCddLFxuICAgIG5hbWVCdWlsdGluOiBbJ19fTU9EVUxFX18nLCAnX19ESVJfXycsICdfX0VOVl9fJywgJ19fQ0FMTEVSX18nLCAnX19TVEFDS1RSQUNFX18nXSxcbiAgICAvLyBNYXRjaGVzIGFueSBvZiB0aGUgb3BlcmF0b3IgbmFtZXM6XG4gICAgLy8gPDw8ID4+PiB8fHwgJiYmIF5eXiB+fn4gPT09ICE9PSB+Pj4gPH4+IHx+PiA8fD4gPT0gIT0gPD0gPj0gJiYgfHwgXFxcXCA8PiArKyAtLSB8PiA9fiAtPiA8LSB+PiA8fiA6OiAuLiA9IDwgPiArIC0gKiAvIHwgLiBeICYgIVxuICAgIG9wZXJhdG9yOiAvLVstPl0/fCE9ezAsMn18XFwqfFxcL3xcXFxcXFxcXHwmezEsM318XFwuXFwuP3xcXF4oPzpcXF5cXF4pP3xcXCtcXCs/fDwoPzotfDw8fD18PnxcXHw+fH4+Pyk/fD1+fD17MSwzfXw+KD86PXw+Pik/fFxcfH4+fFxcfD58XFx8ezEsM318fj4+P3x+fn58OjovLFxuICAgIC8vIFNlZSBodHRwczovL2hleGRvY3MucG0vZWxpeGlyL3N5bnRheC1yZWZlcmVuY2UuaHRtbCN2YXJpYWJsZXNcbiAgICB2YXJpYWJsZU5hbWU6IC9bYS16X11bYS16QS1aMC05X10qWz8hXT8vLFxuICAgIC8vIFNlZSBodHRwczovL2hleGRvY3MucG0vZWxpeGlyL3N5bnRheC1yZWZlcmVuY2UuaHRtbCNhdG9tc1xuICAgIGF0b21OYW1lOiAvW2EtekEtWl9dW2EtekEtWjAtOV9AXSpbPyFdP3xAc3BlY2lhbEF0b21OYW1lfEBvcGVyYXRvci8sXG4gICAgc3BlY2lhbEF0b21OYW1lOiAvXFwuXFwuXFwufDw8Pj58JVxce1xcfXwlfFxce1xcfS8sXG4gICAgYWxpYXNQYXJ0OiAvW0EtWl1bYS16QS1aMC05X10qLyxcbiAgICBtb2R1bGVOYW1lOiAvQGFsaWFzUGFydCg/OlxcLkBhbGlhc1BhcnQpKi8sXG4gICAgLy8gU2lnaWwgcGFpcnMgYXJlOiBcIlwiXCIgXCJcIlwiLCAnJycgJycnLCBcIiBcIiwgJyAnLCAvIC8sIHwgfCwgPCA+LCB7IH0sIFsgXSwgKCApXG4gICAgc2lnaWxTeW1tZXRyaWNEZWxpbWl0ZXI6IC9cIlwiXCJ8JycnfFwifCd8XFwvfFxcfC8sXG4gICAgc2lnaWxTdGFydERlbGltaXRlcjogL0BzaWdpbFN5bW1ldHJpY0RlbGltaXRlcnw8fFxce3xcXFt8XFwoLyxcbiAgICBzaWdpbEVuZERlbGltaXRlcjogL0BzaWdpbFN5bW1ldHJpY0RlbGltaXRlcnw+fFxcfXxcXF18XFwpLyxcbiAgICBkZWNpbWFsOiAvXFxkKD86Xz9cXGQpKi8sXG4gICAgaGV4OiAvWzAtOWEtZkEtRl0oXz9bMC05YS1mQS1GXSkqLyxcbiAgICBvY3RhbDogL1swLTddKF8/WzAtN10pKi8sXG4gICAgYmluYXJ5OiAvWzAxXShfP1swMV0pKi8sXG4gICAgLy8gU2VlIGh0dHBzOi8vaGV4ZG9jcy5wbS9lbGl4aXIvbWFzdGVyL1N0cmluZy5odG1sI21vZHVsZS1lc2NhcGUtY2hhcmFjdGVyc1xuICAgIGVzY2FwZTogL1xcXFx1WzAtOWEtZkEtRl17NH18XFxcXHhbMC05YS1mQS1GXXsyfXxcXFxcLi8sXG4gICAgLy8gVGhlIGtleXMgYmVsb3cgY29ycmVzcG9uZCB0byB0b2tlbml6ZXIgc3RhdGVzLlxuICAgIC8vIFdlIHN0YXJ0IGZyb20gdGhlIHJvb3Qgc3RhdGUgYW5kIG1hdGNoIGFnYWluc3QgaXRzIHJ1bGVzXG4gICAgLy8gdW50aWwgd2UgZXhwbGljaXRseSB0cmFuc2l0aW9uIGludG8gYW5vdGhlciBzdGF0ZS5cbiAgICAvLyBUaGUgYGluY2x1ZGVgIHNpbXBseSBicmluZ3MgaW4gYWxsIG9wZXJhdGlvbnMgZnJvbSB0aGUgZ2l2ZW4gc3RhdGVcbiAgICAvLyBhbmQgaXMgdXNlZnVsIGZvciBpbXByb3ZpbmcgcmVhZGFiaWxpdHkuXG4gICAgdG9rZW5pemVyOiB7XG4gICAgICAgIHJvb3Q6IFtcbiAgICAgICAgICAgIHsgaW5jbHVkZTogJ0B3aGl0ZXNwYWNlJyB9LFxuICAgICAgICAgICAgeyBpbmNsdWRlOiAnQGNvbW1lbnRzJyB9LFxuICAgICAgICAgICAgLy8gS2V5d29yZHMgc3RhcnQgYXMgZWl0aGVyIGFuIGlkZW50aWZpZXIgb3IgYSBzdHJpbmcsXG4gICAgICAgICAgICAvLyBidXQgZW5kIHdpdGggYSA6IHNvIGl0J3MgaW1wb3J0YW50IHRvIG1hdGNoIHRoaXMgZmlyc3QuXG4gICAgICAgICAgICB7IGluY2x1ZGU6ICdAa2V5d29yZHNTaG9ydGhhbmQnIH0sXG4gICAgICAgICAgICB7IGluY2x1ZGU6ICdAbnVtYmVycycgfSxcbiAgICAgICAgICAgIHsgaW5jbHVkZTogJ0BpZGVudGlmaWVycycgfSxcbiAgICAgICAgICAgIHsgaW5jbHVkZTogJ0BzdHJpbmdzJyB9LFxuICAgICAgICAgICAgeyBpbmNsdWRlOiAnQGF0b21zJyB9LFxuICAgICAgICAgICAgeyBpbmNsdWRlOiAnQHNpZ2lscycgfSxcbiAgICAgICAgICAgIHsgaW5jbHVkZTogJ0BhdHRyaWJ1dGVzJyB9LFxuICAgICAgICAgICAgeyBpbmNsdWRlOiAnQHN5bWJvbHMnIH1cbiAgICAgICAgXSxcbiAgICAgICAgLy8gV2hpdGVzcGFjZVxuICAgICAgICB3aGl0ZXNwYWNlOiBbWy9cXHMrLywgJ3doaXRlJ11dLFxuICAgICAgICAvLyBDb21tZW50c1xuICAgICAgICBjb21tZW50czogW1svKCMpKC4qKS8sIFsnY29tbWVudC5wdW5jdHVhdGlvbicsICdjb21tZW50J11dXSxcbiAgICAgICAgLy8gS2V5d29yZCBsaXN0IHNob3J0aGFuZFxuICAgICAgICBrZXl3b3Jkc1Nob3J0aGFuZDogW1xuICAgICAgICAgICAgWy8oQGF0b21OYW1lKSg6KS8sIFsnY29uc3RhbnQnLCAnY29uc3RhbnQucHVuY3R1YXRpb24nXV0sXG4gICAgICAgICAgICAvLyBVc2UgcG9zaXRpdmUgbG9vay1haGVhZCB0byBlbnN1cmUgdGhlIHN0cmluZyBpcyBmb2xsb3dlZCBieSA6XG4gICAgICAgICAgICAvLyBhbmQgc2hvdWxkIGJlIGNvbnNpZGVyZWQgYSBrZXl3b3JkLlxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIC9cIig/PShbXlwiXXwjXFx7Lio/XFx9fFxcXFxcIikqXCI6KS8sXG4gICAgICAgICAgICAgICAgeyB0b2tlbjogJ2NvbnN0YW50LmRlbGltaXRlcicsIG5leHQ6ICdAZG91YmxlUXVvdGVkU3RyaW5nS2V5d29yZCcgfVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAvJyg/PShbXiddfCNcXHsuKj9cXH18XFxcXCcpKic6KS8sXG4gICAgICAgICAgICAgICAgeyB0b2tlbjogJ2NvbnN0YW50LmRlbGltaXRlcicsIG5leHQ6ICdAc2luZ2xlUXVvdGVkU3RyaW5nS2V5d29yZCcgfVxuICAgICAgICAgICAgXVxuICAgICAgICBdLFxuICAgICAgICBkb3VibGVRdW90ZWRTdHJpbmdLZXl3b3JkOiBbXG4gICAgICAgICAgICBbL1wiOi8sIHsgdG9rZW46ICdjb25zdGFudC5kZWxpbWl0ZXInLCBuZXh0OiAnQHBvcCcgfV0sXG4gICAgICAgICAgICB7IGluY2x1ZGU6ICdAc3RyaW5nQ29uc3RhbnRDb250ZW50SW50ZXJwb2wnIH1cbiAgICAgICAgXSxcbiAgICAgICAgc2luZ2xlUXVvdGVkU3RyaW5nS2V5d29yZDogW1xuICAgICAgICAgICAgWy8nOi8sIHsgdG9rZW46ICdjb25zdGFudC5kZWxpbWl0ZXInLCBuZXh0OiAnQHBvcCcgfV0sXG4gICAgICAgICAgICB7IGluY2x1ZGU6ICdAc3RyaW5nQ29uc3RhbnRDb250ZW50SW50ZXJwb2wnIH1cbiAgICAgICAgXSxcbiAgICAgICAgLy8gTnVtYmVyc1xuICAgICAgICBudW1iZXJzOiBbXG4gICAgICAgICAgICBbLzBiQGJpbmFyeS8sICdudW1iZXIuYmluYXJ5J10sXG4gICAgICAgICAgICBbLzBvQG9jdGFsLywgJ251bWJlci5vY3RhbCddLFxuICAgICAgICAgICAgWy8weEBoZXgvLCAnbnVtYmVyLmhleCddLFxuICAgICAgICAgICAgWy9AZGVjaW1hbFxcLkBkZWNpbWFsKFtlRV0tP0BkZWNpbWFsKT8vLCAnbnVtYmVyLmZsb2F0J10sXG4gICAgICAgICAgICBbL0BkZWNpbWFsLywgJ251bWJlciddXG4gICAgICAgIF0sXG4gICAgICAgIC8vIElkZW50aWZpZXJzXG4gICAgICAgIGlkZW50aWZpZXJzOiBbXG4gICAgICAgICAgICAvLyBUb2tlbml6ZSBpZGVudGlmaWVyIG5hbWUgaW4gZnVuY3Rpb24tbGlrZSBkZWZpbml0aW9ucy5cbiAgICAgICAgICAgIC8vIE5vdGU6IGdpdmVuIGBkZWYgYSArIGIsIGRvOiBuaWxgLCBgYWAgaXMgbm90IGEgZnVuY3Rpb24gbmFtZSxcbiAgICAgICAgICAgIC8vIHNvIHdlIHVzZSBuZWdhdGl2ZSBsb29rLWFoZWFkIHRvIGVuc3VyZSB0aGVyZSdzIG5vIG9wZXJhdG9yLlxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIC9cXGIoZGVmcD98ZGVmbnA/fGRlZm1hY3JvcD98ZGVmZ3VhcmRwP3xkZWZkZWxlZ2F0ZSkoXFxzKykoQHZhcmlhYmxlTmFtZSkoPyFcXHMrQG9wZXJhdG9yKS8sXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAna2V5d29yZC5kZWNsYXJhdGlvbicsXG4gICAgICAgICAgICAgICAgICAgICd3aGl0ZScsXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2VzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5xdW90ZTogJ2tleXdvcmQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdAZGVmYXVsdCc6ICdmdW5jdGlvbidcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAvLyBUb2tlbml6ZSBmdW5jdGlvbiBjYWxsc1xuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIC8vIEluLXNjb3BlIGNhbGwgLSBhbiBpZGVudGlmaWVyIGZvbGxvd2VkIGJ5ICggb3IgLihcbiAgICAgICAgICAgICAgICAvKEB2YXJpYWJsZU5hbWUpKD89XFxzKlxcLj9cXHMqXFwoKS8sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjYXNlczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVG9rZW5pemUgYXMga2V5d29yZCBpbiBjYXNlcyBsaWtlIGBpZiguLi4sIGRvOiAuLi4sIGVsc2U6IC4uLilgXG4gICAgICAgICAgICAgICAgICAgICAgICAnQGRlY2xhcmF0aW9uS2V5d29yZHMnOiAna2V5d29yZC5kZWNsYXJhdGlvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnQG5hbWVzcGFjZUtleXdvcmRzJzogJ2tleXdvcmQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0BvdGhlcktleXdvcmRzJzogJ2tleXdvcmQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0BkZWZhdWx0JzogJ2Z1bmN0aW9uLmNhbGwnXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIC8vIFJlZmVyZW5jaW5nIGZ1bmN0aW9uIGluIGEgbW9kdWxlXG4gICAgICAgICAgICAgICAgLyhAbW9kdWxlTmFtZSkoXFxzKikoXFwuKShcXHMqKShAdmFyaWFibGVOYW1lKS8sXG4gICAgICAgICAgICAgICAgWyd0eXBlLmlkZW50aWZpZXInLCAnd2hpdGUnLCAnb3BlcmF0b3InLCAnd2hpdGUnLCAnZnVuY3Rpb24uY2FsbCddXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIC8vIFJlZmVyZW5jaW5nIGZ1bmN0aW9uIGluIGFuIEVybGFuZyBtb2R1bGVcbiAgICAgICAgICAgICAgICAvKDopKEBhdG9tTmFtZSkoXFxzKikoXFwuKShcXHMqKShAdmFyaWFibGVOYW1lKS8sXG4gICAgICAgICAgICAgICAgWydjb25zdGFudC5wdW5jdHVhdGlvbicsICdjb25zdGFudCcsICd3aGl0ZScsICdvcGVyYXRvcicsICd3aGl0ZScsICdmdW5jdGlvbi5jYWxsJ11cbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgLy8gUGlwaW5nIGludG8gYSBmdW5jdGlvbiAodG9rZW5pemVkIHNlcGFyYXRlbHkgYXMgaXQgbWF5IG5vdCBoYXZlIHBhcmVudGhlc2VzKVxuICAgICAgICAgICAgICAgIC8oXFx8PikoXFxzKikoQHZhcmlhYmxlTmFtZSkvLFxuICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgJ29wZXJhdG9yJyxcbiAgICAgICAgICAgICAgICAgICAgJ3doaXRlJyxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnQG90aGVyS2V5d29yZHMnOiAna2V5d29yZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0BkZWZhdWx0JzogJ2Z1bmN0aW9uLmNhbGwnXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIC8vIEZ1bmN0aW9uIHJlZmVyZW5jZSBwYXNzZWQgdG8gYW5vdGhlciBmdW5jdGlvblxuICAgICAgICAgICAgICAgIC8oJikoXFxzKikoQHZhcmlhYmxlTmFtZSkvLFxuICAgICAgICAgICAgICAgIFsnb3BlcmF0b3InLCAnd2hpdGUnLCAnZnVuY3Rpb24uY2FsbCddXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgLy8gTGFuZ3VhZ2Uga2V5d29yZHMsIGJ1aWx0aW5zLCBjb25zdGFudHMgYW5kIHZhcmlhYmxlc1xuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIC9AdmFyaWFibGVOYW1lLyxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2VzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnQGRlY2xhcmF0aW9uS2V5d29yZHMnOiAna2V5d29yZC5kZWNsYXJhdGlvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnQG9wZXJhdG9yS2V5d29yZHMnOiAna2V5d29yZC5vcGVyYXRvcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnQG5hbWVzcGFjZUtleXdvcmRzJzogJ2tleXdvcmQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0BvdGhlcktleXdvcmRzJzogJ2tleXdvcmQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0Bjb25zdGFudHMnOiAnY29uc3RhbnQubGFuZ3VhZ2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0BuYW1lQnVpbHRpbic6ICd2YXJpYWJsZS5sYW5ndWFnZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnXy4qJzogJ2NvbW1lbnQudW51c2VkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdAZGVmYXVsdCc6ICdpZGVudGlmaWVyJ1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIC8vIE1vZHVsZSBuYW1lc1xuICAgICAgICAgICAgWy9AbW9kdWxlTmFtZS8sICd0eXBlLmlkZW50aWZpZXInXVxuICAgICAgICBdLFxuICAgICAgICAvLyBTdHJpbmdzXG4gICAgICAgIHN0cmluZ3M6IFtcbiAgICAgICAgICAgIFsvXCJcIlwiLywgeyB0b2tlbjogJ3N0cmluZy5kZWxpbWl0ZXInLCBuZXh0OiAnQGRvdWJsZVF1b3RlZEhlcmVkb2MnIH1dLFxuICAgICAgICAgICAgWy8nJycvLCB7IHRva2VuOiAnc3RyaW5nLmRlbGltaXRlcicsIG5leHQ6ICdAc2luZ2xlUXVvdGVkSGVyZWRvYycgfV0sXG4gICAgICAgICAgICBbL1wiLywgeyB0b2tlbjogJ3N0cmluZy5kZWxpbWl0ZXInLCBuZXh0OiAnQGRvdWJsZVF1b3RlZFN0cmluZycgfV0sXG4gICAgICAgICAgICBbLycvLCB7IHRva2VuOiAnc3RyaW5nLmRlbGltaXRlcicsIG5leHQ6ICdAc2luZ2xlUXVvdGVkU3RyaW5nJyB9XVxuICAgICAgICBdLFxuICAgICAgICBkb3VibGVRdW90ZWRIZXJlZG9jOiBbXG4gICAgICAgICAgICBbL1wiXCJcIi8sIHsgdG9rZW46ICdzdHJpbmcuZGVsaW1pdGVyJywgbmV4dDogJ0Bwb3AnIH1dLFxuICAgICAgICAgICAgeyBpbmNsdWRlOiAnQHN0cmluZ0NvbnRlbnRJbnRlcnBvbCcgfVxuICAgICAgICBdLFxuICAgICAgICBzaW5nbGVRdW90ZWRIZXJlZG9jOiBbXG4gICAgICAgICAgICBbLycnJy8sIHsgdG9rZW46ICdzdHJpbmcuZGVsaW1pdGVyJywgbmV4dDogJ0Bwb3AnIH1dLFxuICAgICAgICAgICAgeyBpbmNsdWRlOiAnQHN0cmluZ0NvbnRlbnRJbnRlcnBvbCcgfVxuICAgICAgICBdLFxuICAgICAgICBkb3VibGVRdW90ZWRTdHJpbmc6IFtcbiAgICAgICAgICAgIFsvXCIvLCB7IHRva2VuOiAnc3RyaW5nLmRlbGltaXRlcicsIG5leHQ6ICdAcG9wJyB9XSxcbiAgICAgICAgICAgIHsgaW5jbHVkZTogJ0BzdHJpbmdDb250ZW50SW50ZXJwb2wnIH1cbiAgICAgICAgXSxcbiAgICAgICAgc2luZ2xlUXVvdGVkU3RyaW5nOiBbXG4gICAgICAgICAgICBbLycvLCB7IHRva2VuOiAnc3RyaW5nLmRlbGltaXRlcicsIG5leHQ6ICdAcG9wJyB9XSxcbiAgICAgICAgICAgIHsgaW5jbHVkZTogJ0BzdHJpbmdDb250ZW50SW50ZXJwb2wnIH1cbiAgICAgICAgXSxcbiAgICAgICAgLy8gQXRvbXNcbiAgICAgICAgYXRvbXM6IFtcbiAgICAgICAgICAgIFsvKDopKEBhdG9tTmFtZSkvLCBbJ2NvbnN0YW50LnB1bmN0dWF0aW9uJywgJ2NvbnN0YW50J11dLFxuICAgICAgICAgICAgWy86XCIvLCB7IHRva2VuOiAnY29uc3RhbnQuZGVsaW1pdGVyJywgbmV4dDogJ0Bkb3VibGVRdW90ZWRTdHJpbmdBdG9tJyB9XSxcbiAgICAgICAgICAgIFsvOicvLCB7IHRva2VuOiAnY29uc3RhbnQuZGVsaW1pdGVyJywgbmV4dDogJ0BzaW5nbGVRdW90ZWRTdHJpbmdBdG9tJyB9XVxuICAgICAgICBdLFxuICAgICAgICBkb3VibGVRdW90ZWRTdHJpbmdBdG9tOiBbXG4gICAgICAgICAgICBbL1wiLywgeyB0b2tlbjogJ2NvbnN0YW50LmRlbGltaXRlcicsIG5leHQ6ICdAcG9wJyB9XSxcbiAgICAgICAgICAgIHsgaW5jbHVkZTogJ0BzdHJpbmdDb25zdGFudENvbnRlbnRJbnRlcnBvbCcgfVxuICAgICAgICBdLFxuICAgICAgICBzaW5nbGVRdW90ZWRTdHJpbmdBdG9tOiBbXG4gICAgICAgICAgICBbLycvLCB7IHRva2VuOiAnY29uc3RhbnQuZGVsaW1pdGVyJywgbmV4dDogJ0Bwb3AnIH1dLFxuICAgICAgICAgICAgeyBpbmNsdWRlOiAnQHN0cmluZ0NvbnN0YW50Q29udGVudEludGVycG9sJyB9XG4gICAgICAgIF0sXG4gICAgICAgIC8vIFNpZ2lsc1xuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9lbGl4aXItbGFuZy5vcmcvZ2V0dGluZy1zdGFydGVkL3NpZ2lscy5odG1sXG4gICAgICAgIC8vIFNpZ2lscyBhbGxvdyBmb3IgdHlwaW5nIHZhbHVlcyB1c2luZyB0aGVpciB0ZXh0dWFsIHJlcHJlc2VudGF0aW9uLlxuICAgICAgICAvLyBBbGwgc2lnaWxzIHN0YXJ0IHdpdGggfiBmb2xsb3dlZCBieSBhIGxldHRlciBpbmRpY2F0aW5nIHNpZ2lsIHR5cGVcbiAgICAgICAgLy8gYW5kIHRoZW4gYSBkZWxpbWl0ZXIgcGFpciBlbmNsb3NpbmcgdGhlIHRleHR1YWwgcmVwcmVzZW50YXRpb24uXG4gICAgICAgIC8vIE9wdGlvbmFsIG1vZGlmaWVycyBhcmUgYWxsb3dlZCBhZnRlciB0aGUgY2xvc2luZyBkZWxpbWl0ZXIuXG4gICAgICAgIC8vIEZvciBpbnN0YW5jZSBhIHJlZ3VsYXIgZXhwcmVzc2lvbnMgY2FuIGJlIHdyaXR0ZW4gYXM6XG4gICAgICAgIC8vIH5yL2Zvb3xiYXIvIH5ye2Zvb3xiYXJ9IH5yL2Zvb3xiYXIvZ1xuICAgICAgICAvL1xuICAgICAgICAvLyBJbiBnZW5lcmFsIGxvd2VyY2FzZSBzaWdpbHMgYWxsb3cgZm9yIGludGVycG9sYXRpb25cbiAgICAgICAgLy8gYW5kIGVzY2FwZWQgY2hhcmFjdGVycywgd2hlcmVhcyB1cHBlcmNhc2Ugc2lnaWxzIGRvbid0XG4gICAgICAgIC8vXG4gICAgICAgIC8vIER1cmluZyB0b2tlbml6YXRpb24gd2Ugd2FudCB0byBkaXN0aW5ndWlzaCBzb21lXG4gICAgICAgIC8vIHNwZWNpZmljIHNpZ2lsIHR5cGVzLCBuYW1lbHkgc3RyaW5nIGFuZCByZWdleHAsXG4gICAgICAgIC8vIHNvIHRoYXQgdGhleSBjZW4gYmUgdGhlbWVkIHNlcGFyYXRlbHkuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFRvIHJlYXNvbmFibHkgaGFuZGxlIGFsbCB0aG9zZSBjb21iaW5hdGlvbnMgd2UgbGV2ZXJhZ2VcbiAgICAgICAgLy8gZG90LXNlcGFyYXRlZCBzdGF0ZXMsIHNvIGlmIHdlIHRyYW5zaXRpb24gdG8gQHNpZ2lsU3RhcnQuaW50ZXJwb2wucy57Ln1cbiAgICAgICAgLy8gdGhlbiBcInNpZ2lsU3RhcnQuaW50ZXJwb2wuc1wiIHN0YXRlIHdpbGwgbWF0Y2ggYW5kIGFsc28gYWxsXG4gICAgICAgIC8vIHRoZSBpbmRpdmlkdWFsIGRvdC1zZXBhcmF0ZWQgcGFyYW1ldGVycyBjYW4gYmUgYWNjZXNzZWQuXG4gICAgICAgIHNpZ2lsczogW1xuICAgICAgICAgICAgWy9+W2Etel1Ac2lnaWxTdGFydERlbGltaXRlci8sIHsgdG9rZW46ICdAcmVtYXRjaCcsIG5leHQ6ICdAc2lnaWwuaW50ZXJwb2wnIH1dLFxuICAgICAgICAgICAgWy9+W0EtWl1Ac2lnaWxTdGFydERlbGltaXRlci8sIHsgdG9rZW46ICdAcmVtYXRjaCcsIG5leHQ6ICdAc2lnaWwubm9JbnRlcnBvbCcgfV1cbiAgICAgICAgXSxcbiAgICAgICAgc2lnaWw6IFtcbiAgICAgICAgICAgIFsvfihbYS16QS1aXSlcXHsvLCB7IHRva2VuOiAnQHJlbWF0Y2gnLCBzd2l0Y2hUbzogJ0BzaWdpbFN0YXJ0LiRTMi4kMS57Ln0nIH1dLFxuICAgICAgICAgICAgWy9+KFthLXpBLVpdKVxcWy8sIHsgdG9rZW46ICdAcmVtYXRjaCcsIHN3aXRjaFRvOiAnQHNpZ2lsU3RhcnQuJFMyLiQxLlsuXScgfV0sXG4gICAgICAgICAgICBbL34oW2EtekEtWl0pXFwoLywgeyB0b2tlbjogJ0ByZW1hdGNoJywgc3dpdGNoVG86ICdAc2lnaWxTdGFydC4kUzIuJDEuKC4pJyB9XSxcbiAgICAgICAgICAgIFsvfihbYS16QS1aXSlcXDwvLCB7IHRva2VuOiAnQHJlbWF0Y2gnLCBzd2l0Y2hUbzogJ0BzaWdpbFN0YXJ0LiRTMi4kMS48Lj4nIH1dLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIC9+KFthLXpBLVpdKShAc2lnaWxTeW1tZXRyaWNEZWxpbWl0ZXIpLyxcbiAgICAgICAgICAgICAgICB7IHRva2VuOiAnQHJlbWF0Y2gnLCBzd2l0Y2hUbzogJ0BzaWdpbFN0YXJ0LiRTMi4kMS4kMi4kMicgfVxuICAgICAgICAgICAgXVxuICAgICAgICBdLFxuICAgICAgICAvLyBUaGUgZGVmaW5pdGlvbnMgYmVsb3cgZXhwZWN0IHN0YXRlcyB0byBiZSBvZiB0aGUgZm9ybTpcbiAgICAgICAgLy9cbiAgICAgICAgLy8gc2lnaWxTdGFydC48aW50ZXJwb2wtb3Itbm9JbnRlcnBvbD4uPHNpZ2lsLWxldHRlcj4uPHN0YXJ0LWRlbGltaXRlcj4uPGVuZC1kZWxpbWl0ZXI+XG4gICAgICAgIC8vIHNpZ2lsQ29udGludWUuPGludGVycG9sLW9yLW5vSW50ZXJwb2w+LjxzaWdpbC1sZXR0ZXI+LjxzdGFydC1kZWxpbWl0ZXI+LjxlbmQtZGVsaW1pdGVyPlxuICAgICAgICAvL1xuICAgICAgICAvLyBUaGUgc2lnaWxTdGFydCBzdGF0ZSBpcyB1c2VkIG9ubHkgdG8gcHJvcGVybHkgY2xhc3NpZnkgdGhlIHRva2VuIChhcyBzdHJpbmcvcmVnZXgvc2lnaWwpXG4gICAgICAgIC8vIGFuZCBpbW1lZGlhdGVseSBzd2l0Y2hlcyB0byB0aGUgc2lnaWxDb250aW51ZSBzYXRlLCB3aGljaCBoYW5kbGVzIHRoZSBhY3R1YWwgY29udGVudFxuICAgICAgICAvLyBhbmQgd2FpdHMgZm9yIHRoZSBjb3JyZXNwb25kaW5nIGVuZCBkZWxpbWl0ZXIuXG4gICAgICAgICdzaWdpbFN0YXJ0LmludGVycG9sLnMnOiBbXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgL35zQHNpZ2lsU3RhcnREZWxpbWl0ZXIvLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW46ICdzdHJpbmcuZGVsaW1pdGVyJyxcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoVG86ICdAc2lnaWxDb250aW51ZS4kUzIuJFMzLiRTNC4kUzUnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICBdLFxuICAgICAgICAnc2lnaWxDb250aW51ZS5pbnRlcnBvbC5zJzogW1xuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIC8oQHNpZ2lsRW5kRGVsaW1pdGVyKVthLXpBLVpdKi8sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjYXNlczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJyQxPT0kUzUnOiB7IHRva2VuOiAnc3RyaW5nLmRlbGltaXRlcicsIG5leHQ6ICdAcG9wJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0BkZWZhdWx0JzogJ3N0cmluZydcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB7IGluY2x1ZGU6ICdAc3RyaW5nQ29udGVudEludGVycG9sJyB9XG4gICAgICAgIF0sXG4gICAgICAgICdzaWdpbFN0YXJ0Lm5vSW50ZXJwb2wuUyc6IFtcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAvflNAc2lnaWxTdGFydERlbGltaXRlci8sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbjogJ3N0cmluZy5kZWxpbWl0ZXInLFxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2hUbzogJ0BzaWdpbENvbnRpbnVlLiRTMi4kUzMuJFM0LiRTNSdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgIF0sXG4gICAgICAgICdzaWdpbENvbnRpbnVlLm5vSW50ZXJwb2wuUyc6IFtcbiAgICAgICAgICAgIC8vIElnbm9yZSBlc2NhcGVkIHNpZ2lsIGVuZFxuICAgICAgICAgICAgWy8oXnxbXlxcXFxdKVxcXFxAc2lnaWxFbmREZWxpbWl0ZXIvLCAnc3RyaW5nJ10sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgLyhAc2lnaWxFbmREZWxpbWl0ZXIpW2EtekEtWl0qLyxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2VzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnJDE9PSRTNSc6IHsgdG9rZW46ICdzdHJpbmcuZGVsaW1pdGVyJywgbmV4dDogJ0Bwb3AnIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAnQGRlZmF1bHQnOiAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIHsgaW5jbHVkZTogJ0BzdHJpbmdDb250ZW50JyB9XG4gICAgICAgIF0sXG4gICAgICAgICdzaWdpbFN0YXJ0LmludGVycG9sLnInOiBbXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgL35yQHNpZ2lsU3RhcnREZWxpbWl0ZXIvLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW46ICdyZWdleHAuZGVsaW1pdGVyJyxcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoVG86ICdAc2lnaWxDb250aW51ZS4kUzIuJFMzLiRTNC4kUzUnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICBdLFxuICAgICAgICAnc2lnaWxDb250aW51ZS5pbnRlcnBvbC5yJzogW1xuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIC8oQHNpZ2lsRW5kRGVsaW1pdGVyKVthLXpBLVpdKi8sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjYXNlczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJyQxPT0kUzUnOiB7IHRva2VuOiAncmVnZXhwLmRlbGltaXRlcicsIG5leHQ6ICdAcG9wJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0BkZWZhdWx0JzogJ3JlZ2V4cCdcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB7IGluY2x1ZGU6ICdAcmVnZXhwQ29udGVudEludGVycG9sJyB9XG4gICAgICAgIF0sXG4gICAgICAgICdzaWdpbFN0YXJ0Lm5vSW50ZXJwb2wuUic6IFtcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAvflJAc2lnaWxTdGFydERlbGltaXRlci8sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbjogJ3JlZ2V4cC5kZWxpbWl0ZXInLFxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2hUbzogJ0BzaWdpbENvbnRpbnVlLiRTMi4kUzMuJFM0LiRTNSdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgIF0sXG4gICAgICAgICdzaWdpbENvbnRpbnVlLm5vSW50ZXJwb2wuUic6IFtcbiAgICAgICAgICAgIC8vIElnbm9yZSBlc2NhcGVkIHNpZ2lsIGVuZFxuICAgICAgICAgICAgWy8oXnxbXlxcXFxdKVxcXFxAc2lnaWxFbmREZWxpbWl0ZXIvLCAncmVnZXhwJ10sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgLyhAc2lnaWxFbmREZWxpbWl0ZXIpW2EtekEtWl0qLyxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2VzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnJDE9PSRTNSc6IHsgdG9rZW46ICdyZWdleHAuZGVsaW1pdGVyJywgbmV4dDogJ0Bwb3AnIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAnQGRlZmF1bHQnOiAncmVnZXhwJ1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIHsgaW5jbHVkZTogJ0ByZWdleHBDb250ZW50JyB9XG4gICAgICAgIF0sXG4gICAgICAgIC8vIEZhbGxiYWNrIHRvIHRoZSBnZW5lcmljIHNpZ2lsIGJ5IGRlZmF1bHRcbiAgICAgICAgJ3NpZ2lsU3RhcnQuaW50ZXJwb2wnOiBbXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgL34oW2EtekEtWl0pQHNpZ2lsU3RhcnREZWxpbWl0ZXIvLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW46ICdzaWdpbC5kZWxpbWl0ZXInLFxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2hUbzogJ0BzaWdpbENvbnRpbnVlLiRTMi4kUzMuJFM0LiRTNSdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgIF0sXG4gICAgICAgICdzaWdpbENvbnRpbnVlLmludGVycG9sJzogW1xuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIC8oQHNpZ2lsRW5kRGVsaW1pdGVyKVthLXpBLVpdKi8sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjYXNlczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJyQxPT0kUzUnOiB7IHRva2VuOiAnc2lnaWwuZGVsaW1pdGVyJywgbmV4dDogJ0Bwb3AnIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAnQGRlZmF1bHQnOiAnc2lnaWwnXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgeyBpbmNsdWRlOiAnQHNpZ2lsQ29udGVudEludGVycG9sJyB9XG4gICAgICAgIF0sXG4gICAgICAgICdzaWdpbFN0YXJ0Lm5vSW50ZXJwb2wnOiBbXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgL34oW2EtekEtWl0pQHNpZ2lsU3RhcnREZWxpbWl0ZXIvLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW46ICdzaWdpbC5kZWxpbWl0ZXInLFxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2hUbzogJ0BzaWdpbENvbnRpbnVlLiRTMi4kUzMuJFM0LiRTNSdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgIF0sXG4gICAgICAgICdzaWdpbENvbnRpbnVlLm5vSW50ZXJwb2wnOiBbXG4gICAgICAgICAgICAvLyBJZ25vcmUgZXNjYXBlZCBzaWdpbCBlbmRcbiAgICAgICAgICAgIFsvKF58W15cXFxcXSlcXFxcQHNpZ2lsRW5kRGVsaW1pdGVyLywgJ3NpZ2lsJ10sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgLyhAc2lnaWxFbmREZWxpbWl0ZXIpW2EtekEtWl0qLyxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2VzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnJDE9PSRTNSc6IHsgdG9rZW46ICdzaWdpbC5kZWxpbWl0ZXInLCBuZXh0OiAnQHBvcCcgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdAZGVmYXVsdCc6ICdzaWdpbCdcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB7IGluY2x1ZGU6ICdAc2lnaWxDb250ZW50JyB9XG4gICAgICAgIF0sXG4gICAgICAgIC8vIEF0dHJpYnV0ZXNcbiAgICAgICAgYXR0cmlidXRlczogW1xuICAgICAgICAgICAgLy8gTW9kdWxlIEBkb2MqIGF0dHJpYnV0ZXMgLSB0b2tlbml6ZWQgYXMgY29tbWVudHNcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAvXFxAKG1vZHVsZXx0eXBlKT9kb2MgKH5bc1NdKT9cIlwiXCIvLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW46ICdjb21tZW50LmJsb2NrLmRvY3VtZW50YXRpb24nLFxuICAgICAgICAgICAgICAgICAgICBuZXh0OiAnQGRvdWJsZVF1b3RlZEhlcmVkb2NEb2NzdHJpbmcnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAvXFxAKG1vZHVsZXx0eXBlKT9kb2MgKH5bc1NdKT9cIi8sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbjogJ2NvbW1lbnQuYmxvY2suZG9jdW1lbnRhdGlvbicsXG4gICAgICAgICAgICAgICAgICAgIG5leHQ6ICdAZG91YmxlUXVvdGVkU3RyaW5nRG9jc3RyaW5nJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbL1xcQChtb2R1bGV8dHlwZSk/ZG9jIGZhbHNlLywgJ2NvbW1lbnQuYmxvY2suZG9jdW1lbnRhdGlvbiddLFxuICAgICAgICAgICAgLy8gTW9kdWxlIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgIFsvXFxAKEB2YXJpYWJsZU5hbWUpLywgJ3ZhcmlhYmxlJ11cbiAgICAgICAgXSxcbiAgICAgICAgZG91YmxlUXVvdGVkSGVyZWRvY0RvY3N0cmluZzogW1xuICAgICAgICAgICAgWy9cIlwiXCIvLCB7IHRva2VuOiAnY29tbWVudC5ibG9jay5kb2N1bWVudGF0aW9uJywgbmV4dDogJ0Bwb3AnIH1dLFxuICAgICAgICAgICAgeyBpbmNsdWRlOiAnQGRvY3N0cmluZ0NvbnRlbnQnIH1cbiAgICAgICAgXSxcbiAgICAgICAgZG91YmxlUXVvdGVkU3RyaW5nRG9jc3RyaW5nOiBbXG4gICAgICAgICAgICBbL1wiLywgeyB0b2tlbjogJ2NvbW1lbnQuYmxvY2suZG9jdW1lbnRhdGlvbicsIG5leHQ6ICdAcG9wJyB9XSxcbiAgICAgICAgICAgIHsgaW5jbHVkZTogJ0Bkb2NzdHJpbmdDb250ZW50JyB9XG4gICAgICAgIF0sXG4gICAgICAgIC8vIE9wZXJhdG9ycywgcHVuY3R1YXRpb24sIGJyYWNrZXRzXG4gICAgICAgIHN5bWJvbHM6IFtcbiAgICAgICAgICAgIC8vIENvZGUgcG9pbnQgb3BlcmF0b3IgKGVpdGhlciB3aXRoIHJlZ3VsYXIgY2hhcmFjdGVyID9hIG9yIGFuIGVzY2FwZWQgb25lID9cXG4pXG4gICAgICAgICAgICBbL1xcPyhcXFxcLnxbXlxcXFxcXHNdKS8sICdudW1iZXIuY29uc3RhbnQnXSxcbiAgICAgICAgICAgIC8vIEFub255bW91cyBmdW5jdGlvbiBhcmd1bWVudHNcbiAgICAgICAgICAgIFsvJlxcZCsvLCAnb3BlcmF0b3InXSxcbiAgICAgICAgICAgIC8vIEJpdHNoaWZ0IG9wZXJhdG9ycyAobXVzdCBnbyBiZWZvcmUgZGVsaW1pdGVycywgc28gdGhhdCA8PCA+PiBkb24ndCBtYXRjaCBmaXJzdClcbiAgICAgICAgICAgIFsvPDw8fD4+Pi8sICdvcGVyYXRvciddLFxuICAgICAgICAgICAgLy8gRGVsaW1pdGVyIHBhaXJzXG4gICAgICAgICAgICBbL1soKVxcW1xcXVxce1xcfV18PDx8Pj4vLCAnQGJyYWNrZXRzJ10sXG4gICAgICAgICAgICAvLyBUcmlwbGUgZG90IGlzIGEgdmFsaWQgbmFtZSAobXVzdCBnbyBiZWZvcmUgb3BlcmF0b3JzLCBzbyB0aGF0IC4uIGRvZXNuJ3QgbWF0Y2ggaW5zdGVhZClcbiAgICAgICAgICAgIFsvXFwuXFwuXFwuLywgJ2lkZW50aWZpZXInXSxcbiAgICAgICAgICAgIC8vIFB1bmN0dWF0aW9uID0+IChtdXN0IGdvIGJlZm9yZSBvcGVyYXRvcnMsIHNvIGl0J3Mgbm90IHRva2VuaXplZCBhcyA9IHRoZW4gPilcbiAgICAgICAgICAgIFsvPT4vLCAncHVuY3R1YXRpb24nXSxcbiAgICAgICAgICAgIC8vIE9wZXJhdG9yc1xuICAgICAgICAgICAgWy9Ab3BlcmF0b3IvLCAnb3BlcmF0b3InXSxcbiAgICAgICAgICAgIC8vIFB1bmN0dWF0aW9uXG4gICAgICAgICAgICBbL1s6OywuJV0vLCAncHVuY3R1YXRpb24nXVxuICAgICAgICBdLFxuICAgICAgICAvLyBHZW5lcmljIGhlbHBlcnNcbiAgICAgICAgc3RyaW5nQ29udGVudEludGVycG9sOiBbXG4gICAgICAgICAgICB7IGluY2x1ZGU6ICdAaW50ZXJwb2xhdGlvbicgfSxcbiAgICAgICAgICAgIHsgaW5jbHVkZTogJ0Blc2NhcGVDaGFyJyB9LFxuICAgICAgICAgICAgeyBpbmNsdWRlOiAnQHN0cmluZ0NvbnRlbnQnIH1cbiAgICAgICAgXSxcbiAgICAgICAgc3RyaW5nQ29udGVudDogW1svLi8sICdzdHJpbmcnXV0sXG4gICAgICAgIHN0cmluZ0NvbnN0YW50Q29udGVudEludGVycG9sOiBbXG4gICAgICAgICAgICB7IGluY2x1ZGU6ICdAaW50ZXJwb2xhdGlvbicgfSxcbiAgICAgICAgICAgIHsgaW5jbHVkZTogJ0Blc2NhcGVDaGFyJyB9LFxuICAgICAgICAgICAgeyBpbmNsdWRlOiAnQHN0cmluZ0NvbnN0YW50Q29udGVudCcgfVxuICAgICAgICBdLFxuICAgICAgICBzdHJpbmdDb25zdGFudENvbnRlbnQ6IFtbLy4vLCAnY29uc3RhbnQnXV0sXG4gICAgICAgIHJlZ2V4cENvbnRlbnRJbnRlcnBvbDogW1xuICAgICAgICAgICAgeyBpbmNsdWRlOiAnQGludGVycG9sYXRpb24nIH0sXG4gICAgICAgICAgICB7IGluY2x1ZGU6ICdAZXNjYXBlQ2hhcicgfSxcbiAgICAgICAgICAgIHsgaW5jbHVkZTogJ0ByZWdleHBDb250ZW50JyB9XG4gICAgICAgIF0sXG4gICAgICAgIHJlZ2V4cENvbnRlbnQ6IFtcbiAgICAgICAgICAgIC8vICMgbWF5IGJlIGEgcmVndWxhciByZWdleHAgY2hhciwgc28gd2UgdXNlIGEgaGV1cmlzdGljXG4gICAgICAgICAgICAvLyBhc3N1bWluZyBhICMgc3Vycm91bmRlZCBieSB3aGl0ZXNwYWNlIGlzIGFjdHVhbGx5IGEgY29tbWVudC5cbiAgICAgICAgICAgIFsvKFxccykoIykoXFxzLiopJC8sIFsnd2hpdGUnLCAnY29tbWVudC5wdW5jdHVhdGlvbicsICdjb21tZW50J11dLFxuICAgICAgICAgICAgWy8uLywgJ3JlZ2V4cCddXG4gICAgICAgIF0sXG4gICAgICAgIHNpZ2lsQ29udGVudEludGVycG9sOiBbXG4gICAgICAgICAgICB7IGluY2x1ZGU6ICdAaW50ZXJwb2xhdGlvbicgfSxcbiAgICAgICAgICAgIHsgaW5jbHVkZTogJ0Blc2NhcGVDaGFyJyB9LFxuICAgICAgICAgICAgeyBpbmNsdWRlOiAnQHNpZ2lsQ29udGVudCcgfVxuICAgICAgICBdLFxuICAgICAgICBzaWdpbENvbnRlbnQ6IFtbLy4vLCAnc2lnaWwnXV0sXG4gICAgICAgIGRvY3N0cmluZ0NvbnRlbnQ6IFtbLy4vLCAnY29tbWVudC5ibG9jay5kb2N1bWVudGF0aW9uJ11dLFxuICAgICAgICBlc2NhcGVDaGFyOiBbWy9AZXNjYXBlLywgJ2NvbnN0YW50LmNoYXJhY3Rlci5lc2NhcGUnXV0sXG4gICAgICAgIGludGVycG9sYXRpb246IFtcbiAgICAgICAgICAgIFsvI3svLCB7IHRva2VuOiAnZGVsaW1pdGVyLmJyYWNrZXQuZW1iZWQnLCBuZXh0OiAnQGludGVycG9sYXRpb25Db250aW51ZScgfV1cbiAgICAgICAgXSxcbiAgICAgICAgaW50ZXJwb2xhdGlvbkNvbnRpbnVlOiBbXG4gICAgICAgICAgICBbL30vLCB7IHRva2VuOiAnZGVsaW1pdGVyLmJyYWNrZXQuZW1iZWQnLCBuZXh0OiAnQHBvcCcgfV0sXG4gICAgICAgICAgICAvLyBJbnRlcnBvbGF0aW9uIGJyYWNrZXRzIG1heSBjb250YWluIGFyYml0cmFyeSBjb2RlLFxuICAgICAgICAgICAgLy8gc28gd2Ugc2ltcGx5IG1hdGNoIGFnYWluc3QgYWxsIHRoZSByb290IHJ1bGVzLFxuICAgICAgICAgICAgLy8gdW50aWwgd2UgcmVhY2ggaW50ZXJwb2xhdGlvbiBlbmQgKHRoZSBhYm92ZSBtYXRjaGVzKS5cbiAgICAgICAgICAgIHsgaW5jbHVkZTogJ0Byb290JyB9XG4gICAgICAgIF1cbiAgICB9XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/monaco-editor/esm/vs/basic-languages/elixir/elixir.js\n");

/***/ })

}]);